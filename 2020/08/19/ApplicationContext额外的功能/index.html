<!-- build time:Wed Aug 19 2020 12:43:46 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>ApplicationContext额外的功能 | Ubi-Potato</title><meta name="description" content="ApplicationContext额外的功能org.springframework.beans.factory 包提供了管理和使用bean的基本功能， org.springframework.context 包下添加了继承BeanFactory的ApplicationContext接口，其提供了额外的应用级功能ApplicationContext提供了如下功能：通过MessageSource接口"><meta name="keywords" content="spring core"><meta property="og:type" content="article"><meta property="og:title" content="ApplicationContext额外的功能"><meta property="og:url" content="https://ubisoft-potato.github.io/2020/08/19/ApplicationContext额外的功能/index.html"><meta property="og:site_name" content="Ubi-potato&#39;s Blog"><meta property="og:description" content="ApplicationContext额外的功能org.springframework.beans.factory 包提供了管理和使用bean的基本功能， org.springframework.context 包下添加了继承BeanFactory的ApplicationContext接口，其提供了额外的应用级功能ApplicationContext提供了如下功能：通过MessageSource接口"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2020-08-19T04:43:35.009Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ApplicationContext额外的功能"><meta name="twitter:description" content="ApplicationContext额外的功能org.springframework.beans.factory 包提供了管理和使用bean的基本功能， org.springframework.context 包下添加了继承BeanFactory的ApplicationContext接口，其提供了额外的应用级功能ApplicationContext提供了如下功能：通过MessageSource接口"><link rel="canonical" href="https://ubisoft-potato.github.io/2020/08/19/ApplicationContext额外的功能/index.html"><link rel="alternate" href="/atom.xml" title="Ubi-potato&#39;s Blog" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/Ubisoft-potato" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">Ubi-potato</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Developer</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 育碧,苏维埃</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/Ubisoft-potato" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/k3s/">k3s</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">3</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/configmap/">configmap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker基本概念/">docker基本概念</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graphql-java/">graphql-java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ingress/">ingress</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaBean/">javaBean</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rancher/">rancher</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-core/">spring core</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssl/">ssl</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式文件服务/">分布式文件服务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常处理/">异常处理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件上传/">文件上传</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动配置/">自动配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义/">自定义</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/configmap/" style="font-size:13px">configmap</a> <a href="/tags/docker/" style="font-size:14px">docker</a> <a href="/tags/docker基本概念/" style="font-size:13px">docker基本概念</a> <a href="/tags/graphql-java/" style="font-size:13px">graphql-java</a> <a href="/tags/ingress/" style="font-size:13px">ingress</a> <a href="/tags/javaBean/" style="font-size:13px">javaBean</a> <a href="/tags/mysql/" style="font-size:13px">mysql</a> <a href="/tags/rancher/" style="font-size:13px">rancher</a> <a href="/tags/spring-core/" style="font-size:14px">spring core</a> <a href="/tags/ssl/" style="font-size:13px">ssl</a> <a href="/tags/分布式文件服务/" style="font-size:13px">分布式文件服务</a> <a href="/tags/异常处理/" style="font-size:13px">异常处理</a> <a href="/tags/文件上传/" style="font-size:13.5px">文件上传</a> <a href="/tags/自动配置/" style="font-size:13px">自动配置</a> <a href="/tags/自定义/" style="font-size:13px">自定义</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">6</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/spring/">spring</a></p><p class="item-title"><a href="/2020/08/19/ApplicationContext额外的功能/" class="title">ApplicationContext额外的功能</a></p><p class="item-date"><time datetime="2020-08-19T04:42:43.000Z" itemprop="datePublished">2020-08-19</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/spring/">spring</a></p><p class="item-title"><a href="/2020/08/19/ioc-容器/" class="title">ioc 容器</a></p><p class="item-date"><time datetime="2020-08-19T04:39:08.000Z" itemprop="datePublished">2020-08-19</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/spring/">spring</a></p><p class="item-title"><a href="/2020/08/19/spring-bean/" class="title">spring bean</a></p><p class="item-date"><time datetime="2020-08-19T03:11:21.000Z" itemprop="datePublished">2020-08-19</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/k3s/">k3s</a></p><p class="item-title"><a href="/2019/12/07/k3s中使用configmap灵活配置/" class="title">k3s中使用configmap灵活配置</a></p><p class="item-date"><time datetime="2019-12-07T09:15:39.000Z" itemprop="datePublished">2019-12-07</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/k3s/">k3s</a></p><p class="item-title"><a href="/2019/11/03/k3s配置ingress使用ssl证书/" class="title">k3s配置ingress使用ssl证书</a></p><p class="item-date"><time datetime="2019-11-03T06:39:03.000Z" itemprop="datePublished">2019-11-03</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-ApplicationContext额外的功能" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">ApplicationContext额外的功能</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2020/08/19/ApplicationContext额外的功能/" class="article-date"><time datetime="2020-08-19T04:42:43.000Z" itemprop="datePublished">2020-08-19</time></a></span> <span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/spring/">spring</a></span> <span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link" href="/tags/spring-core/">spring core</a></span> <span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/08/19/ApplicationContext额外的功能/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 2.7k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 12(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h3 id="ApplicationContext额外的功能"><a href="#ApplicationContext额外的功能" class="headerlink" title="ApplicationContext额外的功能"></a><code>ApplicationContext</code>额外的功能</h3><p><code>org.springframework.beans.factory</code> 包提供了管理和使用bean的基本功能， <code>org.springframework.context</code> 包下添加了继承<code>BeanFactory</code>的<a href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener"><code>ApplicationContext</code></a>接口，其提供了额外的应用级功能</p><p><code>ApplicationContext</code>提供了如下功能：</p><ul><li>通过<code>MessageSource</code>接口进行国际化</li><li>通过<code>ResourceLoader</code>接口获取URLs或者文件等资源</li><li>事件发布，通过<code>ApplicationEventPublisher</code>通知实现<code>ApplicationListener</code>接口的bean</li><li>加载多个上下文环境（继承关系），通过<code>HierarchicalBeanFactory</code>使得每一个context能专注于其功能项，比如web应用的前端控制器层。</li></ul><h4 id="使用-MessageSource进行国际化"><a href="#使用-MessageSource进行国际化" class="headerlink" title="使用 MessageSource进行国际化"></a>使用 <code>MessageSource</code>进行国际化</h4><p><code>ApplicationContext</code>接口继承了<code>MessageSource</code>接口，因此<code>ApplicationContext</code>能够提供国际化的功能，Spring也提供<code>HierarchicalMessageSource</code>来支持分层处理国际化，接口定义的方法包括：</p><ul><li><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>: 从 <code>MessageSource</code>中获取国际化消息的基本方法。如果没有找到相应的国际化消息结果，则使用默认的值。使用 <code>MessageFormat</code>进行参数位置替换。</li><li><code>String getMessage(String code, Object[] args, Locale loc)</code>: 本质上和以上方法一样，唯一不同是不提供默认值，如果未找到则抛出 <code>NoSuchMessageException</code></li><li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>: 上述方法使用到的参数被封装到 <code>MessageSourceResolvable</code></li></ul><p>当<code>ApplicationContext</code>被加载时，会自动查询容器中的<code>MessageSource</code>bean，并且这个bean的名字必须为<code>messageSource</code>，如果找到<code>MessageSource</code>bean，所有相关的方法都会被代理到这个bean实现，如果未找到，<code>ApplicationContext</code>会查询其父容器中的<code>messageSource</code>bean，如果未找到任何<code>messageSource</code>bean，将会实例化<code>DelegatingMessageSource</code>进行使用。</p><p>spring提供了2个<code>MessageSource</code>实现类： <code>ResourceBundleMessageSource</code> 和 <code>StaticMessageSource</code>。并且都实现了<code>HierarchicalMessageSource</code>接口来实现消息合并国际化处理，<code>StaticMessageSource</code>使用的比较少，<code>ResourceBundleMessageSource</code>案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basenames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>format<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>exceptions<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>windows<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上表示类路径下有3个资源集合： <code>format</code>, <code>exceptions</code>， <code>windows</code> ，任何请求都将通过<code>ResourceBundle</code> – JDK的标准方式进行国际化处理。</p><p>国际化文件编写案例:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in format.properties</span></span><br><span class="line"><span class="attr">message</span>=<span class="string">Alligators rock!</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in exceptions.properties</span></span><br><span class="line">  <span class="meta">argument.required</span>=<span class="string">The &#123;0&#125; argument is required.</span></span><br></pre></td></tr></table></figure><p>通过代码使用<code>MessageSource</code>接口，记住：<code>ApplicationContext</code>实现了<code>MessageSource</code>接口，可以被强转为<code>MessageSource</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    String message = resources.getMessage(<span class="string">"message"</span>, <span class="keyword">null</span>, <span class="string">"Default"</span>, Locale.ENGLISH);</span><br><span class="line">    System.out.println(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alligators rock!</span><br></pre></td></tr></table></figure><p>解析：上述<code>MessageSource</code>定义在beans.xml中，<code>messageSource</code>bean通过<code>basenames</code>指定国际化资源文件。上述指定了3个文件： <code>format.properties</code>, <code>exceptions.properties</code>, <code>windows.properties</code></p><p><code>MessageSource</code>获取使用参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this MessageSource is being used in a web application --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"exceptions"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- lets inject the above MessageSource into this POJO --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"example"</span> <span class="attr">class</span>=<span class="string">"com.something.Example"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messages"</span> <span class="attr">ref</span>=<span class="string">"messageSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageSource messages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessages</span><span class="params">(MessageSource messages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message = <span class="keyword">this</span>.messages.getMessage(<span class="string">"argument.required"</span>,</span><br><span class="line">            <span class="keyword">new</span> Object [] &#123;<span class="string">"userDao"</span>&#125;, <span class="string">"Required"</span>, Locale.ENGLISH);</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The userDao argument is required.</span><br></pre></td></tr></table></figure><p>如果想要进行英国的国际化(<code>en-GB</code>），需要创建 <code>format_en_GB.properties</code>, <code>exceptions_en_GB.properties</code>, <code>windows_en_GB.properties</code>。比如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in exceptions_en_GB.properties</span></span><br><span class="line"><span class="meta">argument.required</span>=<span class="string">Ebagum lad, the ''&#123;0&#125;'' argument is required, I say, required.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">    MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">    String message = resources.getMessage(<span class="string">"argument.required"</span>,</span><br><span class="line">        <span class="keyword">new</span> Object [] &#123;<span class="string">"userDao"</span>&#125;, <span class="string">"Required"</span>, Locale.UK);</span><br><span class="line">    System.out.println(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ebagum lad, the &apos;userDao&apos; argument is required, I say, required.</span><br></pre></td></tr></table></figure><p>也可以使用 <code>MessageSourceAware</code> 接口来获取<code>MessageSource</code>对象，<code>ApplicationContext</code>中任何实现<code>MessageSourceAware</code>接口的对象在创建和被配置的时候都将被注入<code>MessageSource</code>对象。</p><p>tips：<code>ResourceBundleMessageSource</code>的一个可选实现是<code>ReloadableResourceBundleMessageSource</code>，<code>ReloadableResourceBundleMessageSource</code>比基于JDK的<code>ResourceBundleMessageSource</code>更加灵活，尤其是支持从任何spring资源加载位置读取（不仅仅是类路径）以及支持热加载， 详情：<a href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html" target="_blank" rel="noopener"><code>ReloadableResourceBundleMessageSource</code></a></p><h4 id="标准和自定义事件"><a href="#标准和自定义事件" class="headerlink" title="标准和自定义事件"></a>标准和自定义事件</h4><p><code>ApplicationContext</code>通过<code>ApplicationEvent</code>和<code>ApplicationListener</code>提供事件处理机制，如果容器中一个bean实现了<code>ApplicationListener</code>接口,每当有<code>ApplicationEvent</code>发布到<code>ApplicationContext</code>中就会通知此bean，本质上这就是观察者模式的实现。</p><p>Spring 4.2之后，事件机制得到增强，Spring提供了注解开发模式以及事件不再必须实现<code>ApplicationEvent</code>接口，当发布事件时，Spring自动将其封装为<code>ApplicationEvent</code>。</p><p>Spring提供的标准事件：</p><table><thead><tr><th align="left">Event</th><th align="left">Explanation</th></tr></thead><tbody><tr><td align="left"><code>ContextRefreshedEvent</code></td><td align="left">Published when the <code>ApplicationContext</code> is initialized or refreshed (for example, by using the <code>refresh()</code> method on the <code>ConfigurableApplicationContext</code> interface). Here, “initialized” means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the <code>ApplicationContext</code> object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen <code>ApplicationContext</code> actually supports such “hot” refreshes. For example, <code>XmlWebApplicationContext</code> supports hot refreshes, but <code>GenericApplicationContext</code> does not.</td></tr><tr><td align="left"><code>ContextStartedEvent</code></td><td align="left">Published when the <code>ApplicationContext</code> is started by using the <code>start()</code> method on the <code>ConfigurableApplicationContext</code> interface. Here, “started” means that all <code>Lifecycle</code> beans receive an explicit start signal. Typically, this signal is used to restart beans after an explicit stop, but it may also be used to start components that have not been configured for autostart (for example, components that have not already started on initialization).</td></tr><tr><td align="left"><code>ContextStoppedEvent</code></td><td align="left">Published when the <code>ApplicationContext</code> is stopped by using the <code>stop()</code> method on the <code>ConfigurableApplicationContext</code> interface. Here, “stopped” means that all <code>Lifecycle</code> beans receive an explicit stop signal. A stopped context may be restarted through a <code>start()</code> call.</td></tr><tr><td align="left"><code>ContextClosedEvent</code></td><td align="left">Published when the <code>ApplicationContext</code> is being closed by using the <code>close()</code> method on the <code>ConfigurableApplicationContext</code> interface or via a JVM shutdown hook. Here, “closed” means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted.</td></tr><tr><td align="left"><code>RequestHandledEvent</code></td><td align="left">A web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring’s <code>DispatcherServlet</code>.</td></tr><tr><td align="left"><code>ServletRequestHandledEvent</code></td><td align="left">A subclass of <code>RequestHandledEvent</code> that adds Servlet-specific context information.</td></tr></tbody></table><p>自定义事件案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedListEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockedListEvent</span><span class="params">(Object source, String address, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accessor and other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布事件需要调用<code>ApplicationEventPublisher</code>的 <code>publishEvent()</code> 方法，通常的做法是实现<code>ApplicationEventPublisherAware</code>接口，并将其注册为spring bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blockedList;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlockedList</span><span class="params">(List&lt;String&gt; blockedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockedList = blockedList;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 重写 setApplicationEventPublisher方法获取ApplicationEventPublisher</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publisher = publisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(String address, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blockedList.contains(address)) &#123;</span><br><span class="line">            publisher.publishEvent(<span class="keyword">new</span> BlockedListEvent(<span class="keyword">this</span>, address, content));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// send email...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring容器的配置期间，检测到<code>EmailService</code>实现了<code>ApplicationEventPublisherAware</code>接口，会自动调用<code>setApplicationEventPublisher()</code>方法，Spring会自动填充其参数，所以我们可以通过<code>ApplicationEventPublisher</code>与Spring容器交互。</p><p>为了能监听<code>ApplicationEvent</code>事件，需要实现<code>ApplicationListener</code>并将其注册为Spring bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedListNotifier</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">BlockedListEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notificationAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotificationAddress</span><span class="params">(String notificationAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notificationAddress = notificationAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(BlockedListEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationListener</code>带有范型，意味着<code>onApplicationEvent()</code>方法不需要我们进行强转，我们可以注册许多监听器，但是默认情况下监听器是同步接受事件的，也就是说 <code>publishEvent()</code> 在直到所有监听器被执行完之前是一只阻塞的，好处就是能在同一线程中执行，并且如果存在事务环境，也能保持一致。如果需要使用其他策略，考虑 <a href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html" target="_blank" rel="noopener"><code>ApplicationEventMulticaster</code></a>以及实现类 <a href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html" target="_blank" rel="noopener"><code>SimpleApplicationEventMulticaster</code></a></p><p>注册以上的bean进行使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"emailService"</span> <span class="attr">class</span>=<span class="string">"example.EmailService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blockedList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.spammer@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.hacker@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>john.doe@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blockedListNotifier"</span> <span class="attr">class</span>=<span class="string">"example.BlockedListNotifier"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"notificationAddress"</span> <span class="attr">value</span>=<span class="string">"blockedlist@example.org"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当<code>emailService</code>的 <code>sendEmail()</code> 被调用时，如果有黑名单中的邮件，则会发布<code>BlockedListEvent</code>，<code>blockedListNotifier</code>就会被通知</p><blockquote><p>spring的事件机制的设计是被用来处理同一个<code>ApllicationContext</code>中的Bean进行交互的，如果需要更加复杂的交互能力需要使用<a href="https://projects.spring.io/spring-integration/" target="_blank" rel="noopener">Spring Integration</a> ，能够构建轻量级、基于事件驱动的应用</p></blockquote><h5 id="基于注解的事件监听"><a href="#基于注解的事件监听" class="headerlink" title="基于注解的事件监听"></a>基于注解的事件监听</h5><p>Spring 4.2之后能够在任何Bean中的public方法上加上<code>@EventListener</code>注解完成事件监听，<code>blockedListNotifier</code>重新实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedListNotifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notificationAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotificationAddress</span><span class="params">(String notificationAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notificationAddress = notificationAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlockedListEvent</span><span class="params">(BlockedListEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果方法需要监听多个事件，并且想使用无参方法，也可以将事件声明到注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span>(&#123;ContextStartedEvent.class, ContextRefreshedEvent.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleContextStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还能够使用注解的<code>condition</code>属性进行事件过滤，并且是使用 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#expressions" target="_blank" rel="noopener"><code>SpEL</code> expression</a> （Spring表达式）条件配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span>(condition = <span class="string">"#blEvent.content == 'my-event'"</span>) <span class="comment">// 只有当BlockedListEvent事件中的content属性为my-event时才进行调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlockedListEvent</span><span class="params">(BlockedListEvent blockedListEvent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件上下文环境可用的元数据信息：</p><table><thead><tr><th align="left">Name</th><th align="left">Location</th><th align="left">Description</th><th align="left">Example</th></tr></thead><tbody><tr><td align="left">Event</td><td align="left">root object</td><td align="left">The actual <code>ApplicationEvent</code>.</td><td align="left"><code>#root.event</code> or <code>event</code></td></tr><tr><td align="left">Arguments array</td><td align="left">root object</td><td align="left">The arguments (as an object array) used to invoke the method.</td><td align="left"><code>#root.args</code> or <code>args</code>; <code>args[0]</code> to access the first argument, etc.</td></tr><tr><td align="left"><em>Argument name</em></td><td align="left">evaluation context</td><td align="left">The name of any of the method arguments. If, for some reason, the names are not available (for example, because there is no debug information in the compiled byte code), individual arguments are also available using the <code>#a&lt;#arg&gt;</code> syntax where <code>&lt;#arg&gt;</code> stands for the argument index (starting from 0).</td><td align="left"><code>#blEvent</code> or <code>#a0</code> (you can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> parameter notation as an alias)</td></tr></tbody></table><p><code>#root.event</code>能获取到底层的事件，即使监听方法签名参数接收的是自定义事件。</p><p>在处理完一个事件后，如果需要继续发布事件，只需要修改方法返回值即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListUpdateEvent <span class="title">handleBlockedListEvent</span><span class="params">(BlockedListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress and</span></span><br><span class="line">    <span class="comment">// then publish a ListUpdateEvent...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是此用法不支持异步调用监听器</p></blockquote><p>这个方法在美处理完一个<code>BlockedListEvent</code>事件后发布<code>ListUpdateEvent</code>事件，如果需要发布多个事件可以返回事件的<code>Collection</code>。</p><h5 id="异步监听器"><a href="#异步监听器" class="headerlink" title="异步监听器"></a>异步监听器</h5><p>只需在监听方法上加<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#scheduling-annotation-support-async" target="_blank" rel="noopener"> <code>@Async</code> </a>注解就能 完成异步监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlockedListEvent</span><span class="params">(BlockedListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BlockedListEvent is processed in a separate thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用异步监听器的局限性</strong>：</p><ul><li>如果异步监听器抛出异常，并不会被传递到调用者，详情参考<code>AsyncUncaughtExceptionHandler</code></li><li>异步监听器方法不支持上述发布连续的事件，如果需要进行发布连续事件，需要注入 <a href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html" target="_blank" rel="noopener"><code>ApplicationEventPublisher</code></a> 进行手动发布</li></ul><h5 id="监听器的执行顺序"><a href="#监听器的执行顺序" class="headerlink" title="监听器的执行顺序"></a>监听器的执行顺序</h5><p>添加<code>@Order</code>注解进行顺序编排：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">42</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBlockedListEvent</span><span class="params">(BlockedListEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通用事件"><a href="#通用事件" class="headerlink" title="通用事件"></a>通用事件</h5><p>在某些情况下，如果所有事件都遵循相同的结构，这可能会变得很通用性（就像前面示例中的事件一样）。 在这种情况下，可以实现<code>ResolvableTypeProvider</code>来指导框架获取运行时类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityCreatedEvent</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> <span class="keyword">implements</span> <span class="title">ResolvableTypeProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EntityCreatedEvent</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResolvableType <span class="title">getResolvableType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>EntityCreatedEvent&lt;T&gt;</code> 构造通用的事件，其中<code>T</code>是实际的事件实体，比如：只接收<code>EntityCreatedEvent</code>事件的监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPersonCreated</span><span class="params">(EntityCreatedEvent&lt;Person&gt; event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这不光对<code>ApplicationEvent</code>有效，而且可以是任意事件对象</p></blockquote></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://ubisoft-potato.github.io/2020/08/19/ApplicationContext额外的功能/" title="ApplicationContext额外的功能" target="_blank" rel="external">https://ubisoft-potato.github.io/2020/08/19/ApplicationContext额外的功能/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/Ubisoft-potato" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/Ubisoft-potato" target="_blank"><span class="text-dark">Ubi-potato</span><small class="ml-1x">Java Developer</small></a></h3><div>育碧牛逼</div></div></figure></div></div></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="next"><a href="/2020/08/19/ioc-容器/" title="ioc 容器"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/Ubisoft-potato" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2020 Ubi-potato<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>!function(T){var N={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};T.INSIGHT_CONFIG=N}(window)</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script><script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"c53ee0b8d298288412ed",clientSecret:"58f416214407143330670e24826f2ba6b16b7e34",repo:"BlogComments",owner:"Ubisoft-potato",admin:["Ubisoft-potato"],id:md5(location.pathname),distractionFreeMode:!0});gitalk.render("comments")</script></body></html><!-- rebuild by neat -->