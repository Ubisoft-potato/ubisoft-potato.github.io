{"meta":{"title":"Ubi-potato","subtitle":"Ubi-potato","description":null,"author":"Ubi-potato","url":"https://ubisoft-potato.github.io","root":"/"},"pages":[{"title":"书单","date":"2020-08-19T02:46:13.236Z","updated":"2020-08-19T02:46:13.236Z","comments":false,"path":"books/index.html","permalink":"https://ubisoft-potato.github.io/books/index.html","excerpt":"","text":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-19T06:01:36.891Z","comments":true,"path":"about/index.html","permalink":"https://ubisoft-potato.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-19T06:01:09.943Z","comments":true,"path":"categories/index.html","permalink":"https://ubisoft-potato.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-19T02:46:13.240Z","updated":"2020-08-19T02:46:13.240Z","comments":false,"path":"repository/index.html","permalink":"https://ubisoft-potato.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-19T02:46:13.240Z","updated":"2020-08-19T02:46:13.240Z","comments":true,"path":"links/index.html","permalink":"https://ubisoft-potato.github.io/links/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-08-19T06:07:37.000Z","updated":"2020-08-19T06:07:59.548Z","comments":true,"path":"contact/index.html","permalink":"https://ubisoft-potato.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-08-19T06:01:20.258Z","comments":true,"path":"tags/index.html","permalink":"https://ubisoft-potato.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring WebFlux并发模型","slug":"Spring-WebFlux并发模型","date":"2020-11-28T12:47:03.000Z","updated":"2020-11-29T06:03:41.002Z","comments":true,"path":"2020/11/28/spring-webflux-bing-fa-mo-xing/","link":"","permalink":"https://ubisoft-potato.github.io/2020/11/28/spring-webflux-bing-fa-mo-xing/","excerpt":"","text":"介绍主要说明Spring 5.0响应式编程底层的线程模型，并且对比Spring WebFlux的运行容器：Reactor Netty 、Tomcat响应式编程的动机典型的Web应用程序包含几个复杂的交互部分 ，并且他们之间大部分会相互阻塞：比如数据库调用阻塞I/O线程，但是，其他请求是独立的，可以同时执行，也可以并行执行。比如，多个用户请求可以被多个线程同时处理，在如今的多核处理器上有着明显的优势，这种并发模型也被称为 thread-per-request model （一个请求对应一个线程）：如上图所示，每个线程一次只能处理一个请求。虽然基于线程的并发模型为我们解决了部分问题，但它并不能解决我们在单个线程内进行的大多数交互仍在阻塞的事实。此外，就上下文切换而言，线程过多导致在Java中实现并发的本机线程的成本很高。随着Web应用程序面临越来越多的请求，thread-per-request model 模型并不能满足这种并发量。因此，需要一个种新的并发模型，该模型可以以相对较少的线程数来处理越来越多的请求。这是采用响应式编程的主要动机之一。响应式编程的并发模型响应式编程的核心是时间驱动，基于数据流的改变来做出相应的处理。因此，在完全无阻塞的环境中，这可以以更高的资源利用率（CPU）实现更高的并发。响应式编程在使用线程实现并发的方式与传统方式有着很大的区别，响应式编程带来的本质区别是异步。换句话说，程序处理请求的方式从一系列同步操作转为异步事件流。比如：在响应式编程里，调用数据库操作不会阻塞调用方线程，而是返回一个可以被其他线程订阅的Publisher对象，Subscriber可以在数据操作完成后得到通知（回掉）。最重要的是，响应式编程并不强调生成和使用哪些线程事件。重点是将程序构造为异步事件流。Publisher和Subscriber并不一定需要在同一个线程中，这有助于更好地利用可用线程，从而提高整体并发性。EventLoop线程EventLoop 事件循环是实现以更少的线程实现更高的并发性的关键：上图是事件循环的抽象设计，响应式编程的核心思想：EventLoop以单线程持续运行EventLoop按序从事件队列取出事件进行处理并且在注册相关回掉函数之后立即返回阻塞的操作比如：数据库调用、外部服务调用，会触发相关操作完成的回掉EventLoop可以触发操作完成通知的回调并将结果发送回原始调用方EventLoop模型已经有许多的实现，比如： Node.js, Netty 和 Ngnix，比起传统的web server( Apache HTTP Server, Tomcat, JBoss)拥有更好的可扩展性Spring WebFlux 响应式编程Spring WebFlux是Spring在5.0之后推出的响应式web技术栈:可以看到的是：Spring WebFlux和传统的web框架是平行的关系，并不是来替代Spring MVC特性：Spring WebFlux通过函数式路由扩展了传统的注解（@Controller）开发模型Spring WebFlux为Reactive Streams API适配了不同的HTTP运行时环境因此，能够支持许多响应式运行时环境包括：Servlet 3.1+ 容器Tomcat, Undertow、Reactor Netty同时还新增了WebClient，一个响应式、非阻塞、链式API的Http客户端不同运行时环境的线程模型响应式应用往往只使用少数几个线程，并充分利用它们。但是，线程的数量和性质取决于选择的实际Reactive Stream API运行时环境。Spring WebFlux已经适配了通过一个名为HttpHandler的接口适配了不同的运行时环境。这个类只有一个方法，对不同的服务器API（例如Reactor Netty，Servlet 3.1 API或Undertow API）进行抽象。虽然Reactor Netty是WebFlux应用程序中的默认服务器，但是仅声明一个正确的依赖关系即可切换到任何其他受支持的服务器：&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-webflux&lt;/artifactId> &lt;exclusions> &lt;exclusion> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-reactor-netty&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-tomcat&lt;/artifactId> &lt;/dependency>尽管可以通过多种方式观察在JVM中创建的线程，也可以通过如下方式简单获取：public void printThreads(){ Thread.getAllStackTraces() .keySet() .stream() .collect(Collectors.toList()); }Reactor NettyReactor Netty是WebFlux的默认运行时Server，不添加其他依赖，启动一个Spring WebFlux应用查看默认创建的线程信息：除去JVM的相关线程，在一台四核的机器上能看到以上线程信息，Netty产生了一堆用于请求处理的工作线程，这些通常不超过可用的CPU核心数。Netty使用Event Driving(事件循环) 模型为响应式异步提供高度可扩展的并发能力。EventLoopGroup管理一个或多个连续运行的EventLoop。因此，不建议创建比可用CPU核心数量更多的EventLoop。EventLoopGroup还为每个新创建的Channel分配一个EventLoop。因此，在Channel的生存期内，所有操作均由同一线程执行。Apache TomcatSpring WebFlux还支持传统的Servlet容器比如 Apache TomcatWebFlux依赖 Servlet 3.1 +的非阻塞I/O API，使用Servlet容器时需要通过底层适配，所以不能直接使用Servlet API使用Tomcat作为运行时环境线程信息：可以看到，与Netty有着很大区别：Tomcat会启动更多的工作线程，默认时是10Tomcat 5及更高版本在其Connector组件中支持NIO，该组件主要负责接收请求。Tomcat核心是Connector组件实现以支持NIO的线程模型。作为NioEndpoint模块的一部分，它由Acceptor，Poller和Worker组成：Tomcat产生一个或多个用于Acceptor，Poller和Worker的线程，通常有一个专用于Worker的线程池。WebClient 线程模型WebClient作为响应式Http Client是Spring WebFlux的一部分，可以在需要基于Restful的通信时使用它，能够创建端到端的全链路响应式应用使用WebClient使用WebClient非常简单，作为Spring WebFlux一部分，不需要倒入额外依赖：创建一个简单的RestAPI :@GetMapping(\"/index\") public Mono&lt;String> getIndex() { return Mono.just(\"Hello World!\"); }使用WebClient来进行响应式调用：WebClient.create(\"http://localhost:8080/index\").get() .retrieve() .bodyToMono(String.class) .doOnNext(s -> printThreads());WebClient线程模型WebClient也是使用event loop model来实现并发，并且依赖底层的运行时环境。如果使用Reactor Netty，WebClient将和Netty Server共用EventLoop，所以当使用WebClient时的线程情况和Reactor Netty中的一样，并不会创建额外的线程。WebClient也支持Servlet 3.1+ 的运行时环境比如：Jetty,此时应用的线程情况就非常不同了。当使用Jetty时，WebClient必须要创建自己的EventLoop：在某些情况下，为客户端和服务器使用单独的线程池可以提供更好的性能。WebFlux默认情况下共用EventLoop，如果需要获得更好的性能可以单独为WebClient创建线程池。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring webflux","slug":"spring-webflux","permalink":"https://ubisoft-potato.github.io/tags/spring-webflux/"}]},{"title":"关于Netty ByteBuf引用计数","slug":"关于Netty-ByteBuf引用计数","date":"2020-10-20T13:55:13.000Z","updated":"2020-11-28T12:57:29.891Z","comments":true,"path":"2020/10/20/guan-yu-netty-bytebuf-yin-yong-ji-shu/","link":"","permalink":"https://ubisoft-potato.github.io/2020/10/20/guan-yu-netty-bytebuf-yin-yong-ji-shu/","excerpt":"","text":"引言从Netty版本4之后，某些对象的生命周期由它们的引用计数来管理，这样Netty可以在不再使用它们时将它们（或它们的共享资源）返回到对象池（或对象分配器）。因为JVM的垃圾收集机制和引用队列不能提供不可达性的有效实时保证，而Netty的引用计数机制则提供了另一种方式来进行垃圾回收。ByteBuf就是引用计数的典范，它利用引用计数来提高分配和释放性能，接下来将说明Netty中的引用计数如何使用ByteBuf进行工作。引用计数的基本定义ByteBuf这类引用计数初始化时的引用计数为1：ByteBuf buf = ctx.alloc().directBuffer(); assert buf.refCnt() == 1;释放引用计数的对象时，其引用计数将减少1。如果引用计数达到0，则将引用计数的对象释放或返回到其来源的对象池中：assert buf.refCnt() == 1; // release() 将在引用计数减为0时返回true boolean destroyed = buf.release(); assert destroyed; assert buf.refCnt() == 0;当尝试去获取引用计数已经减为0的对象时，将会抛出IllegalReferenceCountException：assert buf.refCnt() == 0; try { buf.writeLong(0xdeadbeef); throw new Error(\"should not reach here\"); } catch (IllegalReferenceCountExeception e) { // Expected }增加引用计数只要还没有销毁引用计数对象，也可以通过retain()操作来增加它：ByteBuf buf = ctx.alloc().directBuffer(); assert buf.refCnt() == 1; buf.retain(); assert buf.refCnt() == 2; boolean destroyed = buf.release(); assert !destroyed; assert buf.refCnt() == 1; 谁负责销毁引用计数对象？一般的经验法则是，最后访问引用计数对象的一方也应负责销毁该引用计数对象。尤其是：通常发送引用计数的组件不需要负责销毁，而是留给接收此引用计数对象的组件进行决定如果一个组件最后消费引用计数对象并且知道除它本身外没有组件将会访问引用计数对象，那么它应该要负责销毁示例：public ByteBuf a(ByteBuf input) { input.writeByte(42); return input; } public ByteBuf b(ByteBuf input) { try { output = input.alloc().directBuffer(input.readableBytes() + 1); output.writeBytes(input); output.writeByte(42); return output; } finally { input.release(); // input 出了b方法调用外没有方法继续访问，在这里销毁掉 } } public void c(ByteBuf input) { System.out.println(input); input.release(); // 释放b方法产生的output } public void main() { ... ByteBuf buf = ...; // 此调用将会打印bytebuf到系统输出流并销毁bytebuf c(b(a(buf))); assert buf.refCnt() == 0; }行为谁应该负责释放谁负责释放1. main() 创建了 bufbuf→main()2. main() 调用 a() 传入 bufbuf→a()3. a() 仅仅是直接返回了 bufbuf→main()4. main()调用 b() 传入 bufbuf→b()5. b() 返回了 buf的拷贝buf→b(), copy→main()b() 释放 buf6. main() 调用 c() 传入 copycopy→c()7. c()消费 copycopy→c()c派生缓冲区ByteBuf.duplicate()，ByteBuf.slice()和ByteBuf.order(ByteOrder)创建一个派生缓冲区，该缓冲区共享父缓冲区的内存区域。派生的缓冲区没有自己的引用计数，只是共享父缓冲区的引用计数。ByteBuf parent = ctx.alloc().directBuffer(); ByteBuf derived = parent.duplicate(); // 创建一个派生缓冲区并不会增加引用计数 assert parent.refCnt() == 1; assert derived.refCnt() == 1;相反 ByteBuf.copy() 和 ByteBuf.readBytes(int) 并不产生派生缓冲区，其创建的 ByteBuf 需要被释放。注意：由于父缓冲区及其派生缓冲区共享相同的引用计数，并且在创建派生缓冲区时引用计数不会增加。因此，如果要将派生的缓冲区传递给应用程序的其他组件，则必须首先在其上调用retain()。ByteBuf parent = ctx.alloc().directBuffer(512); parent.writeBytes(...); try { while (parent.isReadable(16)) { ByteBuf derived = parent.readSlice(16); derived.retain(); // 派生缓冲区需要进行引用计数加一 process(derived); } } finally { parent.release(); // 2.释放父缓冲区 } ... public void process(ByteBuf buf) { ... buf.release(); // 1.释放派生缓冲区 }ByteBufHolder接口有时，缓冲区持有者（例如DatagramPacket，HttpContent和WebSocketframe）包含ByteBuf。这些类型扩展了一个称为ByteBufHolder的通用接口。 缓冲区持有者共享它包含的缓冲区的引用计数，就像派生缓冲区一样。ChannelHandler中的引用计数入站消息当事件循环(EventLoop)将数据读入ByteBuf并触发该channelRead()时，相应管道中的ChannelHandler负责释放缓冲区。因此，使用接收到的数据的处理程序应在其channelRead()处理程序方法中对该数据调用release():public void channelRead(ChannelHandlerContext ctx, Object msg) { ByteBuf buf = (ByteBuf) msg; try { ... } finally { buf.release(); } }在谁负责销毁引用计数对象章节写到，如果handler仅仅是将改引用计数对象传递到下一个handler，它就不需要负责销毁：public void channelRead(ChannelHandlerContext ctx, Object msg) { ByteBuf buf = (ByteBuf) msg; ... ctx.fireChannelRead(buf); }注意：在Netty中并不是仅只有ByteBuf是引用计数对象，比如，解码器产生的对象，很有可能是引用计数对象:// 假设handler在 `HttpRequestDecoder` 解码器之后 public void channelRead(ChannelHandlerContext ctx, Object msg) { if (msg instanceof HttpRequest) { HttpRequest req = (HttpRequest) msg; ... } if (msg instanceof HttpContent) { HttpContent content = (HttpContent) msg; try { ... } finally { content.release(); } } }如果不确定传入对象是否是引用计数对象，可以使用ReferenceCountUtil.release()进行释放：public void channelRead(ChannelHandlerContext ctx, Object msg) { try { ... } finally { ReferenceCountUtil.release(msg); } }除此之外SimpleChannelHandler也是一个不错的选择，它会在每次接收到数据之后调用ReferenceCountUtil.release(msg);出站消息与入站消息不同，出站消息是由应用程序创建的，Netty的责任是在将它们写到网络上后释放它们。但是，拦截写请求的处理程序(ChannelHandler)应确保正确释放任何中间对象。// 只是简单的传递引用计数对象 public void write(ChannelHandlerContext ctx, Object message, ChannelPromise promise) { System.err.println(\"Writing: \" + message); ctx.write(message, promise); } // 拦截引用计数对象并进行转化 public void write(ChannelHandlerContext ctx, Object message, ChannelPromise promise) { if (message instanceof HttpContent) { // 将 HttpContent 转化为 ByteBuf HttpContent content = (HttpContent) message; try { ByteBuf transformed = ctx.alloc().buffer(); .... ctx.write(transformed, promise); } finally { content.release(); // 释放 HttpContent } } else { // 传递非HttpContent 不需要进行释放 ctx.write(message, promise); } }解决内存泄露引用计数的缺点是容易泄漏引用计数的对象。由于JVM不会处理Netty实现的引用计数，因此一旦它们无法继续访问，即使它们的引用计数不为零，JVM也会自动对它们进行垃圾回收。垃圾回收后就无法恢复对象，因此无法将其返回到它来自的池中或者再释放掉，从而将导致内存泄漏。尽管很难发现泄漏，但是Netty默认情况下会抽样大约1％的缓冲区分配内存，以检查应用程序中是否存在泄漏。如果发生泄漏，将发现以下日志消息：LEAK: ByteBuf.release() was not called before it’s garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option ‘-Dio.netty.leakDetectionLevel=advanced‘ or call ResourceLeakDetector.setLevel()-Dio.netty.leakDetectionLevel=advancedResourceLeakDetector.setLevel()内存泄漏检测级别DISABLED - 关闭内存泄漏检测，不推荐SIMPLE - 默认级别。ADVANCED - 高级检测模式PARANOID - 和 ADVANCED 模式类似为每一个ByteBuf进行检测，在自动测试阶段很有帮助，如果输出了LEAK:构建就会失败能够提早发现内存泄漏点通过JVM启动参数进行指定 JVM option -Dio.netty.leakDetection.leveljava -Dio.netty.leakDetection.level=advanced ...此属性对应 io.netty.leakDetectionLevel防止内存泄漏最佳实践以PARANOID级别运行单元测试检测内存泄漏如果发现内存泄漏使用ADVANCED级别进行泄漏点定位","categories":[{"name":"Netty","slug":"Netty","permalink":"https://ubisoft-potato.github.io/categories/Netty/"}],"tags":[{"name":"netty byteBuf","slug":"netty-byteBuf","permalink":"https://ubisoft-potato.github.io/tags/netty-byteBuf/"}]},{"title":"Netty 进阶之路笔记 (一)","slug":"Netty-进阶之路笔记（一）","date":"2020-09-19T01:45:48.000Z","updated":"2020-11-29T06:05:33.803Z","comments":true,"path":"2020/09/19/netty-jin-jie-zhi-lu-bi-ji-yi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/09/19/netty-jin-jie-zhi-lu-bi-ji-yi/","excerpt":"","text":"Netty服务端意外退出案例一服务端程序在bind()方法阻塞执行完后直接退出public static void main(string[] args){ ServerBootstrap serverBootstrap = new ServerBootstrap(); EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(8); try{ serverBootstrap .channel(NioServerSocketChannel.class) .group(bossGroup, workerGroup) .childHandler(new RpcServerInitializer(60L, this.beanRegistry)) .option(ChannelOption.SO_BACKLOG, 128); serverBootstrap.bind(serverAddress, serverPort).sync(); }finally{ bossGroup.shutDownGracefully(); workerGroup.shutDownGracefully(); } }原因：在服务端进行绑定后，无论如何都将执行finally代码块中的方法，将EventLoopGroup关闭掉，此时主线程也执行完退出，EventLoopGroup作为用户进程也被关闭，导致服务端bind到指定端口后直接退出案例二当添加服务端channel的closeFuture之后仍然出现服务端退出现象public static void main(string[] args){ ServerBootstrap serverBootstrap = new ServerBootstrap(); EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(8); try{ serverBootstrap .channel(NioServerSocketChannel.class) .group(bossGroup, workerGroup) .childHandler(new RpcServerInitializer(60L, this.beanRegistry)) .option(ChannelOption.SO_BACKLOG, 128); Channel channel = serverBootstrap.bind(serverAddress, serverPort).sync().channel(); channel.closeFuture().addListener(ChannelFutureListener.CLOSE); }finally{ bossGroup.shutDownGracefully(); workerGroup.shutDownGracefully(); } }原因： channel.closeFuture().addListener(ChannelFutureListener.CLOSE)执行过程完全是异步的，只是在channel关闭时回掉ChannelFutureListener进行相关操作，并不会因此阻塞在这行代码，所以相当于直接进入finally代码块，关闭了NioEventLoopGroup，没有了用户进程，服务端就直接退出了。避免方法方案一让主线程在服务端channel的closeFuture上进行阻塞直到服务端channel关闭public static void main(string[] args){ ServerBootstrap serverBootstrap = new ServerBootstrap(); EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(8); try{ serverBootstrap .channel(NioServerSocketChannel.class) .group(bossGroup, workerGroup) .childHandler(new RpcServerInitializer(60L, this.beanRegistry)) .option(ChannelOption.SO_BACKLOG, 128); Channel channel = serverBootstrap.bind(serverAddress, serverPort).sync().channel(); channel.closeFuture().sync().addListener(ChannelFutureListener.CLOSE); }finally{ bossGroup.shutDownGracefully(); workerGroup.shutDownGracefully(); } }方案二（推荐）使用JDK的ShutdownHook进行实现，删除掉finally块的NioEventLoopGroup的关闭代码，将其移动到ShutdownHook的关闭线程中。public static void main(string[] args){ ServerBootstrap serverBootstrap = new ServerBootstrap(); EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(8); serverBootstrap .channel(NioServerSocketChannel.class) .group(bossGroup, workerGroup) .childHandler(new RpcServerInitializer(60L, this.beanRegistry)) .option(ChannelOption.SO_BACKLOG, 128); serverBootstrap.bind(serverAddress, serverPort).sync(); Runtime.getRuntime().addShutdownHook(new Thread(()->{ bossGroup.shutDownGracefully(); workerGroup.shutDownGracefully(); }, \"server-killer\")); }方案三（推荐）除了ShutdownHook还有通过监听信号量注册signalHanlder的方式进行优雅退出，但是需要判断不同操作系统的中断信号类型，如果是windows系统，则是SIGINT，否则选择SIGTERM信号，然后进行回掉注册：Signal.handle(sig,shutdownHandler)","categories":[{"name":"Netty","slug":"Netty","permalink":"https://ubisoft-potato.github.io/categories/Netty/"}],"tags":[{"name":"netty","slug":"netty","permalink":"https://ubisoft-potato.github.io/tags/netty/"}]},{"title":"SpringBoot 应用特性 - SpringApplication","slug":"SpringBoot-应用特性-SpringApplication","date":"2020-09-17T01:51:19.000Z","updated":"2020-09-20T08:00:23.757Z","comments":true,"path":"2020/09/17/springboot-ying-yong-te-xing-springapplication/","link":"","permalink":"https://ubisoft-potato.github.io/2020/09/17/springboot-ying-yong-te-xing-springapplication/","excerpt":"","text":"SpringApplicationSpringApplication类提供了一种便捷的方式来引导从main（）方法启动的Spring应用程序。通常可以委托给静态SpringApplication.run方法来启动应用程序，如以下示例所示：public static void main(String[] args) { SpringApplication.run(MySpringConfiguration.class, args); }默认情况下，显示INFO日志消息，包括一些相关的启动详细信息，例如启动应用程序的用户。如果需要打印除INFO以外的其他日志级别，则可以按照日志级别中的说明进行设置。使用主应用程序类包中的实现版本来确定应用程序版本。可以通过将spring.main.log-startup-info设置为false来关闭启动信息记录。同时还会关闭对应用程序活动配置文件的日志记录。要在应用启动期时添加其他日志记录，可以在SpringApplication的子类中重写logStartupInfo（boolean）启动失败如果应用启动失败，可以通过FailureAnalyzers提供额外的错误消息和解决问题的措施，比如：使用8080端口部署web应用，但是端口已经被占用，Spring会显示如下信息：*************************** APPLICATION FAILED TO START *************************** Description: Embedded servlet container failed to start. Port 8080 was already in use. Action: Identify and stop the process that&#39;s listening on port 8080 or configure this application to listen on another port.这是由于Spring自身提供了许多FailureAnalyzer实现来将应用程序启动时错误转化为人类可读的错误信息，所以我们也可以自己实现FailureAnalyzer捕获启动时异常。通过设置应用程序日志等级为debug能获取到完整的异常信息：logging.level.root=warn logging.level.org.springframework.web=debug logging.level.org.hibernate=error或者： java -jar myproject-0.0.1-SNAPSHOT.jar --debug延迟加载SpringApplication允许延迟地初始化应用程序。启用延迟初始化后，将根据需要创建bean，而不是在应用程序启动期间创建bean。这样做的结果就是可以减少应用程序启动所花费的时间。在Web应用程序中，启用延迟初始化将导致许多与Web相关的Bean直到收到HTTP请求后才被初始化。延迟初始化的缺点是，它可能会延迟发现应用程序问题的时间点。如果错误配置的Bean延迟初始化，则启动期间将不再发生故障，只有在初始化Bean时问题才会出现。同时还必须注意确保JVM具有足够的内存来容纳所有应用程序的bean，而不仅仅是启动期间初始化的bean。由于这些原因，默认情况下不会启用延迟初始化，因此建议在启用延迟初始化之前先对JVM的堆大小进行微调。延迟加载可以通过SpringApplicationBuilder的lazyInitialization方法或者SpringApplication的setLazyInitialization方法进行手动设置，另一种方法就是使用配置文件进行配置：spring: main: lazy-initialization: true如果要在对应用程序其余部分使用延迟初始化时禁用某些Bean的延迟初始化，则可以使用@Lazy（false）注解将它们的延迟加载属性显式设置为false。自定义SpringApplication如果SpringApplication的默认设置不符合需求，则可以创建一个本地实例并对其进行自定义。例如，要关闭Spring的Banner：public static void main(String[] args) { SpringApplication app = new SpringApplication(MySpringConfiguration.class); app.setBannerMode(Banner.Mode.OFF); app.run(args); }传递给SpringApplication的构造函数参数是Spring bean的配置源(@ComponetScan注解)。在大多数情况下，它们是对@Configuration类的引用，但也可以是对XML配置或应扫描的程序包的引用。链式调用API如果需要构建ApplicationContext层次结构（具有父/子关系的多个上下文），或者需要使用“流式”API，则可以使用SpringApplicationBuilder。public void static main(String[] args){ new SpringApplicationBuilder() .sources(Parent.class) .child(Application.class) .bannerMode(Banner.Mode.OFF) .logStartupInfo(true) .registerShutdownHook(true) .run(args); }创建父子ApplicationContext时有一些限制。例如，Web组件必须包含在子上下文中，并且父上下文和子上下文都使用相同的环境。因为子ApplicationContext能获取到父ApplicationContext中的bean而父ApplicationContext不能获取到子ApplicationContext中的bean。事件监听除了通常的Spring Framework运行时事件（例如ContextRefreshedEvent）之外，SpringApplication在启动应用时还会发送一些其他应用程序事件。有些事件在ApplicationContext被创建完成之前发布的，所以如果通过@Bean的方式注册监听器是无法监听到这类事件。可以通过SpringApplication.addListeners(…)或者SpringApplicationBuilder.listeners(…)方在启动前法进行手动注册。如果需要自动完成这类监听器注册，可以通过META-INF/spring.factories文件进行注册，在文件中加入：org.springframework.context.ApplicationListener=com.example.project.MyListener应用事件按如下顺序发送：ApplicationStartingEvent：在应用运行开始时发部，但在进行任何处理之前（监听器和初始化器initializer的注册除外）。ApplicationEnvironmentPreparedEvent：当Environment 对象初始化完成进行使用时，但此时上下文还没有创建。ApplicationContextInitializedEvent：当ApplicationContext已经初始化完成并且ApplicationContextInitializers都已经被调用，此时bean定义还未被加载ApplicationPreparedEvent：在ioC容器刷新之前，bean定义被加载之后发布ApplicationStartedEvent：在ioC容器刷新之后，Application和Command-line Runner被调用之前发布。AvailabilityChangeEvent：带有LivenessState.CORRECT属性指示应用已经上线ApplicationReadyEvent：在所有的Application和Command-line Runner被调用之后发布AvailabilityChangeEvent：带有ReadinessState.ACCEPTING_TRAFFIC属性指示应用已经可以接受请求ApplicationFailedEvent：当应用启动异常时发布上面的列表仅包括绑定到SpringApplication的SpringApplicationEvents。除这些之外，以下事件也将在ApplicationPreparedEvent之后和ApplicationStartedEvent之前发布:WebServerInitializedEvent:当WebServer初始化完成时发布，ServletWebServerInitializedEvent和ReactiveWebServerInitializedEvent分别对应servlet和响应式（webFlux）应用。ContextRefreshedEvent：当ApplicationContext已经刷新完成（bean已经创建完成）应用程序事件是通过使用Spring Framework的事件发布机制发送的。此机制的一部分确保在子级上下文中发布给监听器的事件也可以在任何父级上下文中发布给监听器。如果应用程序使用SpringApplication实例的层次结构，则监听器可能会收到同一类型的应用程序事件的多个实例。如果需要监听器能够区分其上下文的事件和子级上下文的事件，需要注入其应用程序上下文，然后将注入的上下文与接收到事件所属的上下文进行比较。可以通过实现ApplicationContextAware来注入上下文，或者，如果监听器本身是bean，则可以使用@Autowired注入上下文。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"自定义Spring应用","slug":"自定义Spring应用","permalink":"https://ubisoft-potato.github.io/tags/自定义Spring应用/"}]},{"title":"spring cloud gateway入门","slug":"spring-cloud-gateway入门","date":"2020-09-10T13:29:29.000Z","updated":"2020-09-20T08:01:48.077Z","comments":true,"path":"2020/09/10/spring-cloud-gateway-ru-men/","link":"","permalink":"https://ubisoft-potato.github.io/2020/09/10/spring-cloud-gateway-ru-men/","excerpt":"","text":"Spring Cloud Gateway简介Zuul闭源之后，Spring开发了Spring新一代微服务网关Spring Cloud Gateway来代替Zuul，基于Spring5、Spring boot 2以及project Reactor。Spring Cloud Gateway旨在提供一种简单的、有效的方式来路由API。Spring Cloud Gateway基于Spring WebFlux以及使用Netty作为底层的网络通信框架，所以之前使用到的同步框架或者使用方式会不适用。Maven依赖：&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-gateway&lt;/artifactId> &lt;/dependency>Spring Cloud Gateway术语Route: 构建网关的基本模块。路由 ID, 目标 URI, 一系列断言（predicates）, 以及一组过滤器（ filters）组成了一个路由，当这些断言对请求路径的匹配结果返回true时，网关才会进行处理。Predicate: Java 8 的函数式断言接口.。入参是 Spring Framework ServerWebExchange。能够匹配请求体里的任何信息，比如：http header，url。Filter: 使用具体的工厂类创建的Spring Framework GatewayFilter。通过过滤器可以修改请求体在发送请求到下游的服务之前，或是在得到下游服务响应体后修改响应体。架构图客户端将请求发送到Spring Cloud Gateway，Gateway Handler Mapping进行路由匹配，如果匹配成功则Gateway web handler会处理请求：请求会通过一组预先设定好的过滤器。大概流程是先执行预过滤逻辑、执行请求、得到结果执行后置过滤。配置路由路由可以通过配置文件配置和Java代码配置，配置文件配置又可以分为简化配置和全参配置。简化配置spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - Cookie=mycookie,mycookievalue这段yaml配置了一个Cookie路由断言，将会匹配cookie名为mycookie值为mycookievalue的请求。全参配置spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - name: Cookie args: name: mycookie regexp: mycookievalue这段配置与上面的路由配置一样，但是使用了args作为键来配置具体的断言参数Java 代码配置通过RouteLocatorBuilder可以进行链式调用构建路由：@Configuration public class RouteConfig { @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return builder .routes() .route(\"after_route\", r -> r.cookie(\"mycookie\", \"mycookievalue\").uri(\"https://example.org\")) .build(); } }总结Spring Cloud Gateway作为新一代微服务网关提供了易于配置路由的特性，但是其底层使用到了异步、NIO、响应式编程，所以如果需要进行深入开发，开发者需要改变传统的编程思维。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://ubisoft-potato.github.io/tags/spring-cloud/"}]},{"title":"spring 资源加载机制","slug":"spring-资源加载机制","date":"2020-09-08T01:35:22.000Z","updated":"2020-09-20T08:25:14.613Z","comments":true,"path":"2020/09/08/spring-zi-yuan-jia-zai-ji-zhi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/09/08/spring-zi-yuan-jia-zai-ji-zhi/","excerpt":"","text":"Spring资源加载机制介绍Java标准APIjava.net.URL能够处理URL资源，但是却不能处理”低等级”的资源，比如，没有标准化的URL实现用来加载类路径的资源， 虽然可以注册用于特殊URL前缀的新处理程序（类似于用于诸如http：的现有前缀的处理程序），但这通常相当复杂，并且URL接口仍然缺少某些理想的功能，例如用于检查是否存在的方法 指向的资源。Resource接口定义Spring的Resource接口抽象出了处理低级资源的方法：public interface Resource extends InputStreamSource { boolean exists(); boolean isOpen(); URL getURL() throws IOException; File getFile() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription(); }Resource集成了InputStreamSource接口：public interface InputStreamSource { InputStream getInputStream() throws IOException; }Resource中比较重要的方法是：getInputStream(): 定位并打开资源,返回 InputStream 用于读取资源。作为调用方必须在使用完后关闭这个流。exists(): 返回 boolean 值，判断资源是否存在.isOpen(): 返回 boolean 值，判断当前资源是否已经在被处理，如果返回 true, InputStream 不能同时被调用，同一时间只能有一个调用者，并且必须被关闭防止资源。常规资源的实现通常返回 false。getDescription(): 通常用于处理异常时，返回该resource的说明。结果通常是返回文件的完整名称或是资源的实际URL如果其底层实现支持的话，其他的方法则可以获取URL和File对象。Spring本身许多需要操作资源的方法签名都是使用Resource接口，还有一部分Spring的API接收资源的路径，并且会根据路径的前缀自动创建合适的Resource对象。尽管Spring经常使用Resource接口，但实际上，在自己的代码中单独使用Resource接口类作为通用实用工具类来访问资源非常有用，即使我们的代码不了解或不关心其他Spring的任何东西ResourceAPI并没有替换任何功能，只是在相关的场景进行包装，比如，UrlResource包装了URL，并且实际上是使用这个URL来进行相关操作Spring提供的Resource实现UrlResourceClassPathResourceFileSystemResourceServletContextResourceInputStreamResourceByteArrayResourceUrlResourceUrlResource包装了java.net.URL，可以被用来获取常规资源，比如：文件、http资源、ftp资源，所有的URL都使用String进行表述，并且都包含了适当的资源路径前缀。file:用于读取文件系统，http:获取Http协议资源，ftp:获取FTP文件等UrlResource可以通过构造器显式的创建，但是通常都是调用的Spring API接收String类型的路径参数自动创建合适的Resource实现类，当其无法识别路径前缀才创建UrlResource。ClassPathResourceClassPathResource用于加载类路径的资源，使用当前线程的类加载器或给定的类加载器进行资源加载。如果类路径资源已经被解压到文件系统，则会将资源加载为java.io.File,为了解决这个问题，许多Resource的实现总是支持解析为java.net.URLFileSystemResource支持处理 java.io.File 和 java.nio.file.Path。ServletContextResourceServletContext资源的Resource实现，用于解析相关Web应用程序根目录中的相对路径。它始终支持流访问和URL访问，但仅在Jar包被解压才允许java.io.File访问。 不管是解压还是直接访问文件系统、或者直接从JAR或其他类似数据库访问，取决于Servlet容器。InputStreamResource适用于给定的InputStream，应该被用于未指定的Resource的情况下进行适配。通常情况下isOpen()返回true，意味着不能多次读取流。ByteArrayResource将会创建一个ByteArrayResource基于给定的字节数组，比使用InputStreamResource更有效。ResourceLoader接口ResourceLoader接口需要被那些能够加载资源的对象实现：public interface ResourceLoader { Resource getResource(String location); }所有的ApplicationContext都实现了ResourceLoader接口，因此可以被用来获取相关的Resource实例。更具具体的ApplicationContext实现类，通常不需要加资源路径的前缀，比如通过ClassPathXmlApplicationContext加载：public void loadresource(){ Resource template = ctx.getResource(\"some/resource/path/myTemplate.txt\"); }以上代码将返回ClassPathResource，如果换成FileSystemXmlApplicationContext，将会得到FileSystemResource，而对于WebApplicationContext来说，将会返回ServletContextResource。如果需要强制使用类路径加载则也可以指定路径前缀classpath:public void loadresource(){ Resource template = ctx.getResource(\"classpath:some/resource/path/myTemplate.txt\"); }同样的，指定使用UrlResource需要指定file 或 http 前缀：public void loadresource(){ Resource template = ctx.getResource(\"file:///some/resource/path/myTemplate.txt\"); Resource template = ctx.getResource(\"https://myhost.com/resource/path/myTemplate.txt\"); }资源前缀表：前缀案例解析classpath:classpath:com/myapp/config.xml从类路径加载file:file:///data/config.xml作为 URL 从文件系统加载http:https://myserver/logo.png作为 URL加载(none)/data/config.xml具体由ApplicationContext实现决定ResourceLoaderAware接口ResourceLoaderAware是一个特殊的回掉接口，任何实现这个接口的bean意味着bean需要获取ResourceLoader的引用。public interface ResourceLoaderAware { void setResourceLoader(ResourceLoader resourceLoader); }Spring ioC容器会自动检测到所有实现ResourceLoaderAware接口的bean并且回掉setResourceLoader(ResourceLoader)方法，为当前bean设置ResourceLoader引用。另一种获取ResourceLoader的方式是通过@Autowired自动装配。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"springBoot @async详解","slug":"springBoot-async详解","date":"2020-09-02T06:20:15.000Z","updated":"2020-09-20T08:10:33.581Z","comments":true,"path":"2020/09/02/springboot-async-xiang-jie/","link":"","permalink":"https://ubisoft-potato.github.io/2020/09/02/springboot-async-xiang-jie/","excerpt":"","text":"1、SpringBoot异步处理支持Spring提供了@Aysnc注解进行便捷的异步处理支持,只需要在bean的方法上标注@Async注解即可使得方法异步提交到线程池处理，调用方无需等待。2、如何使用？在SpringBoot中使用只需使用Java代码配置或者XML配置：@Configuration @EnableAsync public class SpringAsyncConfig { ... } @EnableAsync有值得注意的属性：annotation – 默认情况下， @EnableAsync 只检测 Spring的 @Async 注解 和 EJB 3.1的 javax.ejb.Asynchronous注解；这个属性可以配置额外的需要检测的注解，所以我们可以自定义注解。mode – 指定异步代理类生成模式 – JDK 或者 AspectJ 织入proxyTargetClass – 指定使用的代理模式 -CGLIB 或者 JDK; 这个属性只有在将上述 mode 属性设置为 AdviceMode.PROXY才有效order – 设置 AsyncAnnotationBeanPostProcessor后置处理器的调用优先级,默认情况下，这个后置处理器是最后执行，确保能代理所有bean3、@Async注解@Async有2个限制使用条件：必须使用在public方法上，因为私有的方法无法被代理自我调用 – 在同一个类中调用标注@Async的方法。因为在代理类中调用会直接调用原对象的方法3.1、方法返回void@Async public void asyncMethodWithVoidReturnType() { System.out.println(\"Execute method asynchronously. \" + Thread.currentThread().getName()); }3.2、方法具有返回值如果方法有返回值，则需要用Future进行包装：@Async public Future&lt;String> asyncMethodWithReturnType() { System.out.println(\"Execute method asynchronously - \" + Thread.currentThread().getName()); try { Thread.sleep(5000); return new AsyncResult&lt;String>(\"hello world !!!!\"); } catch (InterruptedException e) { // } return null; }Spring提供了一个AsyncResult类，它实现了JDK的Future接口，可以用来跟踪异步方法执行的结果。public void testAsyncAnnotationForMethodsWithReturnType() throws InterruptedException, ExecutionException { System.out.println(\"Invoking an asynchronous method. \" + Thread.currentThread().getName()); Future&lt;String> future = asyncAnnotationExample.asyncMethodWithReturnType(); while (true) { if (future.isDone()) { System.out.println(\"Result from asynchronous process - \" + future.get()); break; } System.out.println(\"Continue doing something else. \"); Thread.sleep(1000); } }4、配置线程池默认，Spring使用SimpleAsyncTaskExecutor来执行异步任务，但是可以在应用级和方法级进行自定义线程池：4.1、方法级自定义线程池首先配置一个自定义的线程池bean：@Configuration @EnableAsync public class SpringAsyncConfig { @Bean(name = \"threadPoolTaskExecutor\") public Executor threadPoolTaskExecutor() { return new ThreadPoolTaskExecutor(); } }在@Async注解上指定该方法允许的线程池：@Async(\"threadPoolTaskExecutor\") public void asyncMethodWithConfiguredExecutor() { System.out.println(\"Execute method with configured executor - \" + Thread.currentThread().getName()); }4.2、应用级自定义线程池给整个应用配置默认的线程池需要实现AsyncConfigurer接口，需要实现其getAsyncExecutor()方法，这个方法放回的线程池作为整个应用的异步任务线程池@Configuration @EnableAsync public class SpringAsyncConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { return new ThreadPoolTaskExecutor(); } }5、异常处理如果一步方法返回Future，处理异常非常简单，因为Future.get()方法会抛出异常，但是如果返回void，异常不会传递到调用线程，所以需要额外的配置来进行处理这类异常。通过实现AsyncUncaughtExceptionHandler接口，自定义异步异常处理，实现handleUncaughtException()方法捕获异步处理的异常：public class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler { @Override public void handleUncaughtException( Throwable throwable, Method method, Object... obj) { System.out.println(\"Exception message - \" + throwable.getMessage()); System.out.println(\"Method name - \" + method.getName()); for (Object param : obj) { System.out.println(\"Parameter value - \" + param); } } }同时需要在上述的AsyncConfigurer的实现类中实现getAsyncUncaughtExceptionHandler()方法来注册这个异常处理器：@Configuration @EnableAsync public class SpringAsyncConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { return new ThreadPoolTaskExecutor(); } @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return new CustomAsyncExceptionHandler(); } }","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://ubisoft-potato.github.io/tags/异步/"}]},{"title":"spring cloud context 介绍","slug":"spring-cloud-context-介绍","date":"2020-08-29T07:21:26.000Z","updated":"2020-09-20T08:12:09.140Z","comments":true,"path":"2020/08/29/spring-cloud-context-jie-shao/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/29/spring-cloud-context-jie-shao/","excerpt":"","text":"Spring Cloud 核心库简介Spring Cloud Commons工程提供了两个库功能：Spring Cloud Context和Spring Cloud Commons。 Spring Cloud Context为Spring Cloud应用程序的ApplicationContext（bootstrap引导程序上下文，encryption加密，refreshScope刷新作用域和环境端点）提供实用程序和特殊服务。 Spring Cloud Commons是在不同的Spring Cloud实现中使用的一组抽象和通用类（例如，Spring Cloud Netflix与Spring Cloud Consul以及现在的Spring cloud Alibaba）。Spring Cloud ContextBootstrap ContextTextEncryptor 组件Refresh Scope（当bean的属性在外部被修改时，bean会被重新创建而应用不需要重启）Environment对象监控Spring Cloud CommonsDiscoveryClient 接口ServiceRegistry 接口RestTemplate 使用 DiscoveryClient来获取目标主机hostSpring Cloud Context启动级上下文一个spring cloud应用依赖一个bootstrap上下文运作，它是整个应用中的父级容器。它会负责应用从外部加载应用的配置属性和读取本地的配置文件，并且这2部分配置属性共享一个Environment。默认情况下，启动级属性会被以最高优先级添加，所以它们不能被本地配置覆盖。配置启动级上下文加载的属性需要使用bootstrap.yml而不是使用application.yml，一次能够将启动级属性和应用级属性的配置区分开，bootstrap.yml`简易配置案例：spring: application: name: foo cloud: config: uri: ${SPRING_CONFIG_URI:http://localhost:8888}如果需要配置应用的名称，则可以在bootstrap.yml 或 application.yml中配置spring.application.name属性，如果需要配置为applicationContext的ID，则只能在bootstrap.yml中配置。同时我们也能够完全禁止处理启动级上下文处理通过设置spring.cloud.bootstrap.enabled=false属性Application Context 继承关系如果通过 SpringApplication或 SpringApplicationBuilder进行构建应用，bootstrap上下文会自动的添加到应用中成为整个应用的父级上下文。并且Spring的子上下文会继承父级上下文的属性和profile，所以，应用能够包含许多额外的属性源：“bootstrap”: 启动级上下文中发现有任何的 PropertySourceLocators ，则将会使用最高优先级的 CompositePropertySource。比如： Spring Cloud Config Server。“applicationConfig: [classpath:bootstrap.yml]”：如果配置了 bootstrap.yml (或者 .properties), 这个配置将用来配置启动级上下文。设置ApplicationContext的父级上下文可以使用SpringApplicationBuilder的parent(), child()和 sibling()方法，通常来说启动级上下文就是父级上下文，并且子上下文的属性会覆盖父上下文的同名属性修改Bootstrap Properties的加载位置bootstrap.yml (或 .properties) 所在位置可以JVM系统属性配置 spring.cloud.bootstrap.name (默认: bootstrap)，spring.cloud.bootstrap.location (默认: 空) 或 spring.cloud.bootstrap.additional-location (默认: 空)spring.cloud.bootstrap.location修改默认的位置。 spring.cloud.bootstrap.additional-location 将会添加额外的配置文件地址。实际上，这些配置都是用来创建启动级ApplicationContext，如果有profile属性（spring.profiles.active）被设置，存在于这个profile下的属性都会被加载，比如：bootstrap-development.properties 指定了 development 的profile。覆盖”远程”配置的属性通过启动级上下文加载的属性源都属于”远程”配置的属性，比如：Spring Cloud Config Server，默认不能被本地的配置覆盖，通过设置spring.cloud.config.allowOverride=true，一旦配置此属性就可以通过以下2个属性进行细化配置：spring.cloud.config.overrideNone=true:只允许任何本地的配置文件覆盖spring.cloud.config.overrideSystemProperties=false: 只允许系统属性、命令行参数和环境变量进行覆盖。自定义启动级配置/META-INF/spring.factories文件的org.springframework.cloud.bootstrap.BootstrapConfiguration属性可以添加我们自定义的启动级配置类。这个文件通过逗号分隔维护了一个@Configuration指定的用于创建上下文的配置类列表。自定义启动级属性源通过PropertySourceLocator接口可以实现定义属性源，比如，需要加载来自数据库或者不同的服务器的属性配置：@Configuration public class CustomPropertySourceLocator implements PropertySourceLocator { @Override public PropertySource&lt;?> locate(Environment environment) { return new MapPropertySource(\"customProperty\", Collections.&lt;String, Object>singletonMap(\"property.from.sample.custom.source\", \"worked as intended\")); } }通过META-INF/spring.factories文件进行注册：org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocatorEnvironment修改事件监听Spring容器会监听EnvironmentChangeEvent事件来对属性的改变做出响应，每当EnvironmentChangeEvent被监听到，会进行如下操作：重新绑定 @ConfigurationProperties 标注的bean为application.yaml文件中所有的 logging.level.*属性设置日志级别RefreshScope当一个bean的定义被@RefreshScope标注时，意味着这个bean在运行的生命周期可以被动态更新，这种作用域解决了bean只能在初始化时期注入属性，而不能在后期运行时动态更新的问题。比如，通过Environment修改DataSource的数据库地址。除了@RefreshScope注解，还可以通过spring.cloud.refresh.extra-refreshable属性进行指定需要刷新的类Spring默认使用的HikariDataSource不能使用RefreshScope，但是可以使用其他的DataSource实现Spring容器中有一个RefreshScope的bean，它有一个refreshAll()方法来清空所有的bean缓存并刷新bean。同时也能够通过refresh(String)刷新指定的bean。/refresh端点必须暴露：management: endpoints: web: exposure: include: refresh@RefreshScope也能使用在@Configuration标注的类上，但是可能会导致意想不到的结果，比如：@Configuration配置类中并不是所有的@Bean都是@RefreshScope的，在进行bean刷新的时候，任何依赖了这些bean的组件都将不能使用。在刷新时期，这些bean会被重新重新创建并被注入依赖。加密与解密Spring cloud提供了一个Environment的预置处理器(pre-processor)，用来解密属性值，我们可以通过encrypt.*进行配置，但是必须依赖org.springframework.security:spring-security-rsaendpointsPOST 请求访问 /actuator/env 更新 Environment 并且重新绑定 @ConfigurationProperties 属性类和日志级别/actuator/refresh 重新加载上下文和刷新 @RefreshScope标注的 beans/actuator/restart 重新启动 ApplicationContext (默认此端点关闭)/actuator/pause 和 /actuator/resume 调用 Lifecycle 的方法 ( ApplicationContext的stop() and start() ).如果禁用/actuator/restart端点， /actuator/pause 和 /actuator/resume也将不能调用，因为这2个端点仅是/actuator/restart的特殊用列","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://ubisoft-potato.github.io/tags/spring-cloud/"}]},{"title":"BeanFactory和ApplicationContext的区别和联系","slug":"BeanFactory和ApplicationContext的区别和联系","date":"2020-08-27T07:38:22.000Z","updated":"2020-09-20T08:12:09.120Z","comments":true,"path":"2020/08/27/beanfactory-he-applicationcontext-de-qu-bie-he-lian-xi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/27/beanfactory-he-applicationcontext-de-qu-bie-he-lian-xi/","excerpt":"","text":"BeanFactoryBeanFactory提供了Spring ioC容器的基本功能API，它抽象出了用于与Spring其他组件或是第三方框架交互集成的规范，BeanFactory默认的实现类DefaultListableBeanFactory是GenericApplicationContext容器核心委托实现（ApplicationContext接口继承BeanFactory，但是BeanFactory接口主要还是通过代理DefaultListableBeanFactory来进行实现）BeanFactory相关的接口（比如 BeanFactoryAware, InitializingBean, DisposableBean) 都是与其他框架集成的关键点，即使不通过注解或是反射，也能非常有效让其他框架与ioC容器交互，BeanFactory的核心API和DefaultListableBeanFactory实现类并没有约定使用的配置格式或者任何的注解。都是通过扩展接口进行实现（比如： XmlBeanDefinitionReader 读取XMLbean定义 、 AutowiredAnnotationBeanPostProcessor负责处理@Autowire注解) ，并且所有的bean定义都是通过BeanDefinition接口表述和使用，这也是使得Spring ioC容器灵活性和扩展性强的原因。BeanFactory还是 ApplicationContext？正常情况下，开发任何应用都应该使用ApplicationContext，GenericApplicationContext以及它的子类AnnotationConfigApplicationContext作为主要的ApplicationContext实现。Spring的容器会做一些核心工作：加载配置文件、出发类路径扫描，注册bean定义等。ApplicationContext包含了BeanFactory的所有功能，所以通常来说是使用ApplicationContext来进行构建应用，而不是使用BeanFactory,除了需要完全控制bean的处理流程这种场景。除此之外，许多核心容器扩展的功能，比如：注解处理、AOP代理、 BeanPostProcessor扩展点，如果使用DefaultListableBeanFactory，像上述的BeanPostProcessor后置处理器不会被自动检测和激活使用。BeanFactory和ApplicationContext对比表：特性BeanFactoryApplicationContextBean 实例化和装配YesYesbean生命周期交互NoYes自动注册 BeanPostProcessorNoYes自动注册 BeanFactoryPostProcessorNoYes获取 MessageSource (进行国际化)NoYesApplicationEvent 事件发布机制NoYes如果需要给DefaultListableBeanFactory注册后置处理器，需要手动调用其addBeanPostProcessor方法：DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); // populate the factory with bean definitions // now register any needed BeanPostProcessor instances factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor()); factory.addBeanPostProcessor(new MyBeanPostProcessor()); // now start using the factory通过DefaultListableBeanFactory使用后置处理器需要手动调用postProcessBeanFactory方法：DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory); reader.loadBeanDefinitions(new FileSystemResource(\"beans.xml\")); // bring in some property values from a Properties file PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer(); cfg.setLocation(new FileSystemResource(\"jdbc.properties\")); // now actually do the replacement cfg.postProcessBeanFactory(factory);通过上述代码，可以知道，通过原生的BeanFactory需要手动“造轮子”才能完成一些ApplicationContext具有的特性，但是BeanFactory能完全掌控bean的处理流程，所以在没有特殊需求的场景下还是都是使用ApplicationContext。AnnotationConfigApplicationContext具有所有的公共注解后置处理器，也能够处理一些额外的注解，比如：@EnableTransactionManagement，由此可见后置处理器BeanPostProcessor在Spring中的重要性","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"Spring Environment","slug":"Spring-Environment","date":"2020-08-24T13:32:06.000Z","updated":"2020-09-20T12:12:32.101Z","comments":true,"path":"2020/08/24/spring-environment/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/24/spring-environment/","excerpt":"","text":"Environment 概念Environment 接口抽象出2个关键概念：profiles 和 properties.profile是在XML和注解定义的bean定义元数据的逻辑组，Environment能决定当前使用哪一个逻辑组的bean定义元数据，那些是默认使用的。Properties在所有的应用程序中占有非常重要的地位，它可以来自多种来源：属性文件，JVM系统属性，系统环境变量，JNDI，Servlet上下文参数，临时属性对象，Map对象等。Environment提供了方便的接口来供开发者来配置属性源以及从中获取属性。BeanDefinition ProfilesBeandefinition profiles 提供了一种能够在不同环境注册不同的bean的机制，Environment对不同的用户来说可以是不同的意义：在开发环境注入本地数据源在性能检测开发环境注入监控组件为客户A和客户B部署注册bean的自定义实现使用 @Profile@Profile注解能够在多环境下指定那些bean需要注入，比如，在开发环境注入内嵌数据源，生产环境注入其他数据源:@Configuration @Profile(\"development\") public class StandaloneDataConfig { @Bean public DataSource dataSource() { return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.HSQL) .addScript(\"classpath:com/bank/config/sql/schema.sql\") .addScript(\"classpath:com/bank/config/sql/test-data.sql\") .build(); } }@Configuration @Profile(\"production\") public class JndiDataConfig { @Bean(destroyMethod=\"\") public DataSource dataSource() throws Exception { Context ctx = new InitialContext(); return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\"); } }profile的名称可能包含环境名称（比如：production），同时还支持复杂的表达式：production &amp; us-east，支持以下表达式：!:逻辑非&amp;: 逻辑与|: 逻辑或混合使用&amp;和|必须要用括号区分，比如：production &amp; us-east | eu-central不能通过验证，需要使用如下：production &amp; (us-east | eu-central)可以使用@Profile作为原注解来开发组合注解，一下案例开发了一个@Production注解，其功能和@Profile(&quot;production&quot;)一致：@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Profile(\"production\") public @interface Production { }@Configuration标注的配置类也被@Profile标注，这个配置类下的所有@Bean以及配置类上的@Import注解倒入的bean都只会在指定的环境中生效，如果@Component和@Configuration被@Profile({&quot;p1&quot;, &quot;p2&quot;})标注，则只有在p1或p2环境被启用的时候它们才会被注入，如果被@Profile({&quot;p1&quot;, &quot;!p2&quot;})标注，则只有当p1激活或p2不被激活时被注入。@Profile 也能被标注到配置类的方法级别：@Configuration public class AppConfig { @Bean(\"dataSource\") @Profile(\"development\") public DataSource standaloneDataSource() { return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.HSQL) .addScript(\"classpath:com/bank/config/sql/schema.sql\") .addScript(\"classpath:com/bank/config/sql/test-data.sql\") .build(); } @Bean(\"dataSource\") @Profile(\"production\") public DataSource jndiDataSource() throws Exception { Context ctx = new InitialContext(); return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\"); } }激活Profile激活当前应用配置有许多方式：但是最直接的方式是通过ApplicationContext获取Environment通过api来直接指定Profilepublic void start(){ AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.getEnvironment().setActiveProfiles(\"development\"); ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class); ctx.refresh(); }还可以通过spring.profiles.active属性来指定，还能通过系统的环境变量、JVM系统属性等方式配置该属性。如果在单元测试中，需要使用@ActiveProfiles来指定tip：profile可以指定多个，它们并不是互相冲突的，比如可以通过setActiveProfiles()一次注册多个环境:ctx.getEnvironment().setActiveProfiles(&quot;profile1&quot;, &quot;profile2&quot;);通过运行时参数： -Dspring.profiles.active=&quot;profile1,profile2&quot;默认的Profile@Configuration @Profile(\"default\") public class DefaultDataConfig { @Bean public DataSource dataSource() { return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.HSQL) .addScript(\"classpath:com/bank/config/sql/schema.sql\") .build(); } }如果没有指定环境，则上述默认的DataSource将会被注入，指定则不会注入。通过setDefaultProfiles()方法可以指定默认的环境，或者通过spring.profiles.default属性指定PropertySourceEnvironment提供获取属性的api：ApplicationContext ctx = new GenericApplicationContext(); Environment env = ctx.getEnvironment(); boolean containsMyProperty = env.containsProperty(\"my-property\"); System.out.println(\"Does my environment contain the 'my-property' property? \" + containsMyProperty);上述代码通过Environment查询是否包含my-property属性，其内部是通过遍历 PropertySource 集合，PropertySource是key-value的简单抽象，Spring’的StandardEnvironment 配置了2个PropertySource对象–一个是JVM系统属性（System.getProperties())，另一个是操作系统环境变量（System.getenv())。对于独立的应用，默认的PropertySource实现类是StandardEnvironment,StandardServletEnvironment可以获取到额外的一些熟悉，比如servlet配置和servlet上下文参数当使用StandardEnvironment时，当调用env.containsProperty(&quot;my-property&quot;)时，如果系统属性或者环境变量包含my-property属性则返回true查询属性的过程时：系统属性优先于环境变量，所以。如果my-property同时在系统属性和环境变量中设置，会优先使用系统属性，而不是合并相同的属性如果需要自定义属性源可以实现PropertySource并添加到Environment中：public void addPropertiySource(){ ConfigurableApplicationContext ctx = new GenericApplicationContext(); MutablePropertySources sources = ctx.getEnvironment().getPropertySources(); sources.addFirst(new MyPropertySource()); }MutablePropertySources提供了一系列的API对PropertySource进行操作使用@PropertySource注解@PropertySource提供一种声明式的方式添加PropertySource到Environment如果有一个叫app.properties的文件包含：testbean.name=myTestBean@Configuration @PropertySource(\"classpath:/com/myco/app.properties\") public class AppConfig { @Autowired Environment env; @Bean public TestBean testBean() { TestBean testBean = new TestBean(); testBean.setName(env.getProperty(\"testbean.name\")); return testBean; } }通过上述配置之后，调用testBean.getName()返回myTestBean@PropertySource还支持${…}表达式：@Configuration @PropertySource(\"classpath:/com/${my.placeholder:default/path}/app.properties\") public class AppConfig { @Autowired Environment env; @Bean public TestBean testBean() { TestBean testBean = new TestBean(); testBean.setName(env.getProperty(\"testbean.name\")); return testBean; } }my.placeholder需要预先注册到Environment中，如果未找到则默认使用default/path@PropertySource是可重复使用的。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"Spring 容器扩展点","slug":"Spring-容器扩展点","date":"2020-08-22T13:52:07.000Z","updated":"2020-09-20T08:22:25.991Z","comments":true,"path":"2020/08/22/spring-rong-qi-kuo-zhan-dian/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/22/spring-rong-qi-kuo-zhan-dian/","excerpt":"","text":"Spring ioC容器扩展点通常来说，开发这不需要继承ApplicationContext来扩展功能，相反，Spring容器可以通过许多指定的接口进行扩展。使用BeanPostProcessor进行bean自定义BeanPostProcessor定义的回掉方法可以用来实现自己bean初始化逻辑，解决依赖逻辑等，如果需要在Spring容器对bean进行实例化、配置、初始化后进行一些自定义操作，也可以实现一系列BeanPostProcessor添加到容器中BeanPostProcessor会作用于bean（或者说时对象）上，每当Springioc容器初始化一个bean，BeanPostProcessor就会被回掉。BeanPostProcessor作用于一个容器中，如果使用父子关系的容器，bean只会被同一个容器中的BeanPostProcessor所处理。如果需要修改bean的定义元数据，即beanDefinition，需要使用BeanFactoryPostProcessororg.springframework.beans.factory.config.BeanPostProcessor由2个回掉方法组成，当一个对象被注册为BeanPostProcessor，只要当Spring容器创建bean，BeanPostProcessor就会在bean的初始化前和初始化后被回掉，这次期间，BeanPostProcessor可以对bean做任何事情，比如：检查bean被回掉的次数、Spring Aop就是通过BeanPostProcessor给bean实现代理逻辑ApplicationContext会自动检测到容器中实现BeanPostProcessor接口的bean，ApplicationContext会注册这些bean以便后期被调用，BeanPostProcessor可以就像注册普通bean一样被注册到容器。手动注册BeanPostProcessor实例：虽然推荐使用ApplicationContext自动检测来注册，但是也可以通过ConfigurableBeanFactory的addBeanPostProcessor方法来手动注册，这种做法的好处就是可以在注册之前实现一些逻辑。注意：手动注册的BeanPostProcessor不会遵循Ordered接口来配置执行顺序，手动注册的BeanPostProcessor总是优先于自动检测的BeanPostProcessor执行。BeanPostProcessor实例和AOP 自动代理：实现BeanPostProcessor接口的类将会被容器区分对待，所有的BeanPostProcessor的实例以及他们直接依赖的bean都将在应用启动的时候实例化，作为ApplicationContext的一个特殊启动阶段。因为AOP自动代理是通过BeanPostProcessor实现的，所以BeanPostProcessor实例或它们直接引用的bean都不适合进行自动代理，因此不会被注入切面。对于这样的Bean，通常会看到以下日志信息：Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)如果我们通过@autowire或@Resource（可能会退回到自动装配）注入bean到BeanPostProcessor实例中，则Spring在搜索类型匹配的依赖项候选对象时可能会访问意想不到的Bean，因此使这些bean不符合自动代理或被后置处理。案例：BeanPostProcessorBeanPostProcessor的基本使用，以下案例将会在bean创建完成之前调用bean的toString()方法获取bean信息：import org.springframework.beans.factory.config.BeanPostProcessor; public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor { // simply return the instantiated bean as-is public Object postProcessBeforeInitialization(Object bean, String beanName) { return bean; // we could potentially return any object reference here... } public Object postProcessAfterInitialization(Object bean, String beanName) { System.out.println(\"Bean '\" + beanName + \"' created : \" + bean.toString()); return bean; } }&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:lang=\"http://www.springframework.org/schema/lang\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd\"> &lt;lang:groovy id=\"messenger\" script-source=\"classpath:org/springframework/scripting/groovy/Messenger.groovy\"> &lt;lang:property name=\"message\" value=\"Fiona Apple Is Just So Dreamy.\"/> &lt;/lang:groovy> &lt;!-- when the above bean (messenger) is instantiated, this custom BeanPostProcessor implementation will output the fact to the system console --> &lt;bean class=\"scripting.InstantiationTracingBeanPostProcessor\"/> &lt;/beans>以上xml配置使用Groovy定义bean：messager使用BeanPostProcessor：import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.scripting.Messenger; public final class Boot { public static void main(final String[] args) throws Exception { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"scripting/beans.xml\"); Messenger messenger = ctx.getBean(\"messenger\", Messenger.class); System.out.println(messenger); } }运行结果:Bean &#39;messenger&#39; created : org.springframework.scripting.groovy.GroovyMessenger@272961 org.springframework.scripting.groovy.GroovyMessenger@272961使用BeanFactoryPostProcessor自定义配置元数据org.springframework.beans.factory.config.BeanFactoryPostProcessor也是Ioc容器的扩展点，和BeanPostProcessor类似，但是有一个主要的区别：BeanFactoryPostProcessor操作bean的配置元数据（beanDefinition），Spring Ioc容器能够让BeanFactoryPostProcessor读取到配置元数据并有可能在容器实例化除BeanFactoryPostProcessor实例以外的任何bean之前更改它。我们可以配置多个BeanFactoryPostProcessor实例，并通过order属性来控制它们的调用顺序，但是只能通过实现Ordered接口来配置顺序，如果需要使用BeanFactoryPostProcessor则需要考虑到实现Ordered接口。public interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; }如果需要改变实际返回的bean实例需要使用上述的BeanPostProcessor，从技术上来说，在postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)中可以使用BeanFactory.getBean()来获取bean然后修改它，但是这回导致提前bean实例化并且打乱容器正常的生命周期，这种做法会带来许多负面影响，比如：bean不会被所有的BeanPostProcessor做后置处理ApplicationContext会自动调用这些BeanFactoryPostProcessor来修改bean的配置元数据，Spring内置了一些实现：PropertyOverrideConfigurer和PropertySourcesPlaceholderConfigurer，也可以自定义BeanFactoryPostProcessor，比如：实现自定义的bean属性修改器Bean(Factory)PostProcessor会忽略延迟加载配置，比如：标签的default-lazy-init属性BeanFactoryPostProcessor使用案例：PropertySourcesPlaceholderConfigurerPropertySourcesPlaceholderConfigurer是Spring内置的占位符处理器，就是使用的BeanFactoryPostProcessor来实现，通过PropertySourcesPlaceholderConfigurer，我们可以在bean的属性配置中使用占位符：&lt;beans> &lt;bean class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\"> &lt;property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/> &lt;/bean> &lt;bean id=\"dataSource\" destroy-method=\"close\" class=\"org.apache.commons.dbcp.BasicDataSource\"> &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> &lt;property name=\"url\" value=\"${jdbc.url}\"/> &lt;property name=\"username\" value=\"${jdbc.username}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;/beans>jdbc.driverClassName=org.hsqldb.jdbcDriver jdbc.url=jdbc:hsqldb:hsql://production:9002 jdbc.username=sa jdbc.password=root在启动过程中。PropertySourcesPlaceholderConfigurer会读取外部的Properties文件，来替换相应的占位符。PropertySourcesPlaceholderConfigurer不仅会在Properties文件中查找值，默认情况下，如果在Properties文件不能找到相应的属性，会自动的在Spring的Environment对象中寻找，甚至是System属性小技巧：使用PropertySourcesPlaceholderConfigurer在运行时决定接口实现类：&lt;beans> &lt;bean class=\"org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer\"> &lt;property name=\"locations\"> &lt;value>classpath:com/something/strategy.properties&lt;/value> &lt;/property> &lt;property name=\"properties\"> &lt;value>custom.strategy.class=com.something.DefaultStrategy&lt;/value> &lt;/property> &lt;/bean> &lt;bean id=\"serviceStrategy\" class=\"${custom.strategy.class}\"/> &lt;/beans>如果在运行时找不到指定的类，则在ApplicationContext的preInstantiateSingletons()阶段就会报错BeanFactoryPostProcessor使用案例：PropertyOverrideConfigurerPropertyOverrideConfigurer也是Spring的常用BeanFactoryPostProcessor实现类，和PropertySourcesPlaceholderConfigurer类似，但不同的是原始定义对于bean属性可以具有默认值，也可以完全没有值。 如果覆盖的属性文件没有某个bean属性的条目，则使用默认的上下文定义。&lt;beans> &lt;bean class=\"org.springframework.beans.factory.config.PropertyOverrideConfigurer\"> &lt;property name=\"location\" value=\"classpath:myproperties.properties\" /> &lt;/bean> &lt;bean id=\"person\" class=\"com.sample.Employee\" > &lt;property name=\"name\" value=\"Dugan\"/> &lt;property name=\"age\" value=\"50\"/> &lt;/bean> &lt;/beans>myproperties.properties:person.age=40 person.name=Stanis如上配置，当获取personbean时：Employee e = (Employee)context.getBean(Employee.class); e.getAge() =&gt; 40 //被properties文件的值覆盖掉 e.getName() =&gt; &quot;Stanis&quot; //被properties文件的值覆盖掉使用FactoryBean自定义实例化逻辑如果一个对象本身作为工程类的话，可以实现org.springframework.beans.factory.FactoryBean接口，FactoryBean接口是Spring Ioc容器实例户逻辑的一个插件类，如果有一些复杂的实例化逻辑使用FactoryBean来实现比用XML配置精简的多：FactoryBean接口提供3个方法：Object getObject(): 获取FactoryBean创建的对象，对象是否为单实例取决于第二个方法返回值。boolean isSingleton(): 如果FactoryBean返回单实例则返回true，否则返回falseClass getObjectType(): 返回 getObject() 方法放回对象的类型，如果为止则返回nullFactoryBean在Spring中被大量使用，超过50个类实现了FactoryBean接口。当我们需要获取FactoryBean本身而不是FactoryBean产生的对象时，需要在bean 的id前加上&amp;。比如：有一个FactoryBean的id为myBean，当调用getBean(&quot;myBean&quot;)时，将会得到FactoryBean的getObject()方法产生的对象，而调用getBean(&quot;&amp;myBean&quot;)时会得到FactoryBean本身","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"Spring自定义Bean的特性","slug":"Spring自定义Bean的特性","date":"2020-08-21T05:13:28.000Z","updated":"2020-09-20T08:18:06.610Z","comments":true,"path":"2020/08/21/spring-zi-ding-yi-bean-de-te-xing/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/21/spring-zi-ding-yi-bean-de-te-xing/","excerpt":"","text":"如何定制Spring BeanSpring提供了一系列用于自定义Bean特性的接口，主要有以下3类：生命周期 回掉ApplicationContextAware和 BeanNameAware其他的 Aware接口生命周期回掉为了能够与Spring管理的bean的生命周期交互，可以实现InitializingBean和DisposableBean接口，Spring容器会在初始化和销毁bean的时期分别回掉afterPropertiesSet()和destroy()方法tips：Spring官方还是推荐使用JSR-250规范的 @PostConstruct 和 @PreDestroy 注解进行生命周期回掉声明，因为这样不会耦合Spring的代码，当然如果既不想耦合Spring的代码又想进行生命周期回掉，可以给beanDefinition指定init-method 和 destroy-method属性在Spring内部，Spring使用BeanPostProcessor来完成生命周期的各种回掉函数，如果想要自定义或者实现Spring没有提供的生命周期行为，可以考虑实现BeanPostProcessor来完成目标除了生命周期回掉函数之外，Spring管理的对象也可能实现了Lifecycle接口，所以这些对象能够参与应用的启动与停止的过程。初始化回掉org.springframework.beans.factory.InitializingBean 接口能够在容器为Bean设置了所有必要的属性后执行初始化工作。public interface InitializingBean { void afterPropertiesSet() throws Exception; }但是，秉承不耦合Spring的宗旨，建议使用 @PostConstruct注解或指定生命周期回掉函数。比如通过@Bean注解：public class BeanOne { public void init() { // initialization logic } } @Configuration public class AppConfig { @Bean(initMethod = \"init\") public BeanOne beanOne() { return new BeanOne(); } @Bean(destroyMethod = \"cleanup\") public BeanTwo beanTwo() { return new BeanTwo(); } }@PostConstruct注解实现：public class CachingMovieLister { @PostConstruct public void populateMovieCache() { // populates the movie cache upon initialization... } @PreDestroy public void clearMovieCache() { // clears the movie cache upon destruction... } }销毁回掉实现org.springframework.beans.factory.DisposableBean接口的bean能够在bean销毁的时候被回掉:public class CachingMovieLister { @PreDestroy public void clearMovieCache() { // clears the movie cache upon destruction... } }同上推荐的方式是：public class BeanTwo { public void cleanup() { // destruction logic } } @Configuration public class AppConfig { @Bean(destroyMethod = \"cleanup\") public BeanTwo beanTwo() { return new BeanTwo(); } }默认的初始化和销毁的回掉方法当不使用InitializingBean和DisposableBean接口实现生命周期回掉时，可以使用init(), initialize(), dispose()等方法名定义回掉方法，通常来说这是标准的生命周期回掉方法名，并且所有的开发者都会使用这些方法名来保持统一性。当使用init()来定义生命周期回掉时，不需要指定bean定义的init-method=&quot;init&quot;属性。所以初始化回掉就默认使用init()，销毁回掉使用dispose() ：public class DefaultBlogService implements BlogService { private BlogDao blogDao; public void setBlogDao(BlogDao blogDao) { this.blogDao = blogDao; } // this is (unsurprisingly) the initialization callback method public void init() { if (this.blogDao == null) { throw new IllegalStateException(\"The [blogDao] property must be set.\"); } } }同时，可以通过init-method和destroy-method来覆盖默认的生命周期回掉Spring容器能够保证一旦bean的所有依赖被注入就会立马回掉声明周期函方法，所以初始化回掉是发生在bean还没有被Spring Aop代理之前的时期。首先目标bean被完全创建，其次Aop再进行拦截。组合生命周期回掉机制Spring 2.5之后我们有3种选择来介入bean的生命周期：InitializingBean 和 DisposableBean 回掉方法自定义 init() 和 destroy() 方法@PostConstruct and @PreDestroy 注解.并且我们可以组合使用这3种方式来介入bean的生命周期\u0011注意：如果一个bean的生命周期被配置了多个回掉方法，那么这些回掉方法不能同名，并且将会按下面描述的顺序执行Bean初始化回掉顺序：@PostConstruct注解标注的方法最先执行InitializingBean 的afterPropertiesSet() 方法自定义的 init()方法bean销毁回掉顺序同上：@PreDestroy注解标注的方法最先执行DisposableBean的 destroy() 方法自定义的destroy()方法启动和停止回掉Spring的Lifecycle接口为任何一个有自己的生命周期的bean定义了必要的方法，比如：正在启动和停止一些后任务public interface Lifecycle { void start(); void stop(); boolean isRunning(); }任何Spring管理的对象都可以实现Lifecycle接口，ApplicationContext在接收到启动和停止信号时，会将其传递给所有实现Lifecycle接口的对象，其内部时通过LifecycleProcessor来实现：public interface LifecycleProcessor extends Lifecycle { void onRefresh(); void onClose(); }LifecycleProcessor本身也继承了Lifecycle接口，并且添加了响应容器刷新和关闭的方法。注意：org.springframework.context.Lifecycle接口只是定义了启动的和停止的规范，但是并不能在上下文环境刷新时自动启动,如果需要实现自动启动，考虑实现org.springframework.context.SmartLifecycle接口更重要的是，stop()方法的回掉不能保证在bean的销毁回掉之前被调用，在正常的停止过程中，实现Lifecycle的bean会首先收到容器停止的回掉其次是bean销毁的回掉，在容器热刷新等情况下，只会接收到bean销毁的回掉。bean之间的启动和停止的调用顺序非常重要，如果2个bean之间有使用@dependsOn注解标识依赖关系，则依赖方会在被依赖方之后启动，在被依赖方之前停止，通常来说，bean之间的直接依赖关系是未知的，在这种情况下，SmartLifecycle接口定义了另一种方式来解决：其继承的父接口Phased的getPhase()方法。public interface Phased { int getPhase(); }SmartLifecycle接口：public interface SmartLifecycle extends Lifecycle, Phased { boolean isAutoStartup(); void stop(Runnable callback); }当应用启动时，phase（阶段）值越低启动优先级越高，因此，如果一个实现了SmartLifecycle接口的对象的getPhase()方法返回值为Integer.MIN_VALUE将会成为最先启动的，最后停止的对象，反之亦然，没有实现SmartLifecycle的普通Lifecycle接口的phase值是0，因此任何负数phase值都将会优先于这些普通的对象创建。SmartLifecycle定义的停止方法接收一个回掉函数，任何实现SmartLifecycle的对象都必须在应用停止的时候调用回掉函数的run()方法，DefaultLifecycleProcessor支持异步回掉停止方法，并且每个阶段的bean回掉超时默认是30s，可以通过自定义DefaultLifecycleProcessor进行修改：&lt;bean id=\"lifecycleProcessor\" class=\"org.springframework.context.support.DefaultLifecycleProcessor\"> &lt;!-- timeout value in milliseconds --> &lt;property name=\"timeoutPerShutdownPhase\" value=\"10000\"/> &lt;/bean>LifecycleProcessor接口定义了在容器刷新和关闭时候的回掉方法，当所有的bean都实例化和初始化完后（即容器刷新）LifecycleProcessor会调用SmartLifecyclebean的isAutoStartup()方法，如果返回true，则SmartLifecyclebean的start()方法会被直接回掉，而不是等待显式的调用。非web环境优雅关闭Spring ioC容器如果在非web环境中使用Spring ioC容器，需要注册一个钩子到JVM上，这样能够确保调用所有单例bean的销毁方法使得所有资源被释放，所以必须正确的配置和实现这些销毁回掉函数。调用ConfigurableApplicationContext的registerShutdownHook()方法注册钩子：import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public final class Boot { public static void main(final String[] args) throws Exception { ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\"); // add a shutdown hook for the above context... ctx.registerShutdownHook(); // app runs here... // main method exits, hook is called prior to the app shutting down... } }","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"Netty 客户端开发连接池","slug":"Netty-客户端开发连接池","date":"2020-08-20T04:57:50.000Z","updated":"2020-09-20T08:12:09.131Z","comments":true,"path":"2020/08/20/netty-ke-hu-duan-kai-fa-lian-jie-chi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/20/netty-ke-hu-duan-kai-fa-lian-jie-chi/","excerpt":"","text":"使用Netty提供的连接池通常来说，使用netty开发服务端应用不需要使用到连接池来管理客户端与服务端的连接，但是在客户端开发中，在发送请求时就新开一个Tcp连接会导致性能低下，所以在web开发中我们会使用到Druid这样的数据库连接池。Netty在4.0.28.Final 版本发布时添加了ChannelPool接口，方便开发客户端池化Channel，以此减少重复代码。在Reactor-netty中就使用到了ChannelPool来开发它自己的HttpClient官方提供的使用案例public static void main(string[] args){ EventLoopGroup group = new NioEventLoopGroup(); final Bootstrap cb = new Bootstrap(); InetSocketAddress addr1 = new InetSocketAddress(\"10.0.0.10\", 8888); InetSocketAddress addr2 = new InetSocketAddress(\"10.0.0.11\", 8888); cb.group(group).channel(NioSocketChannel.class); ChannelPoolMap&lt;InetSocketAddress, SimpleChannelPool> poolMap = new AbstractChannelPoolMap&lt;InetSocketAddress, SimpleChannelPool>() { @Override protected SimpleChannelPool newPool(InetSocketAddress key) { return new SimpleChannelPool(cb.remoteAddress(key), new TestChannelPoolHandler()); } }; // depending on when you use addr1 or addr2 you will get different pools. final SimpleChannelPool pool = poolMap.get(addr1); Future&lt;Channel> f = pool.acquire(); f.addListener(new FutureListener&lt;Channel>() { @Override public void operationComplete(Future&lt;Channel> f) { if (f.isSuccess()) { Channel ch = f.getNow(); // Do somethings // ... // ... // Release back to pool pool.release(ch); } } }); }TIP：ChannelPoolMap的key可以是任何对象，所以极其灵活，比如它还可以是不同的EventLoopChannelPool与channelGroup的区别ChannelPool是用来实现池化操作，像是数据库连接池、httpClient等，而channelGroup是用来实现广播或者批量操作，比如一次性关闭同一个组中的所有Channel或者是同时发送一条消息到同一个组中的所有Channel。","categories":[{"name":"Netty","slug":"Netty","permalink":"https://ubisoft-potato.github.io/categories/Netty/"}],"tags":[{"name":"connectionPool","slug":"connectionPool","permalink":"https://ubisoft-potato.github.io/tags/connectionPool/"}]},{"title":"ApplicationContext应用级功能","slug":"ApplicationContext应用级功能","date":"2020-08-19T04:42:43.000Z","updated":"2020-10-15T13:22:08.665Z","comments":true,"path":"2020/08/19/applicationcontext-ying-yong-ji-gong-neng/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/applicationcontext-ying-yong-ji-gong-neng/","excerpt":"","text":"ApplicationContext应用级功能org.springframework.beans.factory 包提供了管理和使用bean的基本功能， org.springframework.context 包下添加了继承BeanFactory的ApplicationContext接口，其提供了额外的应用级功能ApplicationContext提供了如下功能：通过MessageSource接口进行国际化通过ResourceLoader接口获取URLs或者文件等资源事件发布，通过ApplicationEventPublisher通知实现ApplicationListener接口的bean加载多个上下文环境（继承关系），通过HierarchicalBeanFactory使得每一个context能专注于其功能项，比如web应用的前端控制器层。使用 MessageSource进行国际化ApplicationContext接口继承了MessageSource接口，因此ApplicationContext能够提供国际化的功能，Spring也提供HierarchicalMessageSource来支持分层处理国际化，接口定义的方法包括：String getMessage(String code, Object[] args, String default, Locale loc): 从 MessageSource中获取国际化消息的基本方法。如果没有找到相应的国际化消息结果，则使用默认的值。使用 MessageFormat进行参数位置替换。String getMessage(String code, Object[] args, Locale loc): 本质上和以上方法一样，唯一不同是不提供默认值，如果未找到则抛出 NoSuchMessageExceptionString getMessage(MessageSourceResolvable resolvable, Locale locale): 上述方法使用到的参数被封装到 MessageSourceResolvable当ApplicationContext被加载时，会自动查询容器中的MessageSourcebean，并且这个bean的名字必须为messageSource，如果找到MessageSourcebean，所有相关的方法都会被代理到这个bean实现，如果未找到，ApplicationContext会查询其父容器中的messageSourcebean，如果未找到任何messageSourcebean，将会实例化DelegatingMessageSource进行使用。spring提供了2个MessageSource实现类： ResourceBundleMessageSource 和 StaticMessageSource。并且都实现了HierarchicalMessageSource接口来实现消息合并国际化处理，StaticMessageSource使用的比较少，ResourceBundleMessageSource案例：&lt;beans> &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"> &lt;property name=\"basenames\"> &lt;list> &lt;value>format&lt;/value> &lt;value>exceptions&lt;/value> &lt;value>windows&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;/beans>以上表示类路径下有3个资源集合： format, exceptions， windows ，任何请求都将通过ResourceBundle – JDK的标准方式进行国际化处理。国际化文件编写案例: # in format.properties message=Alligators rock! # in exceptions.properties argument.required=The {0} argument is required.通过代码使用MessageSource接口，记住：ApplicationContext实现了MessageSource接口，可以被强转为MessageSourcepublic static void main(String[] args) { MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\"); String message = resources.getMessage(\"message\", null, \"Default\", Locale.ENGLISH); System.out.println(message); }结果：Alligators rock!解析：上述MessageSource定义在beans.xml中，messageSourcebean通过basenames指定国际化资源文件。上述指定了3个文件： format.properties, exceptions.properties, windows.propertiesMessageSource获取使用参数：&lt;beans> &lt;!-- this MessageSource is being used in a web application --> &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"> &lt;property name=\"basename\" value=\"exceptions\"/> &lt;/bean> &lt;!-- lets inject the above MessageSource into this POJO --> &lt;bean id=\"example\" class=\"com.something.Example\"> &lt;property name=\"messages\" ref=\"messageSource\"/> &lt;/bean> &lt;/beans>public class Example { private MessageSource messages; public void setMessages(MessageSource messages) { this.messages = messages; } public void execute() { String message = this.messages.getMessage(\"argument.required\", new Object [] {\"userDao\"}, \"Required\", Locale.ENGLISH); System.out.println(message); } }结果如下：The userDao argument is required.如果想要进行英国的国际化(en-GB），需要创建 format_en_GB.properties, exceptions_en_GB.properties, windows_en_GB.properties。比如：# in exceptions_en_GB.properties argument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.public static void main(final String[] args) { MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\"); String message = resources.getMessage(\"argument.required\", new Object [] {\"userDao\"}, \"Required\", Locale.UK); System.out.println(message); } 结果如下：Ebagum lad, the &#39;userDao&#39; argument is required, I say, required.也可以使用 MessageSourceAware 接口来获取MessageSource对象，ApplicationContext中任何实现MessageSourceAware接口的对象在创建和被配置的时候都将被注入MessageSource对象。tips：ResourceBundleMessageSource的一个可选实现是ReloadableResourceBundleMessageSource，ReloadableResourceBundleMessageSource比基于JDK的ResourceBundleMessageSource更加灵活，尤其是支持从任何spring资源加载位置读取（不仅仅是类路径）以及支持热加载， 详情：ReloadableResourceBundleMessageSource标准和自定义事件ApplicationContext通过ApplicationEvent和ApplicationListener提供事件处理机制，如果容器中一个bean实现了ApplicationListener接口,每当有ApplicationEvent发布到ApplicationContext中就会通知此bean，本质上这就是观察者模式的实现。Spring 4.2之后，事件机制得到增强，Spring提供了注解开发模式以及事件不再必须实现ApplicationEvent接口，当发布事件时，Spring自动将其封装为ApplicationEvent。Spring提供的标准事件：Event解释ContextRefreshedEvent在初始化或刷新ApplicationContext时发布（例如，通过使用ConfigurableApplicationContext接口上的refresh()方法）。在这里，“已初始化”是指所有Bean均已加载，检测到并激活了后处理器Bean，已预先实例化单例并且可以使用ApplicationContext对象。只要尚未关闭上下文，只要所选的ApplicationContext实际上支持这种“热”刷新，就可以多次触发刷新。例如，XmlWebApplicationContext支持热刷新，但GenericApplicationContext不支持。ContextStartedEvent使用ConfigurableApplicationContext接口上的start()方法启动ApplicationContext时发布。在这里，“已启动”是指所有Lifecycle bean都收到一个明确的启动信号。通常，此信号用于在显式停止后重新启动Bean，但也可以用于启动尚未配置为自动启动的组件（例如，尚未在初始化时启动的组件）。ContextStoppedEvent通过使用ConfigurableApplicationContext接口上的stop()方法停止ApplicationContext时发布。此处，“已停止”表示所有Lifecycle bean均收到明确的停止信号。停止的上下文可以通过start()调用重新启动。ContextClosedEvent通过使用ConfigurableApplicationContext接口上的close()方法或通过JVM关闭钩子关闭ApplicationContext时发布。在这里，“封闭”意味着所有单例Bean将被销毁。关闭上下文后，它将达到使用寿命，无法刷新或重新启动。RequestHandledEvent一个特定于Web的事件，告诉所有Bean HTTP请求已得到服务。请求完成后，将发布此事件。此事件仅适用于使用Spring的DispatcherServlet的Web应用程序。ServletRequestHandledEventRequestHandledEvent的子类，添加了特定于Servlet的上下文信息。自定义事件案例：public class BlockedListEvent extends ApplicationEvent { private final String address; private final String content; public BlockedListEvent(Object source, String address, String content) { super(source); this.address = address; this.content = content; } // accessor and other methods... }发布事件需要调用ApplicationEventPublisher的 publishEvent() 方法，通常的做法是实现ApplicationEventPublisherAware接口，并将其注册为spring bean：public class EmailService implements ApplicationEventPublisherAware { private List&lt;String> blockedList; private ApplicationEventPublisher publisher; public void setBlockedList(List&lt;String> blockedList) { this.blockedList = blockedList; } // 重写 setApplicationEventPublisher方法获取ApplicationEventPublisher public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; } public void sendEmail(String address, String content) { if (blockedList.contains(address)) { publisher.publishEvent(new BlockedListEvent(this, address, content)); return; } // send email... } }在Spring容器的配置期间，检测到EmailService实现了ApplicationEventPublisherAware接口，会自动调用setApplicationEventPublisher()方法，Spring会自动填充其参数，所以我们可以通过ApplicationEventPublisher与Spring容器交互。为了能监听ApplicationEvent事件，需要实现ApplicationListener并将其注册为Spring bean：public class BlockedListNotifier implements ApplicationListener&lt;BlockedListEvent> { private String notificationAddress; public void setNotificationAddress(String notificationAddress) { this.notificationAddress = notificationAddress; } public void onApplicationEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress... } }ApplicationListener带有范型，意味着onApplicationEvent()方法不需要我们进行强转，我们可以注册许多监听器，但是默认情况下监听器是同步接受事件的，也就是说 publishEvent() 在直到所有监听器被执行完之前是一只阻塞的，好处就是能在同一线程中执行，并且如果存在事务环境，也能保持一致。如果需要使用其他策略，考虑 ApplicationEventMulticaster以及实现类 SimpleApplicationEventMulticaster注册以上的bean进行使用：&lt;bean id=\"emailService\" class=\"example.EmailService\"> &lt;property name=\"blockedList\"> &lt;list> &lt;value>known.spammer@example.org&lt;/value> &lt;value>known.hacker@example.org&lt;/value> &lt;value>john.doe@example.org&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;bean id=\"blockedListNotifier\" class=\"example.BlockedListNotifier\"> &lt;property name=\"notificationAddress\" value=\"blockedlist@example.org\"/> &lt;/bean>当emailService的 sendEmail() 被调用时，如果有黑名单中的邮件，则会发布BlockedListEvent，blockedListNotifier就会被通知spring的事件机制的设计是被用来处理同一个ApllicationContext中的Bean进行交互的，如果需要更加复杂的交互能力需要使用Spring Integration ，能够构建轻量级、基于事件驱动的应用基于注解的事件监听Spring 4.2之后能够在任何Bean中的public方法上加上@EventListener注解完成事件监听，blockedListNotifier重新实现：public class BlockedListNotifier { private String notificationAddress; public void setNotificationAddress(String notificationAddress) { this.notificationAddress = notificationAddress; } @EventListener public void processBlockedListEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress... } }如果方法需要监听多个事件，并且想使用无参方法，也可以将事件声明到注解中：@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class}) public void handleContextStart() { // ... }还能够使用注解的condition属性进行事件过滤，并且是使用 SpEL expression （Spring表达式）条件配置：@EventListener(condition = \"#blEvent.content == 'my-event'\") // 只有当BlockedListEvent事件中的content属性为my-event时才进行调用 public void processBlockedListEvent(BlockedListEvent blockedListEvent) { // notify appropriate parties via notificationAddress... }事件上下文环境可用的元数据信息：NameLocationDescriptionExampleEventroot object实际的 ApplicationEvent.#root.event 或者 eventArguments arrayroot object用于调用方法的参数（作为对象数组）#root.args 或者 args;使用 args[0] 获取第一个参数Argument nameevaluation context任何方法参数的名称。如果由于某种原因这些名称不可用（例如，由于在编译的字节码中没有调试信息），则也可以使用#a &lt;#arg&gt;语法（其中&lt;#arg&gt;代表参数索引（从0开始）。#blEvent 或者 #a0 (也可以使用 #p0 或者 #p&lt;#arg&gt; 表示法作为别名)#root.event能获取到底层的事件，即使监听方法签名参数接收的是自定义事件。在处理完一个事件后，如果需要继续发布事件，只需要修改方法返回值即可：@EventListener public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress and // then publish a ListUpdateEvent... }但是此用法不支持异步调用监听器这个方法在美处理完一个BlockedListEvent事件后发布ListUpdateEvent事件，如果需要发布多个事件可以返回事件的Collection。异步监听器只需在监听方法上加 @Async 注解就能 完成异步监听：@EventListener @Async public void processBlockedListEvent(BlockedListEvent event) { // BlockedListEvent is processed in a separate thread }使用异步监听器的局限性：如果异步监听器抛出异常，并不会被传递到调用者，详情参考AsyncUncaughtExceptionHandler异步监听器方法不支持上述发布连续的事件，如果需要进行发布连续事件，需要注入 ApplicationEventPublisher 进行手动发布监听器的执行顺序添加@Order注解进行顺序编排：@EventListener @Order(42) public void processBlockedListEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress... }通用事件在某些情况下，如果所有事件都遵循相同的结构，这可能会变得很通用性（就像前面示例中的事件一样）。 在这种情况下，可以实现ResolvableTypeProvider来指导框架获取运行时类型：public class EntityCreatedEvent&lt;T> extends ApplicationEvent implements ResolvableTypeProvider { public EntityCreatedEvent(T entity) { super(entity); } @Override public ResolvableType getResolvableType() { return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource())); } }使用 EntityCreatedEvent&lt;T&gt; 构造通用的事件，其中T是实际的事件实体，比如：只接收EntityCreatedEvent事件的监听器：@EventListener public void onPersonCreated(EntityCreatedEvent&lt;Person> event) { // ... }这不光对ApplicationEvent有效，而且可以是任意事件对象便捷的资源获取方式Spring将应用资源抽象为Resource接口以及通过ResourceLoader接口进行加载得到。并且ApplicationContext实现了ResourceLoader接口，Resource抽象相当于是增强版的 JDK java.net.URL 类，实际上，Resource的实现包装了java.net.URL的实例，Resource获取几乎任意位置的资源，包括类路径，文件系统，以及使用标准URL描述的资源。可以通过实现ResourceLoaderAware接口，并注入到容器中，在初始化时期就能被回掉，获取到ResourceLoader实例（通常就是ApplicationContext）ApplicationContext的构造器通过接收资源的地址字符串，其需要依赖具体的上下文环境进行加载，比如，ClassPathXmlApplicationContext将其识别为类路径下，也可以使用特定的前缀进行指定，强制其加载为类路径或URL，而不管是什么具体的上下环境。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"ioc 容器","slug":"ioc-容器","date":"2020-08-19T04:39:08.000Z","updated":"2020-11-29T06:03:41.001Z","comments":true,"path":"2020/08/19/ioc-rong-qi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/ioc-rong-qi/","excerpt":"","text":"介绍IoC容器​ IoC容器也被称为依赖注入（DI，dependency injection）。这就是一个过程，在这个过程中，对象通过构造器参数、工厂方法参数或者是工厂方法返回后的对象上的属性来定义依赖项。IoC容器会在创建这些bean的时候注入这些依赖，这个过程完全是交由容器处理（正如其名：控制反转）。​ org.springframework.beans 和 org.springframework.context 包下的类是IoC 容器的基础。 BeanFactory 提供了管理任何类型对象的高级配置机制。 ApplicationContext 是 BeanFactory的子接口，它添加了以下功能：集成Spring AOP特性国际化（i18n）事件发布（ApllicationEvent）应用级容器，例如： WebApplicationContext 构建web应用总而言之，BeanFactory提供了配置框架和基本功能，ApllicationContext则提供了更多企业级的功能。ApllicationContext完全是扩展自BeanFactory （子集关系）。在spring中，被springIoC容器所管理的、组成应用的对象就叫Spring Bean，一个Bean会被Spring IoC容器所实例化、收集和管理。除此之外，bean只是我们应用容器中许多对象的其中之一。Bean之间的依赖关系通过容器中的配置元数据（BeanDefinition）进行展示。容器概览org.springframework.context.ApplicationContext 接口呈现了IoC容器并且负责实例化、配置、收集Bean。容器会通过读取配置元数据来进行实例化、配置和收集Bean。配置元数据可以通过XML、Java注解、Java代码来定义。通过定义可以让我们表示组成应用的对象信息以及对象之间的内部依赖关系。Sprin提供了ApllicationContext的许多实现类，在标准的独立应用中，创建 ClassPathXmlApplicationContext 或者 FileSystemXmlApplicationContext 是常见的选择。尽管XML是定义配置元数据的传统格式，但是我们可以通过提供少量XML配置来声明式地启用对这些其他配置元数据格式的支持，从而指示容器将Java注释或代码用作元数据格式。在大多数应用场景下，不需要用户显式的创建一个或多个Spring IoC容器。下图展示了spring是如何工作的，我们的应用Java类和配置元数据被整合在一起，在创建完ApllicationContext后，将会得到一个完全可配置并且可执行的系统或应用程序。配置元数据像上图所展示的，Spring IoC容器会使用一系列配置元数据，配置元数据能让开发者定义Spring容器如何实例化、配置、收集应用程序中的对象。配置元数据支持以XML格式定义，但是当今许多开发者选择使用基于Java的配置方式。使用其他形式配置：基于注解配置: Spring 2.5 支持基于注解配置基于Java配置: Spring 3.0开始,SpringJava配置项目提供的新特性被加入到Spring的核心框架中。这样就不仅可以使用XML配置还能使用新特性： @Configuration, @Bean, @Import, @DependsOn 注解Spring配置必须又至少管理了一个Bean定义的容器组成。XML通常使用标签定义，而Java配置则通常使用@Bean注解被@configuration类的方法上来定义这些bean定义对应的真实对象组成了应用程序，通常来说，我们定义的服务层、DAO、表述层对象，应用基础对象。通常，不会在容器中配置细粒度的域对象，因为DAO和业务逻辑通常负责创建和加载域对象。如果要配置IoC容器之外的对象可以使用Spring Aspectj整合&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"...\" class=\"...\"> &lt;!-- collaborators and configuration for this bean go here --> &lt;/bean> &lt;bean id=\"...\" class=\"...\"> &lt;!-- collaborators and configuration for this bean go here --> &lt;/bean> &lt;!-- more bean definitions go here --> &lt;/beans>id是Bean定义的唯一标识class定义了bean的类型，使用全类名实例化一个IoC容器ApplicationContext可以从多种外部资源进行加载，比如：本地文件系统，Java类路径等等。public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); }组合XML配置分多个XML文件配置Bean definition是十分有用的，每个XML都可以独立呈现应用程序的逻辑或者模块可以使用application context的接受多个Resource参数的方法来加载多个XML定义，也可以使用标签来加载其他XML文件：&lt;beans> &lt;import resource=\"services.xml\"/> &lt;import resource=\"resources/messageSource.xml\"/> &lt;import resource=\"/resources/themeSource.xml\"/> &lt;bean id=\"bean1\" class=\"...\"/> &lt;bean id=\"bean2\" class=\"...\"/> &lt;/beans>以上配置加载了三个文件：services.xml, messageSource.xml, themeSource.xml。services.xml地址都是相对路径，所以services.xml文件必须在同一个目录下活类路径下，而 messageSource.xml 和 themeSource.xml 必须在resources目录下。能发下的是：地址开头的“/”已经被忽略了，所以鉴于这些路径是相对路径，最好不要使用斜线开头。TIPS：虽然能使用“../”来获取上级目录但是并不是被推荐的方式，这样做会依赖应用外部的文件，更不建议在类路径中使用：比如classpath:../services.xml,如果类路径配置改变将会导致不同的，不正确的目录。也可以使用绝对路径而不是相对路径file:C:/config/services.xml或者 classpath:/config/services.xml但是要注意到应用程序已经耦合了文件系统绝对路径，通常使用绝对路径更好的做法是使用占位符，通过在运行时针对JVM系统属性解析的“ $ {…}”占位符。使用容器ApplicationContext 是一个管理不同bean注册以及它们的依赖的高级工厂接口类，通过使用T getBean(String name, Class&lt;T&gt; requiredType)可以得到想要的实例。ApplicationContext能够让开发者读取bean定义的信息，并访问它们：// create and configure beans ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); // retrieve configured instance PetStoreService service = context.getBean(\"petStore\", PetStoreService.class); // use configured instance List&lt;String> userList = service.getUsernameList();我们可以使用getBean来获取bean，ApplicationContext还有许多获取bean的方法，但是我们的业务代码最好不要使用它们，这样就不会依赖spring的api。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"spring bean","slug":"spring-bean","date":"2020-08-19T03:11:21.000Z","updated":"2020-09-20T08:10:33.590Z","comments":true,"path":"2020/08/19/spring-bean/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/spring-bean/","excerpt":"","text":"Spring BeanSpring容器管理了一个或者多个bean，这些bean是更具bean定义元数据进行创建的。在Spring容器内部，bean定义元数据以BeanDefinition对象呈现，包含以下信息：类的全类名定义bean在容器中的行为的配置元素，比如：bean作用域、生命周期回掉方法等被当前bean所引用的bean其他配置-比如：连接池的大小这些元数据会翻译为一系列属性组成BeanDefinition：属性官方说明链接ClassInstantiating BeansNameNaming BeansScopeBean ScopesConstructor argumentsDependency InjectionPropertiesDependency InjectionAutowiring modeAutowiring CollaboratorsLazy initialization modeLazy-initialized BeansInitialization methodInitialization CallbacksDestruction methodDestruction CallbacksBeanDefinition包含了如何准确创建一个bean的信息，ApplicationContext也允许用户注册在容器外部创建的对象。可以通过getBeanFactory()来获取ApplicationContext内部聚合的BeanFactory来做到，其返回BeanFactory实现类为DefaultListableBeanFactory，DefaultListableBeanFactory支持通过registerSingleton(..)和registerBeanDefinition(..)方法进行注册TIPS： 为了能让Spring容器在自动装盘时正确的理解bean的意图，Bean元数据和手动注册的单实例对象应该被尽可能早地执行。虽然在某种程度上支持覆盖现有Bean元数据和现有单例实例，但是在运行时（与对工厂的实时访问同时）对新bean的注册不被Spring支持，并且可能导致并发访问异常，bean容器中的状态不一致。bean的命名任何一个bean都有一个或多个标识符，这些标识符在持有这些bean的容器中必须唯一，通常一个bean只有一个标识符，如果要求有多个，可以考虑起别名。使用XML进行配置时，我们使用id和name属性进行指定bean的标识符，id能指定唯一的标识，这些都是由字母数字组成的(‘myBean’, ‘someService’等)，也能包含特殊的字符，如果需要起一些别名，则使用name属性进行定义，使用逗号，分号或空格进行分隔。但id必须唯一。如果没有指定id和name，容器会为bean自动生成一个唯一的标识符。bean命名惯例：bean的名称默认使用首单词的首字母小写，其余的单词首字母都是大写，比如：accountManager,accountService,userDao,loginController等。bean的命名能够使得应用的配置更加简单和易读，如果使用Spring Aop，能够更方便的通过bean的名称进行的切面定义。TIPS:通过在类路径中进行组件扫描，Spring会按照前面描述的规则为未命名的组件生成Bean名称：从本质上讲，将采用简单的类名称并将其首字符转换为小写。 但是，在（不寻常的）特殊情况下，如果有多个字符且第一个和第二个字符均为大写字母，则会保留原始大小写。在BeanDefinition之外给bean取别名我们可以通过BeanDefinition给bean定义一个或多个名称，通过id属性定义唯一标识符和name属性定义多个别名。但是，在实际定义bean的地方指定所有别名并不能满足需求。 有时需要为在别处定义的bean引入别名。 在大型系统中通常是这种情况，在大型系统中，配置在每个子系统之间分配，每个子系统都有自己的对象定义集。&lt;alias name=\"fromName\" alias=\"toName\"/> 使用XML的标签进行起别名给fromName的bean起一个toName的别名。比如：A系统通过subsystemA-dataSource来引用一个Datasource对象，B系统通过subsystemB-dataSource来引用DataSource对象，当组合这2个子系统为一个系统时，主应用使用myApp-dataSource来进行引用，这种情况可以使用以下配置：&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt; &lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;实例化bean一个beanDefinition可以创建一个或多个对象，容器在被查询时会查看命名bean的定义，并使用该bean定义封装的配置元数据来创建（或获取）实际对象。如果使用XML定义Bean元数据，通常需要指定标签中的class属性class属性对应BeanDefinition中的Class字段。Class字段有2种用法:通常，在容器本身通过反射机制调用其构造函数直接创建Bean的情况下，指定要构造的Bean类型，这在某种程度上等同于使用new运算符的Java代码。要指定包含用于创建对象的静态工厂方法的实际类，在不太常见的情况下，容器将在类上调用静态工厂方法以创建Bean。 从静态工厂方法的调用返回的对象类型可以是同一类，也可以是完全不同的另一类。内部类：如果需要配置类的内部静态类的bean定义，必须要使用类的组合名称，比如：在 com.example 包下有一个叫SomeThing的类，在其内部有一个叫OtherThing的内部静态类，则其beanDefinition的class属性将会是com.example.SomeThing$OtherThing,$被用来作为内部类和外部类的分隔。使用构造器初始化当通过构造方法创建一个bean时，所有普通类都可以被Spring使用并兼容。 也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。 只需指定bean类就足够了。 但是，根据用于该特定bean的IoC类型，可能需要一个默认（空）构造函数。Spring IoC容器几乎可以管理任何类。 它不仅限于管理真正的JavaBean。 大多数Spring用户更喜欢实际的JavaBean，它们仅具有默认（无参数）构造函数，并具有根据容器中的属性建模的适当的setter和getter。 还可以在容器中包含更多奇特的非bean样式类。 例如，如果需要使用绝对不符合JavaBean规范的旧式连接池，则Spring也可以对其进行管理。&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"/> &lt;bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/>使用静态工厂方法进行实例化可以使用class属性来指定包含静态工厂方法的的类，使用factory-method属性来指定工厂方法的名字。&lt;bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/> public class ClientService { private static ClientService clientService = new ClientService(); private ClientService() {} public static ClientService createInstance() { return clientService; } }使用实例工厂方法使用已存在的bean的非静态工厂方法创建新的bean：&lt;!-- the factory bean, which contains a method called createInstance() --> &lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"> &lt;!-- inject any dependencies required by this locator bean --> &lt;/bean> &lt;!-- the bean to be created via the factory bean --> &lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/>public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } }工厂类也能拥有多个工厂方法：&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"> &lt;!-- inject any dependencies required by this locator bean --> &lt;/bean> &lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/> &lt;bean id=\"accountService\" factory-bean=\"serviceLocator\" factory-method=\"createAccountServiceInstance\"/>public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } public AccountService createAccountServiceInstance() { return accountService; } }这种方式说明工厂bean本省可以被容器管理和通过DI配置。决定bean的运行时类型确定特定bean的运行时类型并非易事。 Bean元数据定义中的指定类只是初始类引用，可能与声明的工厂方法结合使用，或者是FactoryBean类，这可能导致Bean的运行时类型不同，或者在实例的情况下根本不进行设置 工厂方法（通过指定的factory-bean名称解析）。 此外，AOP代理可以使用基于接口的代理包装Bean实例，而目标Bean的实际类型（仅是其实现的接口）的暴露程度有限。建议使用BeanFactory.getType获取运行时bean的类型。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"k3s中使用configmap灵活配置","slug":"k3s中使用configmap灵活配置","date":"2019-12-07T09:15:39.000Z","updated":"2020-09-20T11:28:42.776Z","comments":true,"path":"2019/12/07/k3s-zhong-shi-yong-configmap-ling-huo-pei-zhi/","link":"","permalink":"https://ubisoft-potato.github.io/2019/12/07/k3s-zhong-shi-yong-configmap-ling-huo-pei-zhi/","excerpt":"","text":"使用configmap前所遇到的问题在微服务横行的时代，一个系统被拆分成多个子系统，使得每个子系统各自有一套自己管理的配置， 使得配置管理难度加大，springcloud的解决方案是spring config，可以通过github等集中托管各服务配置， 集群化部署有比spring config更简单的解决方案：k8s configmap什么是configmapConfigMap 是k8s集群中的一种资源类型，并且ConfigMap会将配置数据作为k-v键值对存储，存储的数据可以被集群中的pod消费。通过configMap我们可以将springboot的配置文件集中管理在一个k8s名称空间下，这样就可以统一管理所有容器配置创建configMap使用kubectl命令创建:kubectl create configmap &lt;map-name&gt; &lt;data-source&gt; -n &lt;namespace&gt;其中可以是存放配置文件的目录或者就是配置文件，是创建的configMap的名字, &lt; namespace &gt;为指定的名称空间名。例子：# 创建本地目录 mkdir -p /config # 下载事例配置 wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties kubectl create configmap testConfigMap --from-file=/config/ -n dev上述命令为使用/config 目录下的所有配置文件在dev名称空间创建名为 testConfigMap的configMap资源查看创建完的configmap:kubectl describe configmap testConfigMap -n dev kubectl get configmap testConfigMap -o yaml -n dev查看dev名称空间下名叫testConfigMap的configMap，如果按照上述操作，结果应该如下：Name: game-config Namespace: dev Labels: &lt;none&gt; Annotations: &lt;none&gt; Data ==== game.properties: 158 bytes ui.properties: 83 bytes使用第二条命令则更详细：apiVersion: v1 kind: ConfigMap metadata: creationTimestamp: 2016-02-18T18:52:05Z name: game-config namespace: dev resourceVersion: \"516\" uid: b4952dc3-d670-11e5-8cd0-68f728db1985 data: game.properties: | enemies=aliens lives=3 enemies.cheat=true enemies.cheat.level=noGoodRotten secret.code.passphrase=UUDDLRLRBABAS secret.code.allowed=true secret.code.lives=30 ui.properties: | color.good=purple color.bad=yellow allow.textmode=true how.nice.to.look=fairlyNice通过上述操作可以发现，使用命令创建后，configmap中的key即为配置文件的名字，所以使用起来也非常方便创建configMap还可以通过yaml配置文件的方式创建，不再详细说明，通过文件方式更为通用configMap的应用创建好configMap就要使用到实际应用中，pod可以直接使用集群中的configMap资源，通常来说有2种应用：1、作为pod中的环境变量导入 2、作为pod中的loume挂载，将configMap的key对应的数据变成文件挂载到pod中的指定位置要集中管理springboot配置文件，使用第2种营业员方式：创建configMap，其中有2个配置文件 apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm --- 将配置文件挂载到pod的/etc/config 目录下 apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config/&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: # Provide the name of the ConfigMap containing the files you want # to add to the container name: special-config restartPolicy: Never当pod创建并启动后，会输出如下结果：SPECIAL_LEVEL SPECIAL_TYPE说明configMap中的key作为了文件名，值作为文件内容。注意：这种挂载方式会清空 pod中/etc/config目录下原有的所有文件，再将配置文件挂载进去， 如果不想原来的配置被删除可以使用subPath的挂载方式，修改如下：apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config/&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config/SPECIAL_LEVEL subPath: SPECIAL_LEVEL volumes: - name: config-volume configMap: name: special-config items: - key: SPECIAL_LEVEL path: SPECIAL_LEVEL restartPolicy: Never通过subPath的挂载方式，原来pod目录里的文件就不会被删除","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"configmap","slug":"configmap","permalink":"https://ubisoft-potato.github.io/tags/configmap/"}]},{"title":"k3s配置ingress使用ssl证书","slug":"k3s配置ingress使用ssl证书","date":"2019-11-03T06:39:03.000Z","updated":"2020-09-20T11:28:04.454Z","comments":true,"path":"2019/11/03/k3s-pei-zhi-ingress-shi-yong-ssl-zheng-shu/","link":"","permalink":"https://ubisoft-potato.github.io/2019/11/03/k3s-pei-zhi-ingress-shi-yong-ssl-zheng-shu/","excerpt":"","text":"What is Ingress?Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. internet | [ Ingress ] --|-----|-- [ Services ] Ingress暴露了从集群外部到集群内服务的HTTP和HTTPS路由。流量路由由Ingress资源上定义的规则控制。 可以将Ingress配置为提供服务外部可访问的URL，负载平衡流量，并提供基于SSL / TLS的虚拟主机。 入口控制器通常通过负载平衡器负责实现入口，尽管它也可以配置边缘路由器或其他前端以帮助处理流量。说白了ingress的功能就是类是于反向代理，能够做到像nginx一样的反代的功能，控制流量，并有负载均衡的能力，本文主要讨论如何在k3s集群中配置https证书注意：k3s集群默认使用traefik来实现反向代理，但也支持使用nginx来作为 ingress controller 来实现反向代理配置http ingresskind: Ingress apiVersion: networking.k8s.io/v1beta1 metadata: name: test-ingress annotations: kubernetes.io/ingress.class: traefik traefik.frontend.rule.type: PathPrefixStrip spec: rules: # 这里可以配置多个域名代理规则 - host: xxx # 域名 http: paths: - backend: serviceName: service-01 servicePort: 8080 - host: xxx # 域名 http: paths: - backend: serviceName: service-02 servicePort: 8080执行: kubectl apply -f ingress.yaml ,创建ingress。 [root@hostname ~]# kubectl get ingress NAME HOSTS ADDRESS PORTS AGE test-ingress xxxxx,xxxx 172.17.19.115 80 6h15m 可以看到 端口为80，说明ingress已经为指定的service做好http代理为ingress配置https首先配置k3s secretapiVersion: v1 kind: Secret metadata: name: testsecret-tls namespace: default data: tls.crt: base64 encoded cert #此处必须为base64 加密后的证书 可使用 cat xxx.pem | base64 命令得到 tls.key: base64 encoded key #此处必须为base64 加密后的密钥 可使用 cat xxx.key | base64 命令得到 type: kubernetes.io/tlskind: Ingress apiVersion: networking.k8s.io/v1beta1 metadata: name: test-ingress namespace: default # ingress要和secret在同一个名称空间下 annotations: kubernetes.io/ingress.class: traefik traefik.frontend.rule.type: PathPrefixStrip # http 重定向到 https ingress.kubernetes.io/ssl-redirect: \"True\" spec: tls: - hosts: - xxxx.xxxx # 这里是下面要配置https的域名 - xxxx.xxxx # 这里是下面要配置https的域名 secretName: testsecret-tls rules: # 这里可以配置多个域名代理规则 - host: xxx # 域名 http: paths: - backend: serviceName: service-01 servicePort: 8080 - host: xxx # 域名 http: paths: - backend: serviceName: service-02 servicePort: 8080先后执行： kubectl apply -f secret.yaml kubectl apply -f ingress.yaml ----------------------------------------------------- 查看 secret : kubectl get secret [root@hostname ~]# kubectl get secret NAME TYPE DATA AGE default-token-d25kq kubernetes.io/service-account-token 3 10h testsecret-tls kubernetes.io/tls 2 7h25m 第二行为我们所创建的证书的secret对象 ------------------------------------------------------ 查看ingress: kubectl get ingress [root@hostname ~]# kubectl get ingress NAME HOSTS ADDRESS PORTS AGE test-ingress xxx.xxx,xxx.xxx 172.17.19.115 80, 443 7h26m 可以看到 端口已经添加了443如果操作无误，这时访问我们的域名已经是变成了https，并且访问http也会被重定向到https","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"ingress","slug":"ingress","permalink":"https://ubisoft-potato.github.io/tags/ingress/"},{"name":"ssl","slug":"ssl","permalink":"https://ubisoft-potato.github.io/tags/ssl/"}]},{"title":"docker入门","slug":"docker入门","date":"2019-11-01T13:44:27.000Z","updated":"2020-09-20T11:24:09.461Z","comments":true,"path":"2019/11/01/docker-ru-men/","link":"","permalink":"https://ubisoft-potato.github.io/2019/11/01/docker-ru-men/","excerpt":"","text":"什么是docker？Docker is a set of platform-as-a-service products that use OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. --wikiDocker是一组平台即服务产品，它们使用操作系统级虚拟化并被称为容器的软件包交付软件。 容器彼此隔离，并将它们自己的软件，库和配置文件捆绑在一起； 他们可以通过定义明确的渠道相互通信。docker基本概念容器–什么是容器What is a Container? A standardized unit of software容器是标准的软件单元（可独立运行的） ，传统的软件部署方式，需要将软件打包，并在部署之前，要在操作系统上安装相关依赖，这样的部署方式使得软件的耦合度太高，并且不宜维护，而通过容器，可以将软件打包到标准化单元中，以进行开发，运输和部署，极大降低软件部署的耦合度。Why Docker?作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。docker 容器 vs 虚拟机 容器是应用程序层的抽象，将代码和依赖项打包在一起。 多个容器可以在同一台计算机上运行，​​并与其他容器共享OS内核，每个容器在用户空间中作为隔离的进程运行。 容器占用的空间少于VM（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要的VM和操作系统更少。虚拟机（VM）是将一台服务器转变为多台服务器的物理硬件的抽象。 虚拟机管理程序允许多个VM在单台计算机上运行。 每个VM包含操作系统，应用程序，必要的二进制文件和库的完整副本-占用数十GB。 VM也可能启动缓慢。基本概念Docker 包括三个基本概念镜像（Image）容器（Container）仓库（Repository）镜像Docker 镜像（Image）就是一个只读的模板。 例如：一个镜像可以包含一个完整的 Ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。 镜像可以用来创建 Docker 容器。 Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。容器Docker 利用容器（Container）来运行应用。 容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。仓库仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。 实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括时速云 、网易云等，可以提供大陆用户更稳定快速的访问。 当然，用户也可以在本地网络内创建一个私有仓库（参考本文“私有仓库”部分）。 当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库， 这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。 注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"docker基本概念","slug":"docker基本概念","permalink":"https://ubisoft-potato.github.io/tags/docker基本概念/"}]},{"title":"rancher、k3s安装记录","slug":"rancher、k3s安装记录","date":"2019-10-09T06:02:43.000Z","updated":"2020-09-20T11:38:42.448Z","comments":true,"path":"2019/10/09/rancher-k3s-an-zhuang-ji-lu/","link":"","permalink":"https://ubisoft-potato.github.io/2019/10/09/rancher-k3s-an-zhuang-ji-lu/","excerpt":"","text":"k3s 简介k3s 是 Rancher 推出的轻量级 k8s。k3s 本身包含了 k8s 的源码，所以本质上和 k8s 没有区别。但为了降低资源占用，k3s 和 k8s 还是有一些区别的，主要是：使用了相比 Docker 更轻量的 containerd 作为容器运行时（Docker 并不是唯一的容器选择）去掉了 k8s 的 Legacy, alpha, non-default features用 sqlite3 作为默认的存储，而不是 etcd其他的一些优化，最终 k3s 只是一个 binary 文件，非常易于部署所以 k3s 适用于边缘计算，IoT 等资源紧张的场景。同时 k3s 也是非常容易部署的，官网上提供了一键部署的脚本。下载可执行k3s 安装脚本、二进制文件 和 镜像mkdir k3s-install cd k3s-install curl -sfL https://get.k3s.io > install.sh chmod +x ./install.sh wget https://github.com/rancher/k3s/releases/download/${k3s.version}/k3s wget https://github.com/rancher/k3s/releases/download/${k3s.version}/k3s-airgap-images-amd64.tar安装k3s主服务器cp ./k3s /usr/local/bin/ chmod +x /usr/local/bin/k3s mkdir -p /var/lib/rancher/k3s/agent/images/ cp ./k3s-airgap-images-amd64.tar /var/lib/rancher/k3s/agent/images/ INSTALL_K3S_SKIP_START=true INSTALL_K3S_EXEC=\"--docker\" INSTALL_K3S_BIN_DIR=\"/usr/local/bin\" INSTALL_K3S_SKIP_DOWNLOAD=true sh install.sh ln -s /usr/local/bin/k3s /usr/bin/k3s systemctl enable k3s systemctl start k3s 修改配置文件 /etc/systemd/system/k3s.service 将其中的ExecStart修改为使用dockerExecStart=/usr/local/bin/k3s server --docker运行命令，查看状态kubectl get node NAME STATUS ROLES AGE VERSION hostname Ready master 110s v1.14.5-k3s.1安装agent cp ./k3s /usr/local/bin/ chmod +x /usr/local/bin/k3s mkdir -p /var/lib/rancher/k3s/agent/images/ cp ./k3s-airgap-images-amd64.tar /var/lib/rancher/k3s/agent/images/ INSTALL_K3S_SKIP_START=true INSTALL_K3S_EXEC=\"--docker\" INSTALL_K3S_BIN_DIR=\"/usr/local/bin\" INSTALL_K3S_SKIP_DOWNLOAD=true K3S_TOKEN=XXXXX K3S_URL=https://XXXXX:6443 sh install.sh ln -s /usr/local/bin/k3s /usr/bin/k3s systemctl enable k3s-agent systemctl start k3s-agent token需要从主服务器的 /var/lib/rancher/k3s/server/node-token 获取安装控制台创建目录 /data/k3s/rancher-server/var/lib/rancherdocker run -d -v /data/k3s/rancher-server/var/lib/rancher/:/var/lib/rancher/ --restart=unless-stopped --name rancher-server -p 38080:80 -p 38443:443 rancher/rancher:stable","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"rancher","slug":"rancher","permalink":"https://ubisoft-potato.github.io/tags/rancher/"}]},{"title":"使用docker部署文件服务ambry","slug":"使用docker部署文件服务ambry","date":"2019-10-08T13:17:30.000Z","updated":"2020-09-20T11:24:25.373Z","comments":true,"path":"2019/10/08/shi-yong-docker-bu-shu-wen-jian-fu-wu-ambry/","link":"","permalink":"https://ubisoft-potato.github.io/2019/10/08/shi-yong-docker-bu-shu-wen-jian-fu-wu-ambry/","excerpt":"","text":"分布式文件服务ambry分布式文件服务ambry是国外著名社交软件公司 linkedin 的开源项目，ambry官网地址:https://github.com/linkedin/ambry, 可以自行查看github介绍如何使用docker容器化部署ambryambry官方并没有相关镜像，所以自己制作ambry镜像进行部署,下面进行介绍:ambry分为服务段和前端，所以制作了2个镜像, 镜像dockerHub地址：https://hub.docker.com/r/wdnmdcyka/ambry-client, https://hub.docker.com/r/wdnmdcyka/ambry-server[root@izwz94ymqw967redc0vyeoz ~]# docker search ambry NAME DESCRIPTION STARS OFFICIAL AUTOMATED amimimor/ambry Ambry Docker Image 0 civicknowledge/ambry Public data ETL framework 0 [OK] sandinh/ambry dockerize for linkedin [ambry] 0 [OK] sivabalan/ambry Adding docker support for ambry 0 [OK] sivabalan/ambryfe Ambry FE using in memory router factory 0 [OK] sandinh/ambry-import-xenforo import xenforo avatars, attachments to ambry 0 maciejbak85/ambry Distributed object store https://github.com 0 civicknowledge/ambry-base 0 gnkr8/ambry 0 ktimothy/ambry 0 wdnmdcyka/ambry-server linkedin/ambry server image 0 wdnmdcyka/ambry-client linkedin/ambry fronted image 0 需要下载 wdnmdcyka/ambry-server、wdnmdcyka/ambry-client[root@izwz94ymqw967redc0vyeoz ~]# docker pull wdnmdcyka/ambry-server:1.0 [root@izwz94ymqw967redc0vyeoz ~]# docker pull wdnmdcyka/ambry-client:1.0部署方式按照官网传统部署方式，需要部署ambry的服务端和ambry的前端，前端不负责存储，所有的文件都是在服务端存储，前端只是负责转发请求和组织服务端存储首先部署ambry-server: docker run -d -v ${your config dir}:/app/config -v ${your tmp dir}:/tmp -v ${your logs dir}:/app/logs -p 6667:6667 -p 16503:16503 --restart always --name ambry-server wdnmdcyka/ambry-server:tagname说明：其中挂载出来的目录有ambry的配置文件目录，/tmp为服务端存储文件的目录，/app/logs为ambry生成日志存储的目录暴露的端口6667为server和client通信的端口部署ambry-client：docker run -d -v ${your config dir}:/app/config -v ${your logs dir}:/app/logs -p 1174:1174 --restart always --name ambry-client wdnmdcyka/ambry-client:tagname说明：由于client端不负责存储，所以没有挂载/tmp目录，1174端口是ambry暴露的rest接口所使用的端口配置文件获取地址：https://github.com/linkedin/ambry/tree/master/config测试如果配置无误，直接请求 http://localhost:1174/healthCheck ，如果返回 GOOD 则部署成功!","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://ubisoft-potato.github.io/tags/文件上传/"},{"name":"分布式文件服务","slug":"分布式文件服务","permalink":"https://ubisoft-potato.github.io/tags/分布式文件服务/"}]},{"title":"springBoot统一异常处理","slug":"springBoot统一异常处理","date":"2019-09-28T12:33:00.000Z","updated":"2020-09-20T11:24:22.189Z","comments":true,"path":"2019/09/28/springboot-tong-yi-yi-chang-chu-li/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/28/springboot-tong-yi-yi-chang-chu-li/","excerpt":"","text":"如何在springBoot优雅的处理异常？异常处理在任何项目中都尤为重要，所以这使得如何统一处理异常变得非常重要，本文记录在SpringBoot中解决统一异常处理最优雅的方式。spring 3.2新增注解@ControllerAdvice package org.springframework.web.bind.annotation; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface ControllerAdvice { @AliasFor(\"basePackages\") String[] value() default {}; @AliasFor(\"value\") String[] basePackages() default {}; Class&lt;?>[] basePackageClasses() default {}; Class&lt;?>[] assignableTypes() default {}; Class&lt;? extends Annotation>[] annotations() default {}; }ControllerAdvice拆分开来就是Controller Advice，关于Advice，可以理解为AOP面向切面编程中的环绕增强，为指定范围内的controller进行相应方法的增强代理。结合方法型注解@ExceptionHandler，用于捕获Controller中抛出的指定类型的异常，从而达到不同类型的异常区别处理的目的；@ControllerAdvice的用法基本是将其声明在某个bean上，然后在该bean的方法上使用其他的注解来指定不同的织入逻辑。不过这里@ControllerAdvice并不是使用AOP的方式来织入业务逻辑的，而是Spring内置对其各个逻辑的织入方式进行了内置支持@ExceptionHandler注解@ExceptionHandler的作用主要在于声明一个或多个类型的异常,当符合条件的Controller抛出这些异常之后将会对这些异常进行捕获，然后按照其标注的方法的逻辑进行处理，从而改变返回的信息@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface ExceptionHandler { // 指定需要捕获的异常的Class类型 Class&lt;? extends Throwable>[] value() default {}; }实例说明统一异常配置类@ControllerAdvice(basePackages = \"xxx.xxx\")//指定controller所在的包 public class MyExceptionHandler { @ExceptionHandler(Exception.class)//需要处理的异常类型 @ResponseBody public Map&lt;String, String> handleException(Exception e) { HashMap&lt;String, String> errorMap = new HashMap&lt;>(); errorMap.put(\"errorMsg\", e.getMessage()); errorMap.put(\"code\", 500 + \"\"); return errorMap; } }写个简单的controller 直接抛出异常@RestController public class MyController { @GetMapping(\"/test\") public void test() { throw new ArrayIndexOutOfBoundsException(\"数组越界\"); } }访问 /test 并没有直接返回结果 而是上述返回异常处理的map{ &quot;code&quot;:500, &quot;errorMsg&quot;:&quot;数组越界&quot; }","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://ubisoft-potato.github.io/tags/异常处理/"}]},{"title":"mapstruct在SpringBoot中的使用","slug":"mapstruct在SpringBoot中的使用","date":"2019-09-26T12:54:38.000Z","updated":"2020-09-20T11:24:30.336Z","comments":true,"path":"2019/09/26/mapstruct-zai-springboot-zhong-de-shi-yong/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/26/mapstruct-zai-springboot-zhong-de-shi-yong/","excerpt":"","text":"MapStruct是什么MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach.MapStruct是一个极大简化javaBean之间互相转换的代码生成器，即简化实体类DTO的互相转化，官方文档maven依赖 &lt;properties> &lt;org.mapstruct.version>1.3.0.Final&lt;/org.mapstruct.version> &lt;/properties> &lt;dependency> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct-jdk8&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct-processor&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency>集成MapStruct官方提供了两种方式，上面配置文件内我们采用的是直接添加Maven依赖，而官方文档还提供了另外一种方式，采用Maven插件形式配置，配置如下所示： &lt;properties> &lt;org.mapstruct.version>1.3.0.Final&lt;/org.mapstruct.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.5.1&lt;/version> &lt;!-- or newer version --> &lt;configuration> &lt;source>1.8&lt;/source> &lt;!-- depending on your project --> &lt;target>1.8&lt;/target> &lt;!-- depending on your project --> &lt;annotationProcessorPaths> &lt;path> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct-processor&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;/path> &lt;!-- other annotation processors --> &lt;/annotationProcessorPaths> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build>一对一转换//实体类 public class Customer { private Long id; private String name; //getters and setter omitted for brevity } //DTO public class CustomerDto { public Long id; public String customerName; } //(org.mapstruct.Mapper) annotation @Mapper public interface CustomerMapper { CustomerMapper INSTANCE = Mappers.getMapper( CustomerMapper.class ); //相同属性不需要用@Mapping指定，如Customer和CustomerDto中的id //customerName与name不同，则必须指定 @Mapping(source = \"customerName\", target = \"name\") Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer); }可以看到CustomerMapper是一个接口的形式存在的，当然也可以是一个抽象类，如果需要在转换的时候才用个性化的定制的时候可以采用抽象类的方式，相应的代码配置官方文档已经声明。@Mapper注解是用于标注接口、抽象类是被MapStruct自动映射的标识，只有存在该注解才会将内部的接口方法自动实现。使用方式1：不需要做过多的配置内容，获取Mapper的方式就是采用Mappers通过动态工厂内部反射机制完成Mapper实现类的获取。public class MapStructTest { @Test public void directMapping() { Customer customer = new Customer(); customer.setId(12L); customer.setName(\"customer001\"); CustomerDto customerDto = CustomerConverter.INSTANCE.fromCustomer(customer); System.out.println(\"customerDto = \" + customerDto); } }使用方式2：使用springBoot依赖注入// Specifies the component model to which the generated mapper should adhere. Supported values are //指定mapper的注入模板 :cdi spring jsr330 //@mapper添加参数 componentModel = \"spring\" @Mapper(componentModel = \"spring\") public interface CustomerConverter { CustomerConverter INSTANCE = Mappers.getMapper(CustomerConverter.class); @Mapping(source = \"customerName\", target = \"name\") Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer); } public class MapStructTest { //使用autowired自动注入 @Autowired private CustomerConverter customerConverter; @Test public void directMapping() { Customer customer = new Customer(); customer.setId(12L); customer.setName(\"customer001\"); // CustomerDto customerDto = CustomerConverter.INSTANCE.fromCustomer(customer); CustomerDto customerDto = customerConverter.fromCustomer(customer); System.out.println(\"customerDto = \" + customerDto); } }结果： customerDto = CustomerDto(id=12, customerName=customer001)IDEA插件: MapStruct Support安装idea插件MapStruct Support在编写mapper时可以提示不相同的属性映射@Mapper(componentModel = \"spring\") public interface CustomerConverter { CustomerConverter INSTANCE = Mappers.getMapper(CustomerConverter.class); @Mapping(source = \"customerName\", target = \"name\") //插件可以提示source和target参数 Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer); }实体类中有List属性的转换@Data public class Student { private Integer id; private String name; private Integer age; private String sex; } @Data public class Teacher { private List&lt;Student> students; } @Data public class StudentDto { private Integer id; private String name; private Integer age; private String gender; } @Data public class TeacherDto { private List&lt;StudentDto> studentDtos; }要将teacher转换到teacherDto，按照以前的方式：把teacher中的List遍历，挨个转换成dto再手动添加到teacherDto中的list中使用mapStruct:@Mapper(componentModel = \"spring\") public interface StudentConverter { //定义student转studentDto @Mapping(target = \"gender\", source = \"sex\") StudentDto studentToDto(Student student); //List&lt;Student> 转 List&lt;StudentDto>，此方法在编译生成后会调用StudentDto studentToDto(Student student); //如果不定义StudentDto studentToDto(Student student); 此方法会报错 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); //Teacher 转 TeacherDto ，此方法调用 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); // 如果没有List&lt;StudentDto> studentToDtoList(List&lt;Student> students); 此方法报错 @Mapping(target = \"studentDtos\", source = \"students\") TeacherDto teacherToDto(Teacher teacher); }测试：public class ApplicationTests { @Autowired StudentConverter studentConverter; @Test public void contextLoads() { Student student1 = new Student(); student1.setId(1); student1.setName(\"sda\"); student1.setAge(12); student1.setSex(\"男\"); Student student2 = new Student(); student2.setId(2); student2.setName(\"asdfd\"); student2.setAge(23); student2.setSex(\"男\"); Teacher teacher = new Teacher(); teacher.setStudents(Arrays.asList(student1, student2)); TeacherDto teacherDto = studentConverter.teacherToDto(teacher); System.out.println(\"teacher = \" + teacher); System.out.println(\"teacherDto = \" + teacherDto); } }结果: teacher = Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]) teacherDto = TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男), StudentDto(id=2, name=asdfd, age=23, gender=男)])多对一这里以二对一为例:实体类: @Data public class School { private Long id; private String address; private String name; } @Data public class Student { private Integer id; private String name; private Integer age; private String sex; } @Data public class Teacher { private List&lt;Student> students; }对应Dto: @Data public class SchoolDto { private Long id; private String address; private String name; private List&lt;TeacherDto> teacherDtos; } @Data public class StudentDto { private Integer id; private String name; private Integer age; private String gender; } @Data public class TeacherDto { private List&lt;StudentDto> studentDtos; }mapper类:@Mapper(componentModel = \"spring\") public interface StudentConverter { //定义student转studentDto @Mapping(target = \"gender\", source = \"sex\") StudentDto studentToDto(Student student); //List&lt;Student> 转 List&lt;StudentDto>，此方法在编译生成后会调用StudentDto studentToDto(Student student); //如果不定义StudentDto studentToDto(Student student); 此方法会报错 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); //Teacher 转 TeacherDto ，此方法调用 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); // 如果没有List&lt;StudentDto> studentToDtoList(List&lt;Student> students); 此方法报错 @Mapping(target = \"studentDtos\", source = \"students\") TeacherDto teacherToDto(Teacher teacher); //多对一时，每个属性最好写上起对应关系，并且此方法能正确执行依赖 TeacherDto teacherToDto(Teacher teacher); //如果teacherToDto方法不存在则会报错 @Mapping(target = \"teacherDtos\", source = \"teachers\") @Mapping(target = \"name\", source = \"school.name\") @Mapping(target = \"id\", source = \"school.id\") @Mapping(target = \"address\", source = \"school.address\") SchoolDto schoolToDto(School school, List&lt;Teacher> teachers); }测试：public class EurkaApplicationTests { @Autowired StudentConverter studentConverter; @Test public void convert() { Student student1 = new Student(); student1.setId(1); student1.setName(\"sda\"); student1.setAge(12); student1.setSex(\"男\"); Student student2 = new Student(); student2.setId(2); student2.setName(\"asdfd\"); student2.setAge(23); student2.setSex(\"男\"); Teacher teacher1 = new Teacher(); teacher1.setStudents(Arrays.asList(student1, student2)); Teacher teacher2 = new Teacher(); teacher2.setStudents(Arrays.asList(student1, student2)); List&lt;Teacher> teachers = Arrays.asList(teacher1, teacher2); School school = new School(); school.setId(123L); school.setAddress(\"育碧，苏维埃\"); school.setName(\"育碧一中\"); //调用mapper转换 SchoolDto schoolDto = studentConverter.schoolToDto(school, teachers); System.out.println(\"school = \" + school); System.out.println(\"teachers = \" + teachers); System.out.println(\"schoolDto = \" + schoolDto); } }运行结果： school = School(id=123, address=育碧，苏维埃, name=育碧一中) teachers = [ Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]), Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]) ] schoolDto = SchoolDto( id=123, address=育碧， 苏维埃, name=育碧一中, teacherDtos=[ TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男),StudentDto(id=2, name=asdfd, age=23, gender=男)]), TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男), StudentDto(id=2, name=asdfd, age=23, gender=男)]) ])","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"javaBean","slug":"javaBean","permalink":"https://ubisoft-potato.github.io/tags/javaBean/"}]},{"title":"docker部署mysql5.7","slug":"docker部署mysql5-7","date":"2019-09-19T12:28:54.000Z","updated":"2020-09-20T11:24:34.237Z","comments":true,"path":"2019/09/19/docker-bu-shu-mysql5-7/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/19/docker-bu-shu-mysql5-7/","excerpt":"","text":"docker部署mysql与传统方式对比1、传统方式：在linux上直接使用yum安装 或者mysql官网下载 tar.gz安装，使用tar.gz可能还要自己手动解决依赖问题，yum安装虽然解决了依赖问题，但是随着日益增多，其他数据安装，以及开发环境，难免会引起于其他开发环境的冲突2、docker容器化部署docker是基于linux容器技术发展而来，而linux容器技术能做到进程隔离，从而使得各个服务的部署独立，互不干扰，使用docker部署mysql，还可以部署在同一台服务器上部署不同版本的mysql，而互不影响，比起传统方式，既不用担心依赖，也不用担心开发环境不同而造成影响docker化mysql步骤安装dockercentOS 直接使用yum install docker安装debian系列：使用 apt-get install docker拉去dockerhub mysql官方镜像docker pull mysql:5.7下载完成后 ，使用docker images 查看当前所有镜像 如下所示：REPOSITORY TAG IMAGE ID CREATED SIZE mysql 5.7 383867b75fd2 7 days ago 373MB mongo latest cdc6740b66a7 5 weeks ago 361MB可以看到 TAG 下面标着 5.7， 即mysql的5.7版本运行mysql5.7镜像docker run -v ${pwd}/mysql:/var/lib/mysql –name mysql5.7 -d -e MYSQL_ROOT_PASSWORD=root-p 3306:3306 mysql:5.7参数解析：-v ${pwd}/mysql:/var/lib/mysql 把容器里的/var/lib/mysql目录挂载到实体机的当前执行此docker命令的目录下mysql上，这样容器里的数据库文件就映射到了实体机，即使容器挂掉，mysql的数据还在-p 3306：3306 把主机的3306 端口映射到容器的3306端口，使得可以再容器外访问mysql-d 使容器在后太运行-e 指定mysql容器的运行环境参数， MYSQL_ROOT_PASSWORD 可以设定mysql的root账户的密码查看运行结果docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ee000f76f8fd mongo:latest &quot;docker-entrypoint.s…&quot; 2 days ago Up About an hour 0.0.0.0:27017-&gt;27017/tcp mongoDB b32313af6fd9 mysql:5.7 &quot;docker-entrypoint.s…&quot; 3 days ago Up About an hour 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql5.7 此时，可以看到status显示 运行时间，我的已经运行了一小时，如果失败，status会显示为 Exited ，说明容器运行失败，原因基本上是 docker run 命令参数不全或者错误导致的,这时，可以使用数据库连接工具进行连接，也可以进入容器执行sql查看结果，本文以进入容器为例：执行：docker exec -it ${CONTAINER ID} bash 这里填写自己的mysql容器id,-it表示以交互模式进入容器，容器内部就像是一个精简的linux，可以执行 linux基本命令 root@cyka:/docker-all-conf/mysql5.7/conf.d# docker exec -it mysql5.7 bash root@b32313af6fd9:/# 可以看到进入容器后@后已经变成容器id，相当于linux的host 这是可以运行 mysql -uroot -p 输入 密码后进入mysql执行sql root@b32313af6fd9:/# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.27 MySQL Community Server (GPL) Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | forum-server | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.01 sec) mysql&gt; docker部署mysql5.7完成！如果想配置mysql的配置文件，可以把mysql的配置文件目录挂载，这样就可以自己配置了。","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ubisoft-potato.github.io/tags/mysql/"}]},{"title":"SpringBoot集成graphql文件上传","slug":"SpringBoot集成graphql文件上传","date":"2019-09-13T12:25:11.000Z","updated":"2020-09-20T11:24:38.454Z","comments":true,"path":"2019/09/13/springboot-ji-cheng-graphql-wen-jian-shang-chuan/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/13/springboot-ji-cheng-graphql-wen-jian-shang-chuan/","excerpt":"","text":"SpringBoot集成graphql文件上传graphql上传文件所面临的问题在国内，目前使用graphql的公司并不多，facebook设计graphql主要支持是js，对于java的支持主要靠的还是社区，目前使用最多的是graphql-spring-boot与SpringBoot的整合，以及schema解析工具graphql-java-tools，maven依赖如下，但其对Graphql实现的servlet对文件上传的支持却迟迟没有的demo &lt;dependency> &lt;groupId>com.graphql-java-kickstart&lt;/groupId> &lt;artifactId>graphql-spring-boot-starter&lt;/artifactId> &lt;version>5.9.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.graphql-java-kickstart&lt;/groupId> &lt;artifactId>graphql-java-tools&lt;/artifactId> &lt;version>5.6.1&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.graphql-java-kickstart&lt;/groupId> &lt;artifactId>graphiql-spring-boot-starter&lt;/artifactId> &lt;version>5.6.0&lt;/version> &lt;/dependency> 解决方案于是本人就上stackoverflow求助各路大神，但是由于graphql文件上传过于冷门，没人回答最终还是得靠自己解决，附上原文链接，有兴趣得朋友可以看看How to upload files with graphql-java?","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://ubisoft-potato.github.io/tags/文件上传/"},{"name":"graphql-java","slug":"graphql-java","permalink":"https://ubisoft-potato.github.io/tags/graphql-java/"}]},{"title":"SpringBoot自定义自动配置","slug":"SpringBoot自定义自动配置","date":"2019-09-08T08:26:34.000Z","updated":"2020-09-20T11:24:43.430Z","comments":true,"path":"2019/09/08/springboot-zi-ding-yi-zi-dong-pei-zhi/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/08/springboot-zi-ding-yi-zi-dong-pei-zhi/","excerpt":"","text":"前言为什么需要自定义spring自动配置?在很多时候，我们会需要开发一些公共组件jar包，同时我们又希望能在项目启动时自动加载，所以可以通过自定义自动配置包来到达此目的。准备工作自动配置原理如果不懂springboot自动配置原理，可以看先之前一篇springboot自动配置原理maven引入springboot核心依赖版本依赖父工程的springboot版本号，可自行决定&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>your-version&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;/project>开发需要自动注入的组件 import org.apache.ibatis.datasource.pooled.PooledDataSource; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; @Configuration public class AutoConfigDemo { @Bean @ConditionalOnClass(PooledDataSource.class) public DataSource MyDataSource() { //比如自己注入一个apache的数据源 return new PooledDataSource(); } }上述代码首先在类上添加了@configuration注解，说明这是一个配置类，此时这个类就相当于ssm项目中的applicationContext.xml， @Bean 标注的方法则相当于applicationContext.xml中如下配置:说明：@ConditionalOnClass(PooledDataSource.class)意为当PooledDataSource类存在时才注入这个bean，可以实现注入bean控制&lt;bean id=\"MyDataSource\" class=\"org.apache.ibatis.datasource.pooled.PooledDataSource\"/>但是这个项目如果直接作为jar包导入你的主项目里，还不能实现自动注入，还需要在resource目录下建立 META-INF/spring.factories 文件， 如自动配置文中所述位置, 需要注意的是 文件夹必须叫META-INF，文件名也必须是spring.factories，否则无法实现自动注入， 最后 spring.factories 添加如下内容:org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.xxx.xxx.xxx.AutoConfigDemo文件路径如下：com.xxx.xxx.xxx.AutoConfigDemo 是我们的配置类全类名测试将项目打成jar包，在主项目中引入，启动主项目，实现自动注入","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"自定义Spring应用","slug":"自定义Spring应用","permalink":"https://ubisoft-potato.github.io/tags/自定义Spring应用/"}]},{"title":"SpringBoot自动配置原理","slug":"SpringBoot自动配置原理","date":"2019-09-07T09:38:26.000Z","updated":"2020-09-20T11:24:47.737Z","comments":true,"path":"2019/09/07/springboot-zi-dong-pei-zhi-yuan-li/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/07/springboot-zi-dong-pei-zhi-yuan-li/","excerpt":"","text":"自动配置原理关键注解@SpringBootApplication点击进入@SpringBootApplication注解代码@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { }其中包含@EnableAutoConfiguration注解意为开启自动配置（顺便一提:@ComponentScan注解这个注解会扫描和加了这个注解的类在同一包和子包下的所有组件即:Controller、service等,为我们省去了写xml配置文件的过程）,再点击进入@EnableAutoConfiguration注解@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?>[] exclude() default {}; String[] excludeName() default {}; }这个注解有2个方法: exclude 和 excludeName，在@SpringBootApplication中可以通过使用这两个方法来指明我们不想自动注入的类比如：我们不想让springBoot自动配置数据源（springBoot默认HikariCP连接池），这样可以自己注入数据源，达到切换连接池的目的@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) public class ForumServiceApplication { public static void main(String[] args) { SpringApplication.run(ForumServiceApplication.class, args); } }@Import(AutoConfigurationImportSelector.class),@import注解表示引入指定类型的bean，即AutoConfigurationImportSelector，SpringBoot为我们自动注入的bean全部通过它来读取,点击进入AutoConfigurationImportSelector源码public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry( autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } protected AutoConfigurationEntry getAutoConfigurationEntry( AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String> configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String> exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } protected List&lt;String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String> configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } }getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);AutoConfigurationImportSelector通过getAutoConfigurationEntry这个方法获取到需要自动注入的类，getAutoConfigurationEntry又调用了getCandidateConfigurations(annotationMetadata,attributes),getCandidateConfigurations调用SpringFactoriesLoader类的静态方法，进入SpringFactoriesLoader中，这个类是spring-core包中的public final class SpringFactoriesLoader { /** * The location to look for factories. * &lt;p>Can be present in multiple JAR files. */ public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; }自动配置核心文件通过源码注释可以看到 FACTORIES_RESOURCE_LOCATION，并且位置为META-INF/spring.factories, spring.factories是本文重点部分spring.factories内容： # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\ org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\下面所有的自动配置类将被springBoot自动注入，通过spring.factories我们可以自定义自动配置类，实现springboot容器启动时自动注入的效果","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"自动配置","slug":"自动配置","permalink":"https://ubisoft-potato.github.io/tags/自动配置/"}]}]}