{"meta":{"title":"Ubi-potato","subtitle":"Ubi-potato","description":null,"author":"Ubi-potato","url":"https://ubisoft-potato.github.io","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-19T06:01:36.891Z","comments":true,"path":"about/index.html","permalink":"https://ubisoft-potato.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-19T06:01:09.943Z","comments":true,"path":"categories/index.html","permalink":"https://ubisoft-potato.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-08-19T02:46:13.236Z","updated":"2020-08-19T02:46:13.236Z","comments":false,"path":"books/index.html","permalink":"https://ubisoft-potato.github.io/books/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-08-19T06:01:20.258Z","comments":true,"path":"tags/index.html","permalink":"https://ubisoft-potato.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-19T02:46:13.240Z","updated":"2020-08-19T02:46:13.240Z","comments":false,"path":"repository/index.html","permalink":"https://ubisoft-potato.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-19T02:46:13.240Z","updated":"2020-08-19T02:46:13.240Z","comments":true,"path":"links/index.html","permalink":"https://ubisoft-potato.github.io/links/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-08-19T06:07:37.000Z","updated":"2020-08-19T06:07:59.548Z","comments":true,"path":"contact/index.html","permalink":"https://ubisoft-potato.github.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"springBoot @async详解","slug":"springBoot-async详解","date":"2020-09-02T06:20:15.000Z","updated":"2020-09-02T07:50:18.448Z","comments":true,"path":"2020/09/02/springboot-async-xiang-jie/","link":"","permalink":"https://ubisoft-potato.github.io/2020/09/02/springboot-async-xiang-jie/","excerpt":"","text":"1、SpringBoot异步处理支持Spring提供了@Aysnc注解进行便捷的异步处理支持,只需要在bean的方法上标注@Async注解即可使得方法异步提交到线程池处理，调用方无需等待。2、如何使用？在SpringBoot中使用只需使用Java代码配置或者XML配置：@Configuration @EnableAsync public class SpringAsyncConfig { ... } @EnableAsync有值得注意的属性：annotation – 默认情况下， @EnableAsync 只检测 Spring的 @Async 注解 和 EJB 3.1的 javax.ejb.Asynchronous注解；这个属性可以配置额外的需要检测的注解，所以我们可以自定义注解。mode – 指定异步代理类生成模式 – JDK 或者 AspectJ 织入proxyTargetClass – 指定使用的代理模式 -CGLIB 或者 JDK; 这个属性只有在将上述 mode 属性设置为 AdviceMode.PROXY才有效order – 设置 AsyncAnnotationBeanPostProcessor后置处理器的调用优先级,默认情况下，这个后置处理器是最后执行，确保能代理所有bean3、@Async注解@Async有2个限制使用条件：必须使用在public方法上，因为私有的方法无法被代理自我调用 – 在同一个类中调用标注@Async的方法。因为在代理类中调用会直接调用原对象的方法3.1、方法返回void@Async public void asyncMethodWithVoidReturnType() { System.out.println(\"Execute method asynchronously. \" + Thread.currentThread().getName()); }3.2、方法具有返回值如果方法有返回值，则需要用Future进行包装：@Async public Future&lt;String> asyncMethodWithReturnType() { System.out.println(\"Execute method asynchronously - \" + Thread.currentThread().getName()); try { Thread.sleep(5000); return new AsyncResult&lt;String>(\"hello world !!!!\"); } catch (InterruptedException e) { // } return null; }Spring提供了一个AsyncResult类，它实现了JDK的Future接口，可以用来跟踪异步方法执行的结果。public void testAsyncAnnotationForMethodsWithReturnType() throws InterruptedException, ExecutionException { System.out.println(\"Invoking an asynchronous method. \" + Thread.currentThread().getName()); Future&lt;String> future = asyncAnnotationExample.asyncMethodWithReturnType(); while (true) { if (future.isDone()) { System.out.println(\"Result from asynchronous process - \" + future.get()); break; } System.out.println(\"Continue doing something else. \"); Thread.sleep(1000); } }4、配置线程池默认，Spring使用SimpleAsyncTaskExecutor来执行异步任务，但是可以在应用级和方法级进行自定义线程池：4.1、方法级自定义线程池首先配置一个自定义的线程池bean：@Configuration @EnableAsync public class SpringAsyncConfig { @Bean(name = \"threadPoolTaskExecutor\") public Executor threadPoolTaskExecutor() { return new ThreadPoolTaskExecutor(); } }在@Async注解上指定该方法允许的线程池：@Async(\"threadPoolTaskExecutor\") public void asyncMethodWithConfiguredExecutor() { System.out.println(\"Execute method with configured executor - \" + Thread.currentThread().getName()); }4.2、应用级自定义线程池给整个应用配置默认的线程池需要实现AsyncConfigurer接口，需要实现其getAsyncExecutor()方法，这个方法放回的线程池作为整个应用的异步任务线程池@Configuration @EnableAsync public class SpringAsyncConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { return new ThreadPoolTaskExecutor(); } }5、异常处理如果一步方法返回Future，处理异常非常简单，因为Future.get()方法会抛出异常，但是如果返回void，异常不会传递到调用线程，所以需要额外的配置来进行处理这类异常。通过实现AsyncUncaughtExceptionHandler接口，自定义异步异常处理，实现handleUncaughtException()方法捕获异步处理的异常：public class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler { @Override public void handleUncaughtException( Throwable throwable, Method method, Object... obj) { System.out.println(\"Exception message - \" + throwable.getMessage()); System.out.println(\"Method name - \" + method.getName()); for (Object param : obj) { System.out.println(\"Parameter value - \" + param); } } }同时需要在上述的AsyncConfigurer的实现类中实现getAsyncUncaughtExceptionHandler()方法来注册这个异常处理器：@Configuration @EnableAsync public class SpringAsyncConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { return new ThreadPoolTaskExecutor(); } @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return new CustomAsyncExceptionHandler(); } }","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://ubisoft-potato.github.io/tags/异步/"}]},{"title":"spring cloud commons 介绍","slug":"spring-cloud-commons-介绍","date":"2020-08-29T07:21:26.000Z","updated":"2020-08-29T13:16:29.924Z","comments":true,"path":"2020/08/29/spring-cloud-commons-jie-shao/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/29/spring-cloud-commons-jie-shao/","excerpt":"","text":"Spring Cloud Commons简介Spring Cloud Commons工程提供了两个库功能：Spring Cloud Context和Spring Cloud Commons。 Spring Cloud Context为Spring Cloud应用程序的ApplicationContext（bootstrap引导程序上下文，encryption加密，refreshScope刷新作用域和环境端点）提供实用程序和特殊服务。 Spring Cloud Commons是在不同的Spring Cloud实现中使用的一组抽象和通用类（例如，Spring Cloud Netflix与Spring Cloud Consul以及现在的Spring cloud Alibaba）。Spring Cloud ContextBootstrap ContextTextEncryptor 组件Refresh Scope（当bean的属性在外部被修改时，bean会被重新创建而应用不需要重启）Environment对象监控Spring Cloud CommonsDiscoveryClient 接口ServiceRegistry 接口RestTemplate 使用 DiscoveryClient来获取目标主机host启动级上下文一个spring cloud应用依赖一个bootstrap上下文运作，它是整个应用中的父级容器。它会负责应用从外部加载应用的配置属性和读取本地的配置文件，并且这2部分配置属性共享一个Environment。默认情况下，启动级属性会被以最高优先级添加，所以它们不能被本地配置覆盖。配置启动级上下文加载的属性需要使用bootstrap.yml而不是使用application.yml，一次能够将启动级属性和应用级属性的配置区分开，bootstrap.yml`简易配置案例：spring: application: name: foo cloud: config: uri: ${SPRING_CONFIG_URI:http://localhost:8888}如果需要配置应用的名称，则可以在bootstrap.yml 或 application.yml中配置spring.application.name属性，如果需要配置为applicationContext的ID，则只能在bootstrap.yml中配置。同时我们也能够完全禁止处理启动级上下文处理通过设置spring.cloud.bootstrap.enabled=false属性Application Context 继承关系如果通过 SpringApplication或 SpringApplicationBuilder进行构建应用，bootstrap上下文会自动的添加到应用中成为整个应用的父级上下文。并且Spring的子上下文会继承父级上下文的属性和profile，所以，应用能够包含许多额外的属性源：“bootstrap”: 启动级上下文中发现有任何的 PropertySourceLocators ，则将会使用最高优先级的 CompositePropertySource。比如： Spring Cloud Config Server。“applicationConfig: [classpath:bootstrap.yml]”：如果配置了 bootstrap.yml (或者 .properties), 这个配置将用来配置启动级上下文。设置ApplicationContext的父级上下文可以使用SpringApplicationBuilder的parent(), child()和 sibling()方法，通常来说启动级上下文就是父级上下文，并且子上下文的属性会覆盖父上下文的同名属性修改Bootstrap Properties的加载位置bootstrap.yml (或 .properties) 所在位置可以JVM系统属性配置 spring.cloud.bootstrap.name (默认: bootstrap)，spring.cloud.bootstrap.location (默认: 空) 或 spring.cloud.bootstrap.additional-location (默认: 空)spring.cloud.bootstrap.location修改默认的位置。 spring.cloud.bootstrap.additional-location 将会添加额外的配置文件地址。实际上，这些配置都是用来创建启动级ApplicationContext，如果有profile属性（spring.profiles.active）被设置，存在于这个profile下的属性都会被加载，比如：bootstrap-development.properties 指定了 development 的profile。覆盖”远程”配置的属性通过启动级上下文加载的属性源都属于”远程”配置的属性，比如：Spring Cloud Config Server，默认不能被本地的配置覆盖，通过设置spring.cloud.config.allowOverride=true，一旦配置此属性就可以通过以下2个属性进行细化配置：spring.cloud.config.overrideNone=true:只允许任何本地的配置文件覆盖spring.cloud.config.overrideSystemProperties=false: 只允许系统属性、命令行参数和环境变量进行覆盖。自定义启动级配置/META-INF/spring.factories文件的org.springframework.cloud.bootstrap.BootstrapConfiguration属性可以添加我们自定义的启动级配置类。这个文件通过逗号分隔维护了一个@Configuration指定的用于创建上下文的配置类列表。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://ubisoft-potato.github.io/tags/spring-cloud/"}]},{"title":"BeanFactory和ApplicationContext的区别和联系","slug":"BeanFactory和ApplicationContext的区别和联系","date":"2020-08-27T07:38:22.000Z","updated":"2020-08-29T07:23:00.245Z","comments":true,"path":"2020/08/27/beanfactory-he-applicationcontext-de-qu-bie-he-lian-xi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/27/beanfactory-he-applicationcontext-de-qu-bie-he-lian-xi/","excerpt":"","text":"","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"Spring Environment","slug":"Spring-Environment","date":"2020-08-24T13:32:06.000Z","updated":"2020-08-25T13:46:14.639Z","comments":true,"path":"2020/08/24/spring-environment/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/24/spring-environment/","excerpt":"","text":"Environment 概念Environment 接口抽象出2个关键概念：profiles 和 properties.profile是在XML和注解定义的bean定义元数据的逻辑组，Environment能决定当前使用哪一个逻辑组的bean定义元数据，那些是默认使用的。Properties在所有的应用程序中占有非常重要的地位，它可以来自多种来源：属性文件，JVM系统属性，系统环境变量，JNDI，Servlet上下文参数，临时属性对象，Map对象等。Environment提供了方便的接口来供开发者来配置属性源以及从中获取属性。BeanDefinition ProfilesBeandefinition profiles 提供了一种能够在不同环境注册不同的bean的机制，Environment对不同的用户来说可以是不同的意义：在开发环境注入本地数据源在性能检测开发环境注入监控组件为客户A和客户B部署注册bean的自定义实现使用 @Profile@Profile注解能够在多环境下指定那些bean需要注入，比如，在开发环境注入内嵌数据源，生产环境注入其他数据源:@Configuration @Profile(\"development\") public class StandaloneDataConfig { @Bean public DataSource dataSource() { return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.HSQL) .addScript(\"classpath:com/bank/config/sql/schema.sql\") .addScript(\"classpath:com/bank/config/sql/test-data.sql\") .build(); } }@Configuration @Profile(\"production\") public class JndiDataConfig { @Bean(destroyMethod=\"\") public DataSource dataSource() throws Exception { Context ctx = new InitialContext(); return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\"); } }profile的名称可能包含环境名称（比如：production），同时还支持复杂的表达式：production &amp; us-east，支持以下表达式：!:逻辑非&amp;: 逻辑与|: 逻辑或混合使用&amp;和|必须要用括号区分，比如：production &amp; us-east | eu-central不能通过验证，需要使用如下：production &amp; (us-east | eu-central)可以使用@Profile作为原注解来开发组合注解，一下案例开发了一个@Production注解，其功能和@Profile(&quot;production&quot;)一致：@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Profile(\"production\") public @interface Production { }@Configuration标注的配置类也被@Profile标注，这个配置类下的所有@Bean以及配置类上的@Import注解倒入的bean都只会在指定的环境中生效，如果@Component和@Configuration被@Profile({&quot;p1&quot;, &quot;p2&quot;})标注，则只有在p1或p2环境被启用的时候它们才会被注入，如果被@Profile({&quot;p1&quot;, &quot;!p2&quot;})标注，则只有当p1激活或p2不被激活时被注入。@Profile 也能被标注到配置类的方法级别：@Configuration public class AppConfig { @Bean(\"dataSource\") @Profile(\"development\") public DataSource standaloneDataSource() { return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.HSQL) .addScript(\"classpath:com/bank/config/sql/schema.sql\") .addScript(\"classpath:com/bank/config/sql/test-data.sql\") .build(); } @Bean(\"dataSource\") @Profile(\"production\") public DataSource jndiDataSource() throws Exception { Context ctx = new InitialContext(); return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\"); } }激活Profile激活当前应用配置有许多方式：但是最直接的方式是通过ApplicationContext获取Environment通过api来直接指定Profilepublic void start(){ AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.getEnvironment().setActiveProfiles(\"development\"); ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class); ctx.refresh(); }还可以通过spring.profiles.active属性来指定，还能通过系统的环境变量、JVM系统属性等方式配置该属性。如果在单元测试中，需要使用@ActiveProfiles来指定tip：profile可以指定多个，它们并不是互相冲突的，比如可以通过setActiveProfiles()一次注册多个环境:ctx.getEnvironment().setActiveProfiles(&quot;profile1&quot;, &quot;profile2&quot;);通过运行时参数： -Dspring.profiles.active=&quot;profile1,profile2&quot;默认的Profile@Configuration @Profile(\"default\") public class DefaultDataConfig { @Bean public DataSource dataSource() { return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.HSQL) .addScript(\"classpath:com/bank/config/sql/schema.sql\") .build(); } }如果没有指定环境，则上述默认的DataSource将会被注入，指定则不会注入。通过setDefaultProfiles()方法可以指定默认的环境，或者通过spring.profiles.default属性指定PropertySourceEnvironment提供获取属性的api：ApplicationContext ctx = new GenericApplicationContext(); Environment env = ctx.getEnvironment(); boolean containsMyProperty = env.containsProperty(&quot;my-property&quot;); System.out.println(&quot;Does my environment contain the &#39;my-property&#39; property? &quot; + containsMyProperty);上述代码通过Environment查询是否包含my-property属性，其内部是通过遍历 PropertySource 集合，PropertySource是key-value的简单抽象，Spring’的StandardEnvironment 配置了2个PropertySource对象–一个是JVM系统属性（System.getProperties())，另一个是操作系统环境变量（System.getenv())。对于独立的应用，默认的PropertySource实现类是StandardEnvironment,StandardServletEnvironment可以获取到额外的一些熟悉，比如servlet配置和servlet上下文参数当使用StandardEnvironment时，当调用env.containsProperty(&quot;my-property&quot;)时，如果系统属性或者环境变量包含my-property属性则返回true查询属性的过程时：系统属性优先于环境变量，所以。如果my-property同时在系统属性和环境变量中设置，会优先使用系统属性，而不是合并相同的属性如果需要自定义属性源可以实现PropertySource并添加到Environment中：public void addPropertiySource(){ ConfigurableApplicationContext ctx = new GenericApplicationContext(); MutablePropertySources sources = ctx.getEnvironment().getPropertySources(); sources.addFirst(new MyPropertySource()); }MutablePropertySources提供了一系列的API对PropertySource进行操作使用@PropertySource注解@PropertySource提供一种声明式的方式添加PropertySource到Environment如果有一个叫app.properties的文件包含：testbean.name=myTestBean@Configuration @PropertySource(\"classpath:/com/myco/app.properties\") public class AppConfig { @Autowired Environment env; @Bean public TestBean testBean() { TestBean testBean = new TestBean(); testBean.setName(env.getProperty(\"testbean.name\")); return testBean; } }通过上述配置之后，调用testBean.getName()返回myTestBean@PropertySource还支持${…}表达式：@Configuration @PropertySource(\"classpath:/com/${my.placeholder:default/path}/app.properties\") public class AppConfig { @Autowired Environment env; @Bean public TestBean testBean() { TestBean testBean = new TestBean(); testBean.setName(env.getProperty(\"testbean.name\")); return testBean; } }my.placeholder需要预先注册到Environment中，如果未找到则默认使用default/path@PropertySource是可重复使用的。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"Spring 容器扩展点","slug":"Spring-容器扩展点","date":"2020-08-22T13:52:07.000Z","updated":"2020-08-24T06:01:35.080Z","comments":true,"path":"2020/08/22/spring-rong-qi-kuo-zhan-dian/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/22/spring-rong-qi-kuo-zhan-dian/","excerpt":"","text":"Spring ioC容器扩展点通常来说，开发这不需要继承ApplicationContext来扩展功能，相反，Spring容器可以通过许多指定的接口进行扩展。使用BeanPostProcessor进行bean自定义BeanPostProcessor定义的回掉方法可以用来实现自己bean初始化逻辑，解决依赖逻辑等，如果需要在Spring容器对bean进行实例化、配置、初始化后进行一些自定义操作，也可以实现一系列BeanPostProcessor添加到容器中BeanPostProcessor会作用于bean（或者说时对象）上，每当Springioc容器初始化一个bean，BeanPostProcessor就会被回掉。BeanPostProcessor作用于一个容器中，如果使用父子关系的容器，bean只会被同一个容器中的BeanPostProcessor所处理。如果需要修改bean的定义元数据，即beanDefinition，需要使用BeanFactoryPostProcessororg.springframework.beans.factory.config.BeanPostProcessor由2个回掉方法组成，当一个对象被注册为BeanPostProcessor，只要当Spring容器创建bean，BeanPostProcessor就会在bean的初始化前和初始化后被回掉，这次期间，BeanPostProcessor可以对bean做任何事情，比如：检查bean被回掉的次数、Spring Aop就是通过BeanPostProcessor给bean实现代理逻辑ApplicationContext会自动检测到容器中实现BeanPostProcessor接口的bean，ApplicationContext会注册这些bean以便后期被调用，BeanPostProcessor可以就像注册普通bean一样被注册到容器。手动注册BeanPostProcessor实例：虽然推荐使用ApplicationContext自动检测来注册，但是也可以通过ConfigurableBeanFactory的addBeanPostProcessor方法来手动注册，这种做法的好处就是可以在注册之前实现一些逻辑。注意：手动注册的BeanPostProcessor不会遵循Ordered接口来配置执行顺序，手动注册的BeanPostProcessor总是优先于自动检测的BeanPostProcessor执行。BeanPostProcessor实例和AOP 自动代理：实现BeanPostProcessor接口的类将会被容器区分对待，所有的BeanPostProcessor的实例以及他们直接依赖的bean都将在应用启动的时候实例化，作为ApplicationContext的一个特殊启动阶段。因为AOP自动代理是通过BeanPostProcessor实现的，所以BeanPostProcessor实例或它们直接引用的bean都不适合进行自动代理，因此不会被注入切面。对于这样的Bean，通常会看到以下日志信息：Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)如果我们通过@autowire或@Resource（可能会退回到自动装配）注入bean到BeanPostProcessor实例中，则Spring在搜索类型匹配的依赖项候选对象时可能会访问意想不到的Bean，因此使这些bean不符合自动代理或被后置处理。案例：BeanPostProcessorBeanPostProcessor的基本使用，以下案例将会在bean创建完成之前调用bean的toString()方法获取bean信息：import org.springframework.beans.factory.config.BeanPostProcessor; public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor { // simply return the instantiated bean as-is public Object postProcessBeforeInitialization(Object bean, String beanName) { return bean; // we could potentially return any object reference here... } public Object postProcessAfterInitialization(Object bean, String beanName) { System.out.println(\"Bean '\" + beanName + \"' created : \" + bean.toString()); return bean; } }&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:lang=\"http://www.springframework.org/schema/lang\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd\"> &lt;lang:groovy id=\"messenger\" script-source=\"classpath:org/springframework/scripting/groovy/Messenger.groovy\"> &lt;lang:property name=\"message\" value=\"Fiona Apple Is Just So Dreamy.\"/> &lt;/lang:groovy> &lt;!-- when the above bean (messenger) is instantiated, this custom BeanPostProcessor implementation will output the fact to the system console --> &lt;bean class=\"scripting.InstantiationTracingBeanPostProcessor\"/> &lt;/beans>以上xml配置使用Groovy定义bean：messager使用BeanPostProcessor：import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.scripting.Messenger; public final class Boot { public static void main(final String[] args) throws Exception { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"scripting/beans.xml\"); Messenger messenger = ctx.getBean(\"messenger\", Messenger.class); System.out.println(messenger); } }运行结果:Bean &#39;messenger&#39; created : org.springframework.scripting.groovy.GroovyMessenger@272961 org.springframework.scripting.groovy.GroovyMessenger@272961使用BeanFactoryPostProcessor自定义配置元数据org.springframework.beans.factory.config.BeanFactoryPostProcessor也是Ioc容器的扩展点，和BeanPostProcessor类似，但是有一个主要的区别：BeanFactoryPostProcessor操作bean的配置元数据（beanDefinition），Spring Ioc容器能够让BeanFactoryPostProcessor读取到配置元数据并有可能在容器实例化除BeanFactoryPostProcessor实例以外的任何bean之前更改它。我们可以配置多个BeanFactoryPostProcessor实例，并通过order属性来控制它们的调用顺序，但是只能通过实现Ordered接口来配置顺序，如果需要使用BeanFactoryPostProcessor则需要考虑到实现Ordered接口。public interface BeanFactoryPostProcessor { void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; }如果需要改变实际返回的bean实例需要使用上述的BeanPostProcessor，从技术上来说，在postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)中可以使用BeanFactory.getBean()来获取bean然后修改它，但是这回导致提前bean实例化并且打乱容器正常的生命周期，这种做法会带来许多负面影响，比如：bean不会被所有的BeanPostProcessor做后置处理ApplicationContext会自动调用这些BeanFactoryPostProcessor来修改bean的配置元数据，Spring内置了一些实现：PropertyOverrideConfigurer和PropertySourcesPlaceholderConfigurer，也可以自定义BeanFactoryPostProcessor，比如：实现自定义的bean属性修改器Bean(Factory)PostProcessor会忽略延迟加载配置，比如：标签的default-lazy-init属性BeanFactoryPostProcessor使用案例：PropertySourcesPlaceholderConfigurerPropertySourcesPlaceholderConfigurer是Spring内置的占位符处理器，就是使用的BeanFactoryPostProcessor来实现，通过PropertySourcesPlaceholderConfigurer，我们可以在bean的属性配置中使用占位符：&lt;beans> &lt;bean class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\"> &lt;property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/> &lt;/bean> &lt;bean id=\"dataSource\" destroy-method=\"close\" class=\"org.apache.commons.dbcp.BasicDataSource\"> &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> &lt;property name=\"url\" value=\"${jdbc.url}\"/> &lt;property name=\"username\" value=\"${jdbc.username}\"/> &lt;property name=\"password\" value=\"${jdbc.password}\"/> &lt;/bean> &lt;/beans>jdbc.driverClassName=org.hsqldb.jdbcDriver jdbc.url=jdbc:hsqldb:hsql://production:9002 jdbc.username=sa jdbc.password=root在启动过程中。PropertySourcesPlaceholderConfigurer会读取外部的Properties文件，来替换相应的占位符。PropertySourcesPlaceholderConfigurer不仅会在Properties文件中查找值，默认情况下，如果在Properties文件不能找到相应的属性，会自动的在Spring的Environment对象中寻找，甚至是System属性小技巧：使用PropertySourcesPlaceholderConfigurer在运行时决定接口实现类：&lt;beans> &lt;bean class=\"org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer\"> &lt;property name=\"locations\"> &lt;value>classpath:com/something/strategy.properties&lt;/value> &lt;/property> &lt;property name=\"properties\"> &lt;value>custom.strategy.class=com.something.DefaultStrategy&lt;/value> &lt;/property> &lt;/bean> &lt;bean id=\"serviceStrategy\" class=\"${custom.strategy.class}\"/> &lt;/beans>如果在运行时找不到指定的类，则在ApplicationContext的preInstantiateSingletons()阶段就会报错BeanFactoryPostProcessor使用案例：PropertyOverrideConfigurerPropertyOverrideConfigurer也是Spring的常用BeanFactoryPostProcessor实现类，和PropertySourcesPlaceholderConfigurer类似，但不同的是原始定义对于bean属性可以具有默认值，也可以完全没有值。 如果覆盖的属性文件没有某个bean属性的条目，则使用默认的上下文定义。&lt;beans> &lt;bean class=\"org.springframework.beans.factory.config.PropertyOverrideConfigurer\"> &lt;property name=\"location\" value=\"classpath:myproperties.properties\" /> &lt;/bean> &lt;bean id=\"person\" class=\"com.sample.Employee\" > &lt;property name=\"name\" value=\"Dugan\"/> &lt;property name=\"age\" value=\"50\"/> &lt;/bean> &lt;/beans>myproperties.properties:person.age=40 person.name=Stanis如上配置，当获取personbean时：Employee e = (Employee)context.getBean(Employee.class); e.getAge() =&gt; 40 //被properties文件的值覆盖掉 e.getName() =&gt; &quot;Stanis&quot; //被properties文件的值覆盖掉使用FactoryBean自定义实例化逻辑如果一个对象本身作为工程类的话，可以实现org.springframework.beans.factory.FactoryBean接口，FactoryBean接口是Spring Ioc容器实例户逻辑的一个插件类，如果有一些复杂的实例化逻辑使用FactoryBean来实现比用XML配置精简的多：FactoryBean接口提供3个方法：Object getObject(): 获取FactoryBean创建的对象，对象是否为单实例取决于第二个方法返回值。boolean isSingleton(): 如果FactoryBean返回单实例则返回true，否则返回falseClass getObjectType(): 返回 getObject() 方法放回对象的类型，如果为止则返回nullFactoryBean在Spring中被大量使用，超过50个类实现了FactoryBean接口。当我们需要获取FactoryBean本身而不是FactoryBean产生的对象时，需要在bean 的id前加上&amp;。比如：有一个FactoryBean的id为myBean，当调用getBean(&quot;myBean&quot;)时，将会得到FactoryBean的getObject()方法产生的对象，而调用getBean(&quot;&amp;myBean&quot;)时会得到FactoryBean本身","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"Spring自定义Bean的特性","slug":"Spring自定义Bean的特性","date":"2020-08-21T05:13:28.000Z","updated":"2020-08-22T13:28:16.570Z","comments":true,"path":"2020/08/21/spring-zi-ding-yi-bean-de-te-xing/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/21/spring-zi-ding-yi-bean-de-te-xing/","excerpt":"","text":"如何定制Spring BeanSpring提供了一系列用于自定义Bean特性的接口，主要有以下3类：生命周期 回掉ApplicationContextAware和 BeanNameAware其他的 Aware接口生命周期回掉为了能够与Spring管理的bean的生命周期交互，可以实现InitializingBean和DisposableBean接口，Spring容器会在初始化和销毁bean的时期分别回掉afterPropertiesSet()和destroy()方法tips：Spring官方还是推荐使用JSR-250规范的 @PostConstruct 和 @PreDestroy 注解进行生命周期回掉声明，因为这样不会耦合Spring的代码，当然如果既不想耦合Spring的代码又想进行生命周期回掉，可以给beanDefinition指定init-method 和 destroy-method属性在Spring内部，Spring使用BeanPostProcessor来完成生命周期的各种回掉函数，如果想要自定义或者实现Spring没有提供的生命周期行为，可以考虑实现BeanPostProcessor来完成目标除了生命周期回掉函数之外，Spring管理的对象也可能实现了Lifecycle接口，所以这些对象能够参与应用的启动与停止的过程。初始化回掉org.springframework.beans.factory.InitializingBean 接口能够在容器为Bean设置了所有必要的属性后执行初始化工作。public interface InitializingBean { void afterPropertiesSet() throws Exception; }但是，秉承不耦合Spring的宗旨，建议使用 @PostConstruct注解或指定生命周期回掉函数。比如通过@Bean注解：public class BeanOne { public void init() { // initialization logic } } @Configuration public class AppConfig { @Bean(initMethod = \"init\") public BeanOne beanOne() { return new BeanOne(); } @Bean(destroyMethod = \"cleanup\") public BeanTwo beanTwo() { return new BeanTwo(); } }@PostConstruct注解实现：public class CachingMovieLister { @PostConstruct public void populateMovieCache() { // populates the movie cache upon initialization... } @PreDestroy public void clearMovieCache() { // clears the movie cache upon destruction... } }销毁回掉实现org.springframework.beans.factory.DisposableBean接口的bean能够在bean销毁的时候被回掉:public class CachingMovieLister { @PreDestroy public void clearMovieCache() { // clears the movie cache upon destruction... } }同上推荐的方式是：public class BeanTwo { public void cleanup() { // destruction logic } } @Configuration public class AppConfig { @Bean(destroyMethod = \"cleanup\") public BeanTwo beanTwo() { return new BeanTwo(); } }默认的初始化和销毁的回掉方法当不使用InitializingBean和DisposableBean接口实现生命周期回掉时，可以使用init(), initialize(), dispose()等方法名定义回掉方法，通常来说这是标准的生命周期回掉方法名，并且所有的开发者都会使用这些方法名来保持统一性。当使用init()来定义生命周期回掉时，不需要指定bean定义的init-method=&quot;init&quot;属性。所以初始化回掉就默认使用init()，销毁回掉使用dispose() ：public class DefaultBlogService implements BlogService { private BlogDao blogDao; public void setBlogDao(BlogDao blogDao) { this.blogDao = blogDao; } // this is (unsurprisingly) the initialization callback method public void init() { if (this.blogDao == null) { throw new IllegalStateException(\"The [blogDao] property must be set.\"); } } }同时，可以通过init-method和destroy-method来覆盖默认的生命周期回掉Spring容器能够保证一旦bean的所有依赖被注入就会立马回掉声明周期函方法，所以初始化回掉是发生在bean还没有被Spring Aop代理之前的时期。首先目标bean被完全创建，其次Aop再进行拦截。组合生命周期回掉机制Spring 2.5之后我们有3种选择来介入bean的生命周期：InitializingBean 和 DisposableBean 回掉方法自定义 init() 和 destroy() 方法@PostConstruct and @PreDestroy 注解.并且我们可以组合使用这3种方式来介入bean的生命周期\u0011注意：如果一个bean的生命周期被配置了多个回掉方法，那么这些回掉方法不能同名，并且将会按下面描述的顺序执行Bean初始化回掉顺序：@PostConstruct注解标注的方法最先执行InitializingBean 的afterPropertiesSet() 方法自定义的 init()方法bean销毁回掉顺序同上：@PreDestroy注解标注的方法最先执行DisposableBean的 destroy() 方法自定义的destroy()方法启动和停止回掉Spring的Lifecycle接口为任何一个有自己的生命周期的bean定义了必要的方法，比如：正在启动和停止一些后任务public interface Lifecycle { void start(); void stop(); boolean isRunning(); }任何Spring管理的对象都可以实现Lifecycle接口，ApplicationContext在接收到启动和停止信号时，会将其传递给所有实现Lifecycle接口的对象，其内部时通过LifecycleProcessor来实现：public interface LifecycleProcessor extends Lifecycle { void onRefresh(); void onClose(); }LifecycleProcessor本身也继承了Lifecycle接口，并且添加了响应容器刷新和关闭的方法。注意：org.springframework.context.Lifecycle接口只是定义了启动的和停止的规范，但是并不能在上下文环境刷新时自动启动,如果需要实现自动启动，考虑实现org.springframework.context.SmartLifecycle接口更重要的是，stop()方法的回掉不能保证在bean的销毁回掉之前被调用，在正常的停止过程中，实现Lifecycle的bean会首先收到容器停止的回掉其次是bean销毁的回掉，在容器热刷新等情况下，只会接收到bean销毁的回掉。bean之间的启动和停止的调用顺序非常重要，如果2个bean之间有使用@dependsOn注解标识依赖关系，则依赖方会在被依赖方之后启动，在被依赖方之前停止，通常来说，bean之间的直接依赖关系是未知的，在这种情况下，SmartLifecycle接口定义了另一种方式来解决：其继承的父接口Phased的getPhase()方法。public interface Phased { int getPhase(); }SmartLifecycle接口：public interface SmartLifecycle extends Lifecycle, Phased { boolean isAutoStartup(); void stop(Runnable callback); }当应用启动时，phase（阶段）值越低启动优先级越高，因此，如果一个实现了SmartLifecycle接口的对象的getPhase()方法返回值为Integer.MIN_VALUE将会成为最先启动的，最后停止的对象，反之亦然，没有实现SmartLifecycle的普通Lifecycle接口的phase值是0，因此任何负数phase值都将会优先于这些普通的对象创建。SmartLifecycle定义的停止方法接收一个回掉函数，任何实现SmartLifecycle的对象都必须在应用停止的时候调用回掉函数的run()方法，DefaultLifecycleProcessor支持异步回掉停止方法，并且每个阶段的bean回掉超时默认是30s，可以通过自定义DefaultLifecycleProcessor进行修改：&lt;bean id=\"lifecycleProcessor\" class=\"org.springframework.context.support.DefaultLifecycleProcessor\"> &lt;!-- timeout value in milliseconds --> &lt;property name=\"timeoutPerShutdownPhase\" value=\"10000\"/> &lt;/bean>LifecycleProcessor接口定义了在容器刷新和关闭时候的回掉方法，当所有的bean都实例化和初始化完后（即容器刷新）LifecycleProcessor会调用SmartLifecyclebean的isAutoStartup()方法，如果返回true，则SmartLifecyclebean的start()方法会被直接回掉，而不是等待显式的调用。非web环境优雅关闭Spring ioC容器如果在非web环境中使用Spring ioC容器，需要注册一个钩子到JVM上，这样能够确保调用所有单例bean的销毁方法使得所有资源被释放，所以必须正确的配置和实现这些销毁回掉函数。调用ConfigurableApplicationContext的registerShutdownHook()方法注册钩子：import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public final class Boot { public static void main(final String[] args) throws Exception { ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\"); // add a shutdown hook for the above context... ctx.registerShutdownHook(); // app runs here... // main method exits, hook is called prior to the app shutting down... } }","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"Netty 客户端开发连接池","slug":"Netty-客户端开发连接池","date":"2020-08-20T04:57:50.000Z","updated":"2020-08-20T05:20:56.663Z","comments":true,"path":"2020/08/20/netty-ke-hu-duan-kai-fa-lian-jie-chi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/20/netty-ke-hu-duan-kai-fa-lian-jie-chi/","excerpt":"","text":"使用Netty提供的连接池通常来说，使用netty开发服务端应用不需要使用到连接池来管理客户端与服务端的连接，但是在客户端开发中，在发送请求时就新开一个Tcp连接会导致性能低下，所以在web开发中我们会使用到Druid这样的数据库连接池。Netty在4.0.28.Final 版本发布时添加了ChannelPool接口，方便开发客户端池化Channel，以此减少重复代码。在Reactor-netty中就使用到了ChannelPool来开发它自己的HttpClient官方提供的使用案例public static void main(string[] args){ EventLoopGroup group = new NioEventLoopGroup(); final Bootstrap cb = new Bootstrap(); InetSocketAddress addr1 = new InetSocketAddress(\"10.0.0.10\", 8888); InetSocketAddress addr2 = new InetSocketAddress(\"10.0.0.11\", 8888); cb.group(group).channel(NioSocketChannel.class); ChannelPoolMap&lt;InetSocketAddress, SimpleChannelPool> poolMap = new AbstractChannelPoolMap&lt;InetSocketAddress, SimpleChannelPool>() { @Override protected SimpleChannelPool newPool(InetSocketAddress key) { return new SimpleChannelPool(cb.remoteAddress(key), new TestChannelPoolHandler()); } }; // depending on when you use addr1 or addr2 you will get different pools. final SimpleChannelPool pool = poolMap.get(addr1); Future&lt;Channel> f = pool.acquire(); f.addListener(new FutureListener&lt;Channel>() { @Override public void operationComplete(Future&lt;Channel> f) { if (f.isSuccess()) { Channel ch = f.getNow(); // Do somethings // ... // ... // Release back to pool pool.release(ch); } } }); }TIP：ChannelPoolMap的key可以是任何对象，所以极其灵活，比如它还可以是不同的EventLoopChannelPool与channelGroup的区别ChannelPool是用来实现池化操作，像是数据库连接池、httpClient等，而channelGroup是用来实现广播或者批量操作，比如一次性关闭同一个组中的所有Channel或者是同时发送一条消息到同一个组中的所有Channel。","categories":[{"name":"Netty","slug":"Netty","permalink":"https://ubisoft-potato.github.io/categories/Netty/"}],"tags":[{"name":"connectionPool","slug":"connectionPool","permalink":"https://ubisoft-potato.github.io/tags/connectionPool/"}]},{"title":"ApplicationContext额外的功能","slug":"ApplicationContext应用级功能","date":"2020-08-19T04:42:43.000Z","updated":"2020-08-20T14:59:18.119Z","comments":true,"path":"2020/08/19/applicationcontext-ying-yong-ji-gong-neng/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/applicationcontext-ying-yong-ji-gong-neng/","excerpt":"","text":"ApplicationContext应用级功能org.springframework.beans.factory 包提供了管理和使用bean的基本功能， org.springframework.context 包下添加了继承BeanFactory的ApplicationContext接口，其提供了额外的应用级功能ApplicationContext提供了如下功能：通过MessageSource接口进行国际化通过ResourceLoader接口获取URLs或者文件等资源事件发布，通过ApplicationEventPublisher通知实现ApplicationListener接口的bean加载多个上下文环境（继承关系），通过HierarchicalBeanFactory使得每一个context能专注于其功能项，比如web应用的前端控制器层。使用 MessageSource进行国际化ApplicationContext接口继承了MessageSource接口，因此ApplicationContext能够提供国际化的功能，Spring也提供HierarchicalMessageSource来支持分层处理国际化，接口定义的方法包括：String getMessage(String code, Object[] args, String default, Locale loc): 从 MessageSource中获取国际化消息的基本方法。如果没有找到相应的国际化消息结果，则使用默认的值。使用 MessageFormat进行参数位置替换。String getMessage(String code, Object[] args, Locale loc): 本质上和以上方法一样，唯一不同是不提供默认值，如果未找到则抛出 NoSuchMessageExceptionString getMessage(MessageSourceResolvable resolvable, Locale locale): 上述方法使用到的参数被封装到 MessageSourceResolvable当ApplicationContext被加载时，会自动查询容器中的MessageSourcebean，并且这个bean的名字必须为messageSource，如果找到MessageSourcebean，所有相关的方法都会被代理到这个bean实现，如果未找到，ApplicationContext会查询其父容器中的messageSourcebean，如果未找到任何messageSourcebean，将会实例化DelegatingMessageSource进行使用。spring提供了2个MessageSource实现类： ResourceBundleMessageSource 和 StaticMessageSource。并且都实现了HierarchicalMessageSource接口来实现消息合并国际化处理，StaticMessageSource使用的比较少，ResourceBundleMessageSource案例：&lt;beans> &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"> &lt;property name=\"basenames\"> &lt;list> &lt;value>format&lt;/value> &lt;value>exceptions&lt;/value> &lt;value>windows&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;/beans>以上表示类路径下有3个资源集合： format, exceptions， windows ，任何请求都将通过ResourceBundle – JDK的标准方式进行国际化处理。国际化文件编写案例: # in format.properties message=Alligators rock! # in exceptions.properties argument.required=The {0} argument is required.通过代码使用MessageSource接口，记住：ApplicationContext实现了MessageSource接口，可以被强转为MessageSourcepublic static void main(String[] args) { MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\"); String message = resources.getMessage(\"message\", null, \"Default\", Locale.ENGLISH); System.out.println(message); }结果：Alligators rock!解析：上述MessageSource定义在beans.xml中，messageSourcebean通过basenames指定国际化资源文件。上述指定了3个文件： format.properties, exceptions.properties, windows.propertiesMessageSource获取使用参数：&lt;beans> &lt;!-- this MessageSource is being used in a web application --> &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"> &lt;property name=\"basename\" value=\"exceptions\"/> &lt;/bean> &lt;!-- lets inject the above MessageSource into this POJO --> &lt;bean id=\"example\" class=\"com.something.Example\"> &lt;property name=\"messages\" ref=\"messageSource\"/> &lt;/bean> &lt;/beans>public class Example { private MessageSource messages; public void setMessages(MessageSource messages) { this.messages = messages; } public void execute() { String message = this.messages.getMessage(\"argument.required\", new Object [] {\"userDao\"}, \"Required\", Locale.ENGLISH); System.out.println(message); } }结果如下：The userDao argument is required.如果想要进行英国的国际化(en-GB），需要创建 format_en_GB.properties, exceptions_en_GB.properties, windows_en_GB.properties。比如：# in exceptions_en_GB.properties argument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.public static void main(final String[] args) { MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\"); String message = resources.getMessage(\"argument.required\", new Object [] {\"userDao\"}, \"Required\", Locale.UK); System.out.println(message); } 结果如下：Ebagum lad, the &#39;userDao&#39; argument is required, I say, required.也可以使用 MessageSourceAware 接口来获取MessageSource对象，ApplicationContext中任何实现MessageSourceAware接口的对象在创建和被配置的时候都将被注入MessageSource对象。tips：ResourceBundleMessageSource的一个可选实现是ReloadableResourceBundleMessageSource，ReloadableResourceBundleMessageSource比基于JDK的ResourceBundleMessageSource更加灵活，尤其是支持从任何spring资源加载位置读取（不仅仅是类路径）以及支持热加载， 详情：ReloadableResourceBundleMessageSource标准和自定义事件ApplicationContext通过ApplicationEvent和ApplicationListener提供事件处理机制，如果容器中一个bean实现了ApplicationListener接口,每当有ApplicationEvent发布到ApplicationContext中就会通知此bean，本质上这就是观察者模式的实现。Spring 4.2之后，事件机制得到增强，Spring提供了注解开发模式以及事件不再必须实现ApplicationEvent接口，当发布事件时，Spring自动将其封装为ApplicationEvent。Spring提供的标准事件：EventExplanationContextRefreshedEventPublished when the ApplicationContext is initialized or refreshed (for example, by using the refresh() method on the ConfigurableApplicationContext interface). Here, “initialized” means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the ApplicationContext object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen ApplicationContext actually supports such “hot” refreshes. For example, XmlWebApplicationContext supports hot refreshes, but GenericApplicationContext does not.ContextStartedEventPublished when the ApplicationContext is started by using the start() method on the ConfigurableApplicationContext interface. Here, “started” means that all Lifecycle beans receive an explicit start signal. Typically, this signal is used to restart beans after an explicit stop, but it may also be used to start components that have not been configured for autostart (for example, components that have not already started on initialization).ContextStoppedEventPublished when the ApplicationContext is stopped by using the stop() method on the ConfigurableApplicationContext interface. Here, “stopped” means that all Lifecycle beans receive an explicit stop signal. A stopped context may be restarted through a start() call.ContextClosedEventPublished when the ApplicationContext is being closed by using the close() method on the ConfigurableApplicationContext interface or via a JVM shutdown hook. Here, “closed” means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted.RequestHandledEventA web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring’s DispatcherServlet.ServletRequestHandledEventA subclass of RequestHandledEvent that adds Servlet-specific context information.自定义事件案例：public class BlockedListEvent extends ApplicationEvent { private final String address; private final String content; public BlockedListEvent(Object source, String address, String content) { super(source); this.address = address; this.content = content; } // accessor and other methods... }发布事件需要调用ApplicationEventPublisher的 publishEvent() 方法，通常的做法是实现ApplicationEventPublisherAware接口，并将其注册为spring bean：public class EmailService implements ApplicationEventPublisherAware { private List&lt;String> blockedList; private ApplicationEventPublisher publisher; public void setBlockedList(List&lt;String> blockedList) { this.blockedList = blockedList; } // 重写 setApplicationEventPublisher方法获取ApplicationEventPublisher public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; } public void sendEmail(String address, String content) { if (blockedList.contains(address)) { publisher.publishEvent(new BlockedListEvent(this, address, content)); return; } // send email... } }在Spring容器的配置期间，检测到EmailService实现了ApplicationEventPublisherAware接口，会自动调用setApplicationEventPublisher()方法，Spring会自动填充其参数，所以我们可以通过ApplicationEventPublisher与Spring容器交互。为了能监听ApplicationEvent事件，需要实现ApplicationListener并将其注册为Spring bean：public class BlockedListNotifier implements ApplicationListener&lt;BlockedListEvent> { private String notificationAddress; public void setNotificationAddress(String notificationAddress) { this.notificationAddress = notificationAddress; } public void onApplicationEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress... } }ApplicationListener带有范型，意味着onApplicationEvent()方法不需要我们进行强转，我们可以注册许多监听器，但是默认情况下监听器是同步接受事件的，也就是说 publishEvent() 在直到所有监听器被执行完之前是一只阻塞的，好处就是能在同一线程中执行，并且如果存在事务环境，也能保持一致。如果需要使用其他策略，考虑 ApplicationEventMulticaster以及实现类 SimpleApplicationEventMulticaster注册以上的bean进行使用：&lt;bean id=\"emailService\" class=\"example.EmailService\"> &lt;property name=\"blockedList\"> &lt;list> &lt;value>known.spammer@example.org&lt;/value> &lt;value>known.hacker@example.org&lt;/value> &lt;value>john.doe@example.org&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;bean id=\"blockedListNotifier\" class=\"example.BlockedListNotifier\"> &lt;property name=\"notificationAddress\" value=\"blockedlist@example.org\"/> &lt;/bean>当emailService的 sendEmail() 被调用时，如果有黑名单中的邮件，则会发布BlockedListEvent，blockedListNotifier就会被通知spring的事件机制的设计是被用来处理同一个ApllicationContext中的Bean进行交互的，如果需要更加复杂的交互能力需要使用Spring Integration ，能够构建轻量级、基于事件驱动的应用基于注解的事件监听Spring 4.2之后能够在任何Bean中的public方法上加上@EventListener注解完成事件监听，blockedListNotifier重新实现：public class BlockedListNotifier { private String notificationAddress; public void setNotificationAddress(String notificationAddress) { this.notificationAddress = notificationAddress; } @EventListener public void processBlockedListEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress... } }如果方法需要监听多个事件，并且想使用无参方法，也可以将事件声明到注解中：@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class}) public void handleContextStart() { // ... }还能够使用注解的condition属性进行事件过滤，并且是使用 SpEL expression （Spring表达式）条件配置：@EventListener(condition = \"#blEvent.content == 'my-event'\") // 只有当BlockedListEvent事件中的content属性为my-event时才进行调用 public void processBlockedListEvent(BlockedListEvent blockedListEvent) { // notify appropriate parties via notificationAddress... }事件上下文环境可用的元数据信息：NameLocationDescriptionExampleEventroot objectThe actual ApplicationEvent.#root.event or eventArguments arrayroot objectThe arguments (as an object array) used to invoke the method.#root.args or args; args[0] to access the first argument, etc.Argument nameevaluation contextThe name of any of the method arguments. If, for some reason, the names are not available (for example, because there is no debug information in the compiled byte code), individual arguments are also available using the #a&lt;#arg&gt; syntax where &lt;#arg&gt; stands for the argument index (starting from 0).#blEvent or #a0 (you can also use #p0 or #p&lt;#arg&gt; parameter notation as an alias)#root.event能获取到底层的事件，即使监听方法签名参数接收的是自定义事件。在处理完一个事件后，如果需要继续发布事件，只需要修改方法返回值即可：@EventListener public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress and // then publish a ListUpdateEvent... }但是此用法不支持异步调用监听器这个方法在美处理完一个BlockedListEvent事件后发布ListUpdateEvent事件，如果需要发布多个事件可以返回事件的Collection。异步监听器只需在监听方法上加 @Async 注解就能 完成异步监听：@EventListener @Async public void processBlockedListEvent(BlockedListEvent event) { // BlockedListEvent is processed in a separate thread }使用异步监听器的局限性：如果异步监听器抛出异常，并不会被传递到调用者，详情参考AsyncUncaughtExceptionHandler异步监听器方法不支持上述发布连续的事件，如果需要进行发布连续事件，需要注入 ApplicationEventPublisher 进行手动发布监听器的执行顺序添加@Order注解进行顺序编排：@EventListener @Order(42) public void processBlockedListEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress... }通用事件在某些情况下，如果所有事件都遵循相同的结构，这可能会变得很通用性（就像前面示例中的事件一样）。 在这种情况下，可以实现ResolvableTypeProvider来指导框架获取运行时类型：public class EntityCreatedEvent&lt;T> extends ApplicationEvent implements ResolvableTypeProvider { public EntityCreatedEvent(T entity) { super(entity); } @Override public ResolvableType getResolvableType() { return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource())); } }使用 EntityCreatedEvent&lt;T&gt; 构造通用的事件，其中T是实际的事件实体，比如：只接收EntityCreatedEvent事件的监听器：@EventListener public void onPersonCreated(EntityCreatedEvent&lt;Person> event) { // ... }这不光对ApplicationEvent有效，而且可以是任意事件对象便捷的资源获取方式Spring将应用资源抽象为Resource接口以及通过ResourceLoader接口进行加载得到。并且ApplicationContext实现了ResourceLoader接口，Resource抽象相当于是增强版的 JDK java.net.URL 类，实际上，Resource的实现包装了java.net.URL的实例，Resource获取几乎任意位置的资源，包括类路径，文件系统，以及使用标准URL描述的资源。可以通过实现ResourceLoaderAware接口，并注入到容器中，在初始化时期就能被回掉，获取到ResourceLoader实例（通常就是ApplicationContext）ApplicationContext的构造器通过接收资源的地址字符串，其需要依赖具体的上下文环境进行加载，比如，ClassPathXmlApplicationContext将其识别为类路径下，也可以使用特定的前缀进行指定，强制其加载为类路径或URL，而不管是什么具体的上下环境。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"ioc 容器","slug":"ioc-容器","date":"2020-08-19T04:39:08.000Z","updated":"2020-08-20T05:06:01.976Z","comments":true,"path":"2020/08/19/ioc-rong-qi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/ioc-rong-qi/","excerpt":"","text":"介绍IoC容器​ IoC容器也被称为依赖注入（DI，dependency injection）。这就是一个过程，在这个过程中，对象通过构造器参数、工厂方法参数或者是工厂方法返回后的对象上的属性来定义依赖项。IoC容器会在创建这些bean的时候注入这些依赖，这个过程完全是交由容器处理（正如其名：控制反转）。​ org.springframework.beans 和 org.springframework.context 包下的类是IoC 容器的基础。 BeanFactory 提供了管理任何类型对象的高级配置机制。 ApplicationContext 是 BeanFactory的子接口，它添加了以下功能：集成Spring AOP特性国际化（i18n）事件发布（ApllicationEvent）应用级容器，例如： WebApplicationContext 构建web应用总而言之，BeanFactory提供了配置框架和基本功能，ApllicationContext则提供了更多企业级的功能。ApllicationContext完全是扩展自BeanFactory （子集关系）。在spring中，被springIoC容器所管理的、组成应用的对象就叫Spring Bean，一个Bean会被Spring IoC容器所实例化、收集和管理。除此之外，bean只是我们应用容器中许多对象的其中之一。Bean之间的依赖关系通过容器中的配置元数据（BeanDefinition）进行展示。容器概览org.springframework.context.ApplicationContext 接口呈现了IoC容器并且负责实例化、配置、收集Bean。容器会通过读取配置元数据来进行实例化、配置和收集Bean。配置元数据可以通过XML、Java注解、Java代码来定义。通过定义可以让我们表示组成应用的对象信息以及对象之间的内部依赖关系。Sprin提供了ApllicationContext的许多实现类，在标准的独立应用中，创建 ClassPathXmlApplicationContext 或者 FileSystemXmlApplicationContext 是常见的选择。尽管XML是定义配置元数据的传统格式，但是我们可以通过提供少量XML配置来声明式地启用对这些其他配置元数据格式的支持，从而指示容器将Java注释或代码用作元数据格式。在大多数应用场景下，不需要用户显式的创建一个或多个Spring IoC容器。下图展示了spring是如何工作的，我们的应用Java类和配置元数据被整合在一起，在创建完ApllicationContext后，将会得到一个完全可配置并且可执行的系统或应用程序。配置元数据像上图所展示的，Spring IoC容器会使用一系列配置元数据，配置元数据能让开发者定义Spring容器如何实例化、配置、收集应用程序中的对象。配置元数据支持以XML格式定义，但是当今许多开发者选择使用基于Java的配置方式。使用其他形式配置：基于注解配置: Spring 2.5 支持基于注解配置基于Java配置: Spring 3.0开始,SpringJava配置项目提供的新特性被加入到Spring的核心框架中。这样就不仅可以使用XML配置还能使用新特性： @Configuration, @Bean, @Import, @DependsOn 注解Spring配置必须又至少管理了一个Bean定义的容器组成。XML通常使用标签定义，而Java配置则通常使用@Bean注解被@configuration类的方法上来定义这些bean定义对应的真实对象组成了应用程序，通常来说，我们定义的服务层、DAO、表述层对象，应用基础对象。通常，不会在容器中配置细粒度的域对象，因为DAO和业务逻辑通常负责创建和加载域对象。如果要配置IoC容器之外的对象可以使用Spring Aspectj整合&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"...\" class=\"...\"> &lt;!-- collaborators and configuration for this bean go here --> &lt;/bean> &lt;bean id=\"...\" class=\"...\"> &lt;!-- collaborators and configuration for this bean go here --> &lt;/bean> &lt;!-- more bean definitions go here --> &lt;/beans>id是Bean定义的唯一标识class定义了bean的类型，使用全类名实例化一个IoC容器ApplicationContext可以从多种外部资源进行加载，比如：本地文件系统，Java类路径等等。public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); }组合XML配置分多个XML文件配置Bean definition是十分有用的，每个XML都可以独立呈现应用程序的逻辑或者模块可以使用application context的接受多个Resource参数的方法来加载多个XML定义，也可以使用标签来加载其他XML文件：&lt;beans> &lt;import resource=\"services.xml\"/> &lt;import resource=\"resources/messageSource.xml\"/> &lt;import resource=\"/resources/themeSource.xml\"/> &lt;bean id=\"bean1\" class=\"...\"/> &lt;bean id=\"bean2\" class=\"...\"/> &lt;/beans>以上配置加载了三个文件：services.xml, messageSource.xml, themeSource.xml。services.xml地址都是相对路径，所以services.xml文件必须在同一个目录下活类路径下，而 messageSource.xml 和 themeSource.xml 必须在resources目录下。能发下的是：地址开头的“/”已经被忽略了，所以鉴于这些路径是相对路径，最好不要使用斜线开头。TIPS：虽然能使用“../”来获取上级目录但是并不是被推荐的方式，这样做会依赖应用外部的文件，更不建议在类路径中使用：比如classpath:../services.xml,如果类路径配置改变将会导致不同的，不正确的目录。也可以使用绝对路径而不是相对路径file:C:/config/services.xml或者 classpath:/config/services.xml但是要注意到应用程序已经耦合了文件系统绝对路径，通常使用绝对路径更好的做法是使用占位符，通过在运行时针对JVM系统属性解析的“ $ {…}”占位符。使用容器ApplicationContext 是一个管理不同bean注册以及它们的依赖的高级工厂接口类，通过使用T getBean(String name, Class&lt;T&gt; requiredType)可以得到想要的实例。ApplicationContext能够让开发者读取bean定义的信息，并访问它们：// create and configure beans ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); // retrieve configured instance PetStoreService service = context.getBean(\"petStore\", PetStoreService.class); // use configured instance List&lt;String> userList = service.getUsernameList();我们可以使用getBean来获取bean，ApplicationContext还有许多获取bean的方法，但是我们的业务代码最好不要使用它们，这样就不会依赖spring的api。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"spring bean","slug":"spring-bean","date":"2020-08-19T03:11:21.000Z","updated":"2020-08-19T14:40:33.307Z","comments":true,"path":"2020/08/19/spring-bean/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/spring-bean/","excerpt":"","text":"Spring BeanSpring容器管理了一个或者多个bean，这些bean是更具bean定义元数据进行创建的。在Spring容器内部，bean定义元数据以BeanDefinition对象呈现，包含以下信息：类的全类名定义bean在容器中的行为的配置元素，比如：bean作用域、生命周期回掉方法等被当前bean所引用的bean其他配置-比如：连接池的大小这些元数据会翻译为一系列属性组成BeanDefinition：属性官方说明链接ClassInstantiating BeansNameNaming BeansScopeBean ScopesConstructor argumentsDependency InjectionPropertiesDependency InjectionAutowiring modeAutowiring CollaboratorsLazy initialization modeLazy-initialized BeansInitialization methodInitialization CallbacksDestruction methodDestruction CallbacksBeanDefinition包含了如何准确创建一个bean的信息，ApplicationContext也允许用户注册在容器外部创建的对象。可以通过getBeanFactory()来获取ApplicationContext内部聚合的BeanFactory来做到，其返回BeanFactory实现类为DefaultListableBeanFactory，DefaultListableBeanFactory支持通过registerSingleton(..)和registerBeanDefinition(..)方法进行注册TIPS： 为了能让Spring容器在自动装盘时正确的理解bean的意图，Bean元数据和手动注册的单实例对象应该被尽可能早地执行。虽然在某种程度上支持覆盖现有Bean元数据和现有单例实例，但是在运行时（与对工厂的实时访问同时）对新bean的注册不被Spring支持，并且可能导致并发访问异常，bean容器中的状态不一致。bean的命名任何一个bean都有一个或多个标识符，这些标识符在持有这些bean的容器中必须唯一，通常一个bean只有一个标识符，如果要求有多个，可以考虑起别名。使用XML进行配置时，我们使用id和name属性进行指定bean的标识符，id能指定唯一的标识，这些都是由字母数字组成的(‘myBean’, ‘someService’等)，也能包含特殊的字符，如果需要起一些别名，则使用name属性进行定义，使用逗号，分号或空格进行分隔。但id必须唯一。如果没有指定id和name，容器会为bean自动生成一个唯一的标识符。bean命名惯例：bean的名称默认使用首单词的首字母小写，其余的单词首字母都是大写，比如：accountManager,accountService,userDao,loginController等。bean的命名能够使得应用的配置更加简单和易读，如果使用Spring Aop，能够更方便的通过bean的名称进行的切面定义。TIPS:通过在类路径中进行组件扫描，Spring会按照前面描述的规则为未命名的组件生成Bean名称：从本质上讲，将采用简单的类名称并将其首字符转换为小写。 但是，在（不寻常的）特殊情况下，如果有多个字符且第一个和第二个字符均为大写字母，则会保留原始大小写。在BeanDefinition之外给bean取别名我们可以通过BeanDefinition给bean定义一个或多个名称，通过id属性定义唯一标识符和name属性定义多个别名。但是，在实际定义bean的地方指定所有别名并不能满足需求。 有时需要为在别处定义的bean引入别名。 在大型系统中通常是这种情况，在大型系统中，配置在每个子系统之间分配，每个子系统都有自己的对象定义集。&lt;alias name=\"fromName\" alias=\"toName\"/> 使用XML的标签进行起别名给fromName的bean起一个toName的别名。比如：A系统通过subsystemA-dataSource来引用一个Datasource对象，B系统通过subsystemB-dataSource来引用DataSource对象，当组合这2个子系统为一个系统时，主应用使用myApp-dataSource来进行引用，这种情况可以使用以下配置：&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt; &lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;实例化bean一个beanDefinition可以创建一个或多个对象，容器在被查询时会查看命名bean的定义，并使用该bean定义封装的配置元数据来创建（或获取）实际对象。如果使用XML定义Bean元数据，通常需要指定标签中的class属性class属性对应BeanDefinition中的Class字段。Class字段有2种用法:通常，在容器本身通过反射机制调用其构造函数直接创建Bean的情况下，指定要构造的Bean类型，这在某种程度上等同于使用new运算符的Java代码。要指定包含用于创建对象的静态工厂方法的实际类，在不太常见的情况下，容器将在类上调用静态工厂方法以创建Bean。 从静态工厂方法的调用返回的对象类型可以是同一类，也可以是完全不同的另一类。内部类：如果需要配置类的内部静态类的bean定义，必须要使用类的组合名称，比如：在 com.example 包下有一个叫SomeThing的类，在其内部有一个叫OtherThing的内部静态类，则其beanDefinition的class属性将会是com.example.SomeThing$OtherThing,$被用来作为内部类和外部类的分隔。使用构造器初始化当通过构造方法创建一个bean时，所有普通类都可以被Spring使用并兼容。 也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。 只需指定bean类就足够了。 但是，根据用于该特定bean的IoC类型，可能需要一个默认（空）构造函数。Spring IoC容器几乎可以管理任何类。 它不仅限于管理真正的JavaBean。 大多数Spring用户更喜欢实际的JavaBean，它们仅具有默认（无参数）构造函数，并具有根据容器中的属性建模的适当的setter和getter。 还可以在容器中包含更多奇特的非bean样式类。 例如，如果需要使用绝对不符合JavaBean规范的旧式连接池，则Spring也可以对其进行管理。&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"/> &lt;bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/>使用静态工厂方法进行实例化可以使用class属性来指定包含静态工厂方法的的类，使用factory-method属性来指定工厂方法的名字。&lt;bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/> public class ClientService { private static ClientService clientService = new ClientService(); private ClientService() {} public static ClientService createInstance() { return clientService; } }使用实例工厂方法使用已存在的bean的非静态工厂方法创建新的bean：&lt;!-- the factory bean, which contains a method called createInstance() --> &lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"> &lt;!-- inject any dependencies required by this locator bean --> &lt;/bean> &lt;!-- the bean to be created via the factory bean --> &lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/>public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } }工厂类也能拥有多个工厂方法：&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"> &lt;!-- inject any dependencies required by this locator bean --> &lt;/bean> &lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/> &lt;bean id=\"accountService\" factory-bean=\"serviceLocator\" factory-method=\"createAccountServiceInstance\"/>public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } public AccountService createAccountServiceInstance() { return accountService; } }这种方式说明工厂bean本省可以被容器管理和通过DI配置。决定bean的运行时类型确定特定bean的运行时类型并非易事。 Bean元数据定义中的指定类只是初始类引用，可能与声明的工厂方法结合使用，或者是FactoryBean类，这可能导致Bean的运行时类型不同，或者在实例的情况下根本不进行设置 工厂方法（通过指定的factory-bean名称解析）。 此外，AOP代理可以使用基于接口的代理包装Bean实例，而目标Bean的实际类型（仅是其实现的接口）的暴露程度有限。建议使用BeanFactory.getType获取运行时bean的类型。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"k3s中使用configmap灵活配置","slug":"k3s中使用configmap灵活配置","date":"2019-12-07T09:15:39.000Z","updated":"2020-08-19T14:30:16.067Z","comments":true,"path":"2019/12/07/k3s-zhong-shi-yong-configmap-ling-huo-pei-zhi/","link":"","permalink":"https://ubisoft-potato.github.io/2019/12/07/k3s-zhong-shi-yong-configmap-ling-huo-pei-zhi/","excerpt":"使用configmap前所遇到的问题在微服务横行的时代，一个系统被拆分成多个子系统，使得每个子系统各自有一套自己管理的配置， 使得配置管理难度加大，springcloud的解决方案是spring config，可以通过github等集中托管各服务配置， 集群化部署有比spring config更简单的解决方案：k8s configmap","text":"使用configmap前所遇到的问题在微服务横行的时代，一个系统被拆分成多个子系统，使得每个子系统各自有一套自己管理的配置， 使得配置管理难度加大，springcloud的解决方案是spring config，可以通过github等集中托管各服务配置， 集群化部署有比spring config更简单的解决方案：k8s configmap什么是configmapConfigMap 是k8s集群中的一种资源类型，并且ConfigMap会将配置数据作为k-v键值对存储，存储的数据可以被集群中的pod消费。通过configMap我们可以将springboot的配置文件集中管理在一个k8s名称空间下，这样就可以统一管理所有容器配置创建configMap使用kubectl命令创建:kubectl create configmap &lt;map-name&gt; &lt;data-source&gt; -n &lt;namespace&gt;其中可以是存放配置文件的目录或者就是配置文件，是创建的configMap的名字, &lt; namespace &gt;为指定的名称空间名。例子：# 创建本地目录 mkdir -p /config # 下载事例配置 wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties kubectl create configmap testConfigMap --from-file=/config/ -n dev上述命令为使用/config 目录下的所有配置文件在dev名称空间创建名为 testConfigMap的configMap资源查看创建完的configmap:kubectl describe configmap testConfigMap -n dev kubectl get configmap testConfigMap -o yaml -n dev查看dev名称空间下名叫testConfigMap的configMap，如果按照上述操作，结果应该如下：Name: game-config Namespace: dev Labels: &lt;none&gt; Annotations: &lt;none&gt; Data ==== game.properties: 158 bytes ui.properties: 83 bytes使用第二条命令则更详细：apiVersion: v1 kind: ConfigMap metadata: creationTimestamp: 2016-02-18T18:52:05Z name: game-config namespace: dev resourceVersion: \"516\" uid: b4952dc3-d670-11e5-8cd0-68f728db1985 data: game.properties: | enemies=aliens lives=3 enemies.cheat=true enemies.cheat.level=noGoodRotten secret.code.passphrase=UUDDLRLRBABAS secret.code.allowed=true secret.code.lives=30 ui.properties: | color.good=purple color.bad=yellow allow.textmode=true how.nice.to.look=fairlyNice通过上述操作可以发现，使用命令创建后，configmap中的key即为配置文件的名字，所以使用起来也非常方便创建configMap还可以通过yaml配置文件的方式创建，不再详细说明，通过文件方式更为通用configMap的应用创建好configMap就要使用到实际应用中，pod可以直接使用集群中的configMap资源，通常来说有2种应用：1、作为pod中的环境变量导入 2、作为pod中的loume挂载，将configMap的key对应的数据变成文件挂载到pod中的指定位置要集中管理springboot配置文件，使用第2种营业员方式：创建configMap，其中有2个配置文件 apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm --- 将配置文件挂载到pod的/etc/config 目录下 apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config/&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: # Provide the name of the ConfigMap containing the files you want # to add to the container name: special-config restartPolicy: Never当pod创建并启动后，会输出如下结果：SPECIAL_LEVEL SPECIAL_TYPE说明configMap中的key作为了文件名，值作为文件内容。注意：这种挂载方式会清空 pod中/etc/config目录下原有的所有文件，再将配置文件挂载进去， 如果不想原来的配置被删除可以使用subPath的挂载方式，修改如下：apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config/&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config/SPECIAL_LEVEL subPath: SPECIAL_LEVEL volumes: - name: config-volume configMap: name: special-config items: - key: SPECIAL_LEVEL path: SPECIAL_LEVEL restartPolicy: Never通过subPath的挂载方式，原来pod目录里的文件就不会被删除","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"configmap","slug":"configmap","permalink":"https://ubisoft-potato.github.io/tags/configmap/"}]},{"title":"k3s配置ingress使用ssl证书","slug":"k3s配置ingress使用ssl证书","date":"2019-11-03T06:39:03.000Z","updated":"2020-08-19T06:58:43.367Z","comments":true,"path":"2019/11/03/k3s-pei-zhi-ingress-shi-yong-ssl-zheng-shu/","link":"","permalink":"https://ubisoft-potato.github.io/2019/11/03/k3s-pei-zhi-ingress-shi-yong-ssl-zheng-shu/","excerpt":"What is Ingress?Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. internet | [ Ingress ] --|-----|-- [ Services ] Ingress暴露了从集群外部到集群内服务的HTTP和HTTPS路由。流量路由由Ingress资源上定义的规则控制。 可以将Ingress配置为提供服务外部可访问的URL，负载平衡流量，并提供基于SSL / TLS的虚拟主机。 入口控制器通常通过负载平衡器负责实现入口，尽管它也可以配置边缘路由器或其他前端以帮助处理流量。","text":"What is Ingress?Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. internet | [ Ingress ] --|-----|-- [ Services ] Ingress暴露了从集群外部到集群内服务的HTTP和HTTPS路由。流量路由由Ingress资源上定义的规则控制。 可以将Ingress配置为提供服务外部可访问的URL，负载平衡流量，并提供基于SSL / TLS的虚拟主机。 入口控制器通常通过负载平衡器负责实现入口，尽管它也可以配置边缘路由器或其他前端以帮助处理流量。说白了ingress的功能就是类是于反向代理，能够做到像nginx一样的反代的功能，控制流量，并有负载均衡的能力，本文主要讨论如何在k3s集群中配置https证书注意：k3s集群默认使用traefik来实现反向代理，但也支持使用nginx来作为 ingress controller 来实现反向代理配置http ingresskind: Ingress apiVersion: networking.k8s.io/v1beta1 metadata: name: test-ingress annotations: kubernetes.io/ingress.class: traefik traefik.frontend.rule.type: PathPrefixStrip spec: rules: # 这里可以配置多个域名代理规则 - host: xxx # 域名 http: paths: - backend: serviceName: service-01 servicePort: 8080 - host: xxx # 域名 http: paths: - backend: serviceName: service-02 servicePort: 8080执行: kubectl apply -f ingress.yaml ,创建ingress。 [root@hostname ~]# kubectl get ingress NAME HOSTS ADDRESS PORTS AGE test-ingress xxxxx,xxxx 172.17.19.115 80 6h15m 可以看到 端口为80，说明ingress已经为指定的service做好http代理为ingress配置https首先配置k3s secretapiVersion: v1 kind: Secret metadata: name: testsecret-tls namespace: default data: tls.crt: base64 encoded cert #此处必须为base64 加密后的证书 可使用 cat xxx.pem | base64 命令得到 tls.key: base64 encoded key #此处必须为base64 加密后的密钥 可使用 cat xxx.key | base64 命令得到 type: kubernetes.io/tlskind: Ingress apiVersion: networking.k8s.io/v1beta1 metadata: name: test-ingress namespace: default # ingress要和secret在同一个名称空间下 annotations: kubernetes.io/ingress.class: traefik traefik.frontend.rule.type: PathPrefixStrip # http 重定向到 https ingress.kubernetes.io/ssl-redirect: \"True\" spec: tls: - hosts: - xxxx.xxxx # 这里是下面要配置https的域名 - xxxx.xxxx # 这里是下面要配置https的域名 secretName: testsecret-tls rules: # 这里可以配置多个域名代理规则 - host: xxx # 域名 http: paths: - backend: serviceName: service-01 servicePort: 8080 - host: xxx # 域名 http: paths: - backend: serviceName: service-02 servicePort: 8080先后执行： kubectl apply -f secret.yaml kubectl apply -f ingress.yaml ----------------------------------------------------- 查看 secret : kubectl get secret [root@hostname ~]# kubectl get secret NAME TYPE DATA AGE default-token-d25kq kubernetes.io/service-account-token 3 10h testsecret-tls kubernetes.io/tls 2 7h25m 第二行为我们所创建的证书的secret对象 ------------------------------------------------------ 查看ingress: kubectl get ingress [root@hostname ~]# kubectl get ingress NAME HOSTS ADDRESS PORTS AGE test-ingress xxx.xxx,xxx.xxx 172.17.19.115 80, 443 7h26m 可以看到 端口已经添加了443如果操作无误，这时访问我们的域名已经是变成了https，并且访问http也会被重定向到https","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"ingress","slug":"ingress","permalink":"https://ubisoft-potato.github.io/tags/ingress/"},{"name":"ssl","slug":"ssl","permalink":"https://ubisoft-potato.github.io/tags/ssl/"}]},{"title":"docker入门","slug":"docker入门","date":"2019-11-01T13:44:27.000Z","updated":"2020-08-19T02:46:13.235Z","comments":true,"path":"2019/11/01/docker-ru-men/","link":"","permalink":"https://ubisoft-potato.github.io/2019/11/01/docker-ru-men/","excerpt":"什么是docker？Docker is a set of platform-as-a-service products that use OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. --wikiDocker是一组平台即服务产品，它们使用操作系统级虚拟化并被称为容器的软件包交付软件。 容器彼此隔离，并将它们自己的软件，库和配置文件捆绑在一起； 他们可以通过定义明确的渠道相互通信。","text":"什么是docker？Docker is a set of platform-as-a-service products that use OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. --wikiDocker是一组平台即服务产品，它们使用操作系统级虚拟化并被称为容器的软件包交付软件。 容器彼此隔离，并将它们自己的软件，库和配置文件捆绑在一起； 他们可以通过定义明确的渠道相互通信。docker基本概念容器–什么是容器What is a Container? A standardized unit of software容器是标准的软件单元（可独立运行的） ，传统的软件部署方式，需要将软件打包，并在部署之前，要在操作系统上安装相关依赖，这样的部署方式使得软件的耦合度太高，并且不宜维护，而通过容器，可以将软件打包到标准化单元中，以进行开发，运输和部署，极大降低软件部署的耦合度。Why Docker?作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。docker 容器 vs 虚拟机 容器是应用程序层的抽象，将代码和依赖项打包在一起。 多个容器可以在同一台计算机上运行，​​并与其他容器共享OS内核，每个容器在用户空间中作为隔离的进程运行。 容器占用的空间少于VM（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要的VM和操作系统更少。虚拟机（VM）是将一台服务器转变为多台服务器的物理硬件的抽象。 虚拟机管理程序允许多个VM在单台计算机上运行。 每个VM包含操作系统，应用程序，必要的二进制文件和库的完整副本-占用数十GB。 VM也可能启动缓慢。基本概念Docker 包括三个基本概念镜像（Image）容器（Container）仓库（Repository）镜像Docker 镜像（Image）就是一个只读的模板。 例如：一个镜像可以包含一个完整的 Ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。 镜像可以用来创建 Docker 容器。 Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。容器Docker 利用容器（Container）来运行应用。 容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。仓库仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。 实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括时速云 、网易云等，可以提供大陆用户更稳定快速的访问。 当然，用户也可以在本地网络内创建一个私有仓库（参考本文“私有仓库”部分）。 当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库， 这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。 注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"docker基本概念","slug":"docker基本概念","permalink":"https://ubisoft-potato.github.io/tags/docker基本概念/"}]},{"title":"rancher、k3s安装记录","slug":"rancher、k3s安装记录","date":"2019-10-09T06:02:43.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/10/09/rancher-k3s-an-zhuang-ji-lu/","link":"","permalink":"https://ubisoft-potato.github.io/2019/10/09/rancher-k3s-an-zhuang-ji-lu/","excerpt":"k3s 简介k3s 是 Rancher 推出的轻量级 k8s。k3s 本身包含了 k8s 的源码，所以本质上和 k8s 没有区别。但为了降低资源占用，k3s 和 k8s 还是有一些区别的，主要是：使用了相比 Docker 更轻量的 containerd 作为容器运行时（Docker 并不是唯一的容器选择）去掉了 k8s 的 Legacy, alpha, non-default features用 sqlite3 作为默认的存储，而不是 etcd其他的一些优化，最终 k3s 只是一个 binary 文件，非常易于部署所以 k3s 适用于边缘计算，IoT 等资源紧张的场景。同时 k3s 也是非常容易部署的，官网上提供了一键部署的脚本。","text":"k3s 简介k3s 是 Rancher 推出的轻量级 k8s。k3s 本身包含了 k8s 的源码，所以本质上和 k8s 没有区别。但为了降低资源占用，k3s 和 k8s 还是有一些区别的，主要是：使用了相比 Docker 更轻量的 containerd 作为容器运行时（Docker 并不是唯一的容器选择）去掉了 k8s 的 Legacy, alpha, non-default features用 sqlite3 作为默认的存储，而不是 etcd其他的一些优化，最终 k3s 只是一个 binary 文件，非常易于部署所以 k3s 适用于边缘计算，IoT 等资源紧张的场景。同时 k3s 也是非常容易部署的，官网上提供了一键部署的脚本。下载可执行k3s 安装脚本、二进制文件 和 镜像mkdir k3s-install cd k3s-install curl -sfL https://get.k3s.io &gt; install.sh chmod +x ./install.sh wget https://github.com/rancher/k3s/releases/download/${k3s.version}/k3s wget https://github.com/rancher/k3s/releases/download/${k3s.version}/k3s-airgap-images-amd64.tar安装k3s主服务器cp ./k3s /usr/local/bin/ chmod +x /usr/local/bin/k3s mkdir -p /var/lib/rancher/k3s/agent/images/ cp ./k3s-airgap-images-amd64.tar /var/lib/rancher/k3s/agent/images/ INSTALL_K3S_SKIP_START=true INSTALL_K3S_EXEC=\"--docker\" INSTALL_K3S_BIN_DIR=\"/usr/local/bin\" INSTALL_K3S_SKIP_DOWNLOAD=true sh install.sh ln -s /usr/local/bin/k3s /usr/bin/k3s systemctl enable k3s systemctl start k3s 修改配置文件 /etc/systemd/system/k3s.service 将其中的ExecStart修改为使用dockerExecStart=/usr/local/bin/k3s server --docker运行命令，查看状态kubectl get node NAME STATUS ROLES AGE VERSION hostname Ready master 110s v1.14.5-k3s.1安装agent cp ./k3s /usr/local/bin/ chmod +x /usr/local/bin/k3s mkdir -p /var/lib/rancher/k3s/agent/images/ cp ./k3s-airgap-images-amd64.tar /var/lib/rancher/k3s/agent/images/ INSTALL_K3S_SKIP_START=true INSTALL_K3S_EXEC=\"--docker\" INSTALL_K3S_BIN_DIR=\"/usr/local/bin\" INSTALL_K3S_SKIP_DOWNLOAD=true K3S_TOKEN=XXXXX K3S_URL=https://XXXXX:6443 sh install.sh ln -s /usr/local/bin/k3s /usr/bin/k3s systemctl enable k3s-agent systemctl start k3s-agent token需要从主服务器的 /var/lib/rancher/k3s/server/node-token 获取安装控制台创建目录 /data/k3s/rancher-server/var/lib/rancherdocker run -d -v /data/k3s/rancher-server/var/lib/rancher/:/var/lib/rancher/ --restart=unless-stopped --name rancher-server -p 38080:80 -p 38443:443 rancher/rancher:stable","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"rancher","slug":"rancher","permalink":"https://ubisoft-potato.github.io/tags/rancher/"}]},{"title":"使用docker部署文件服务ambry","slug":"使用docker部署文件服务ambry","date":"2019-10-08T13:17:30.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/10/08/shi-yong-docker-bu-shu-wen-jian-fu-wu-ambry/","link":"","permalink":"https://ubisoft-potato.github.io/2019/10/08/shi-yong-docker-bu-shu-wen-jian-fu-wu-ambry/","excerpt":"分布式文件服务ambry分布式文件服务ambry是国外著名社交软件公司 linkedin 的开源项目，ambry官网地址:https://github.com/linkedin/ambry, 可以自行查看github介绍","text":"分布式文件服务ambry分布式文件服务ambry是国外著名社交软件公司 linkedin 的开源项目，ambry官网地址:https://github.com/linkedin/ambry, 可以自行查看github介绍如何使用docker容器化部署ambryambry官方并没有相关镜像，所以自己制作ambry镜像进行部署,下面进行介绍:ambry分为服务段和前端，所以制作了2个镜像, 镜像dockerHub地址：https://hub.docker.com/r/wdnmdcyka/ambry-client, https://hub.docker.com/r/wdnmdcyka/ambry-server[root@izwz94ymqw967redc0vyeoz ~]# docker search ambry NAME DESCRIPTION STARS OFFICIAL AUTOMATED amimimor/ambry Ambry Docker Image 0 civicknowledge/ambry Public data ETL framework 0 [OK] sandinh/ambry dockerize for linkedin [ambry] 0 [OK] sivabalan/ambry Adding docker support for ambry 0 [OK] sivabalan/ambryfe Ambry FE using in memory router factory 0 [OK] sandinh/ambry-import-xenforo import xenforo avatars, attachments to ambry 0 maciejbak85/ambry Distributed object store https://github.com 0 civicknowledge/ambry-base 0 gnkr8/ambry 0 ktimothy/ambry 0 wdnmdcyka/ambry-server linkedin/ambry server image 0 wdnmdcyka/ambry-client linkedin/ambry fronted image 0 需要下载 wdnmdcyka/ambry-server、wdnmdcyka/ambry-client[root@izwz94ymqw967redc0vyeoz ~]# docker pull wdnmdcyka/ambry-server:1.0 [root@izwz94ymqw967redc0vyeoz ~]# docker pull wdnmdcyka/ambry-client:1.0部署方式按照官网传统部署方式，需要部署ambry的服务端和ambry的前端，前端不负责存储，所有的文件都是在服务端存储，前端只是负责转发请求和组织服务端存储首先部署ambry-server: docker run -d -v ${your config dir}:/app/config -v ${your tmp dir}:/tmp -v ${your logs dir}:/app/logs -p 6667:6667 -p 16503:16503 --restart always --name ambry-server wdnmdcyka/ambry-server:tagname说明：其中挂载出来的目录有ambry的配置文件目录，/tmp为服务端存储文件的目录，/app/logs为ambry生成日志存储的目录暴露的端口6667为server和client通信的端口部署ambry-client：docker run -d -v ${your config dir}:/app/config -v ${your logs dir}:/app/logs -p 1174:1174 --restart always --name ambry-client wdnmdcyka/ambry-client:tagname说明：由于client端不负责存储，所以没有挂载/tmp目录，1174端口是ambry暴露的rest接口所使用的端口配置文件获取地址：https://github.com/linkedin/ambry/tree/master/config测试如果配置无误，直接请求 http://localhost:1174/healthCheck ，如果返回 GOOD 则部署成功!","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://ubisoft-potato.github.io/tags/文件上传/"},{"name":"分布式文件服务","slug":"分布式文件服务","permalink":"https://ubisoft-potato.github.io/tags/分布式文件服务/"}]},{"title":"springBoot统一异常处理","slug":"springBoot统一异常处理","date":"2019-09-28T12:33:00.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/28/springboot-tong-yi-yi-chang-chu-li/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/28/springboot-tong-yi-yi-chang-chu-li/","excerpt":"如何在springBoot优雅的处理异常？异常处理在任何项目中都尤为重要，所以这使得如何统一处理异常变得非常重要，本文记录在SpringBoot中解决统一异常处理最优雅的方式。","text":"如何在springBoot优雅的处理异常？异常处理在任何项目中都尤为重要，所以这使得如何统一处理异常变得非常重要，本文记录在SpringBoot中解决统一异常处理最优雅的方式。spring 3.2新增注解@ControllerAdvice package org.springframework.web.bind.annotation; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface ControllerAdvice { @AliasFor(\"basePackages\") String[] value() default {}; @AliasFor(\"value\") String[] basePackages() default {}; Class&lt;?>[] basePackageClasses() default {}; Class&lt;?>[] assignableTypes() default {}; Class&lt;? extends Annotation>[] annotations() default {}; }ControllerAdvice拆分开来就是Controller Advice，关于Advice，可以理解为AOP面向切面编程中的环绕增强，为指定范围内的controller进行相应方法的增强代理。结合方法型注解@ExceptionHandler，用于捕获Controller中抛出的指定类型的异常，从而达到不同类型的异常区别处理的目的；@ControllerAdvice的用法基本是将其声明在某个bean上，然后在该bean的方法上使用其他的注解来指定不同的织入逻辑。不过这里@ControllerAdvice并不是使用AOP的方式来织入业务逻辑的，而是Spring内置对其各个逻辑的织入方式进行了内置支持@ExceptionHandler注解@ExceptionHandler的作用主要在于声明一个或多个类型的异常,当符合条件的Controller抛出这些异常之后将会对这些异常进行捕获，然后按照其标注的方法的逻辑进行处理，从而改变返回的信息@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface ExceptionHandler { // 指定需要捕获的异常的Class类型 Class&lt;? extends Throwable>[] value() default {}; }实例说明统一异常配置类@ControllerAdvice(basePackages = \"xxx.xxx\")//指定controller所在的包 public class MyExceptionHandler { @ExceptionHandler(Exception.class)//需要处理的异常类型 @ResponseBody public Map&lt;String, String> handleException(Exception e) { HashMap&lt;String, String> errorMap = new HashMap&lt;>(); errorMap.put(\"errorMsg\", e.getMessage()); errorMap.put(\"code\", 500 + \"\"); return errorMap; } }写个简单的controller 直接抛出异常@RestController public class MyController { @GetMapping(\"/test\") public void test() { throw new ArrayIndexOutOfBoundsException(\"数组越界\"); } }访问 /test 并没有直接返回结果 而是上述返回异常处理的map{ &quot;code&quot;:500, &quot;errorMsg&quot;:&quot;数组越界&quot; }","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://ubisoft-potato.github.io/tags/异常处理/"}]},{"title":"mapstruct在SpringBoot中的使用","slug":"mapstruct在SpringBoot中的使用","date":"2019-09-26T12:54:38.000Z","updated":"2020-08-19T07:40:51.019Z","comments":true,"path":"2019/09/26/mapstruct-zai-springboot-zhong-de-shi-yong/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/26/mapstruct-zai-springboot-zhong-de-shi-yong/","excerpt":"MapStruct是什么MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach.MapStruct是一个极大简化javaBean之间互相转换的代码生成器，即简化实体类DTO的互相转化官方文档（https://mapstruct.org/documentation/stable/reference/html/#defining-mapper）","text":"MapStruct是什么MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach.MapStruct是一个极大简化javaBean之间互相转换的代码生成器，即简化实体类DTO的互相转化官方文档（https://mapstruct.org/documentation/stable/reference/html/#defining-mapper）maven依赖 &lt;properties> &lt;org.mapstruct.version>1.3.0.Final&lt;/org.mapstruct.version> &lt;/properties> &lt;dependency> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct-jdk8&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct-processor&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency>集成MapStruct官方提供了两种方式，上面配置文件内我们采用的是直接添加Maven依赖，而官方文档还提供了另外一种方式，采用Maven插件形式配置，配置如下所示： &lt;properties> &lt;org.mapstruct.version>1.3.0.Final&lt;/org.mapstruct.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.5.1&lt;/version> &lt;!-- or newer version --> &lt;configuration> &lt;source>1.8&lt;/source> &lt;!-- depending on your project --> &lt;target>1.8&lt;/target> &lt;!-- depending on your project --> &lt;annotationProcessorPaths> &lt;path> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct-processor&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;/path> &lt;!-- other annotation processors --> &lt;/annotationProcessorPaths> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build>一对一转换//实体类 public class Customer { private Long id; private String name; //getters and setter omitted for brevity } //DTO public class CustomerDto { public Long id; public String customerName; } //(org.mapstruct.Mapper) annotation @Mapper public interface CustomerMapper { CustomerMapper INSTANCE = Mappers.getMapper( CustomerMapper.class ); //相同属性不需要用@Mapping指定，如Customer和CustomerDto中的id //customerName与name不同，则必须指定 @Mapping(source = \"customerName\", target = \"name\") Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer); }可以看到CustomerMapper是一个接口的形式存在的，当然也可以是一个抽象类，如果需要在转换的时候才用个性化的定制的时候可以采用抽象类的方式，相应的代码配置官方文档已经声明。@Mapper注解是用于标注接口、抽象类是被MapStruct自动映射的标识，只有存在该注解才会将内部的接口方法自动实现。使用方式1：不需要做过多的配置内容，获取Mapper的方式就是采用Mappers通过动态工厂内部反射机制完成Mapper实现类的获取。public class MapStructTest { @Test public void directMapping() { Customer customer = new Customer(); customer.setId(12L); customer.setName(\"customer001\"); CustomerDto customerDto = CustomerConverter.INSTANCE.fromCustomer(customer); System.out.println(\"customerDto = \" + customerDto); } }使用方式2：使用springBoot依赖注入// Specifies the component model to which the generated mapper should adhere. Supported values are //指定mapper的注入模板 :cdi spring jsr330 //@mapper添加参数 componentModel = \"spring\" @Mapper(componentModel = \"spring\") public interface CustomerConverter { CustomerConverter INSTANCE = Mappers.getMapper(CustomerConverter.class); @Mapping(source = \"customerName\", target = \"name\") Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer); } public class MapStructTest { //使用autowired自动注入 @Autowired private CustomerConverter customerConverter; @Test public void directMapping() { Customer customer = new Customer(); customer.setId(12L); customer.setName(\"customer001\"); // CustomerDto customerDto = CustomerConverter.INSTANCE.fromCustomer(customer); CustomerDto customerDto = customerConverter.fromCustomer(customer); System.out.println(\"customerDto = \" + customerDto); } }结果： customerDto = CustomerDto(id=12, customerName=customer001)IDEA插件: MapStruct Support安装idea插件MapStruct Support在编写mapper时可以提示不相同的属性映射@Mapper(componentModel = \"spring\") public interface CustomerConverter { CustomerConverter INSTANCE = Mappers.getMapper(CustomerConverter.class); @Mapping(source = \"customerName\", target = \"name\") //插件可以提示source和target参数 Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer); }实体类中有List属性的转换@Data public class Student { private Integer id; private String name; private Integer age; private String sex; } @Data public class Teacher { private List&lt;Student> students; } @Data public class StudentDto { private Integer id; private String name; private Integer age; private String gender; } @Data public class TeacherDto { private List&lt;StudentDto> studentDtos; }要将teacher转换到teacherDto，按照以前的方式：把teacher中的List遍历，挨个转换成dto再手动添加到teacherDto中的list中使用mapStruct:@Mapper(componentModel = \"spring\") public interface StudentConverter { //定义student转studentDto @Mapping(target = \"gender\", source = \"sex\") StudentDto studentToDto(Student student); //List&lt;Student> 转 List&lt;StudentDto>，此方法在编译生成后会调用StudentDto studentToDto(Student student); //如果不定义StudentDto studentToDto(Student student); 此方法会报错 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); //Teacher 转 TeacherDto ，此方法调用 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); // 如果没有List&lt;StudentDto> studentToDtoList(List&lt;Student> students); 此方法报错 @Mapping(target = \"studentDtos\", source = \"students\") TeacherDto teacherToDto(Teacher teacher); }测试：public class ApplicationTests { @Autowired StudentConverter studentConverter; @Test public void contextLoads() { Student student1 = new Student(); student1.setId(1); student1.setName(\"sda\"); student1.setAge(12); student1.setSex(\"男\"); Student student2 = new Student(); student2.setId(2); student2.setName(\"asdfd\"); student2.setAge(23); student2.setSex(\"男\"); Teacher teacher = new Teacher(); teacher.setStudents(Arrays.asList(student1, student2)); TeacherDto teacherDto = studentConverter.teacherToDto(teacher); System.out.println(\"teacher = \" + teacher); System.out.println(\"teacherDto = \" + teacherDto); } }结果: teacher = Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]) teacherDto = TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男), StudentDto(id=2, name=asdfd, age=23, gender=男)])多对一这里以二对一为例:实体类: @Data public class School { private Long id; private String address; private String name; } @Data public class Student { private Integer id; private String name; private Integer age; private String sex; } @Data public class Teacher { private List&lt;Student> students; }对应Dto: @Data public class SchoolDto { private Long id; private String address; private String name; private List&lt;TeacherDto> teacherDtos; } @Data public class StudentDto { private Integer id; private String name; private Integer age; private String gender; } @Data public class TeacherDto { private List&lt;StudentDto> studentDtos; }mapper类:@Mapper(componentModel = \"spring\") public interface StudentConverter { //定义student转studentDto @Mapping(target = \"gender\", source = \"sex\") StudentDto studentToDto(Student student); //List&lt;Student> 转 List&lt;StudentDto>，此方法在编译生成后会调用StudentDto studentToDto(Student student); //如果不定义StudentDto studentToDto(Student student); 此方法会报错 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); //Teacher 转 TeacherDto ，此方法调用 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); // 如果没有List&lt;StudentDto> studentToDtoList(List&lt;Student> students); 此方法报错 @Mapping(target = \"studentDtos\", source = \"students\") TeacherDto teacherToDto(Teacher teacher); //多对一时，每个属性最好写上起对应关系，并且此方法能正确执行依赖 TeacherDto teacherToDto(Teacher teacher); //如果teacherToDto方法不存在则会报错 @Mapping(target = \"teacherDtos\", source = \"teachers\") @Mapping(target = \"name\", source = \"school.name\") @Mapping(target = \"id\", source = \"school.id\") @Mapping(target = \"address\", source = \"school.address\") SchoolDto schoolToDto(School school, List&lt;Teacher> teachers); }测试：public class EurkaApplicationTests { @Autowired StudentConverter studentConverter; @Test public void convert() { Student student1 = new Student(); student1.setId(1); student1.setName(\"sda\"); student1.setAge(12); student1.setSex(\"男\"); Student student2 = new Student(); student2.setId(2); student2.setName(\"asdfd\"); student2.setAge(23); student2.setSex(\"男\"); Teacher teacher1 = new Teacher(); teacher1.setStudents(Arrays.asList(student1, student2)); Teacher teacher2 = new Teacher(); teacher2.setStudents(Arrays.asList(student1, student2)); List&lt;Teacher> teachers = Arrays.asList(teacher1, teacher2); School school = new School(); school.setId(123L); school.setAddress(\"育碧，苏维埃\"); school.setName(\"育碧一中\"); //调用mapper转换 SchoolDto schoolDto = studentConverter.schoolToDto(school, teachers); System.out.println(\"school = \" + school); System.out.println(\"teachers = \" + teachers); System.out.println(\"schoolDto = \" + schoolDto); } }运行结果： school = School(id=123, address=育碧，苏维埃, name=育碧一中) teachers = [ Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]), Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]) ] schoolDto = SchoolDto( id=123, address=育碧， 苏维埃, name=育碧一中, teacherDtos=[ TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男),StudentDto(id=2, name=asdfd, age=23, gender=男)]), TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男), StudentDto(id=2, name=asdfd, age=23, gender=男)]) ])","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"javaBean","slug":"javaBean","permalink":"https://ubisoft-potato.github.io/tags/javaBean/"}]},{"title":"docker部署mysql5.7","slug":"docker部署mysql5-7","date":"2019-09-19T12:28:54.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/19/docker-bu-shu-mysql5-7/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/19/docker-bu-shu-mysql5-7/","excerpt":"docker部署mysql与传统方式对比1、传统方式：在linux上直接使用yum安装 或者mysql官网下载 tar.gz安装，使用tar.gz可能还要自己手动解决依赖问题，yum安装虽然解决了依赖问题，但是随着日益增多，其他数据安装，以及开发环境，难免会引起于其他开发环境的冲突2、docker容器化部署docker是基于linux容器技术发展而来，而linux容器技术能做到进程隔离，从而使得各个服务的部署独立，互不干扰，使用docker部署mysql，还可以部署在同一台服务器上部署不同版本的mysql，而互不影响，比起传统方式，既不用担心依赖，也不用担心开发环境不同而造成影响","text":"docker部署mysql与传统方式对比1、传统方式：在linux上直接使用yum安装 或者mysql官网下载 tar.gz安装，使用tar.gz可能还要自己手动解决依赖问题，yum安装虽然解决了依赖问题，但是随着日益增多，其他数据安装，以及开发环境，难免会引起于其他开发环境的冲突2、docker容器化部署docker是基于linux容器技术发展而来，而linux容器技术能做到进程隔离，从而使得各个服务的部署独立，互不干扰，使用docker部署mysql，还可以部署在同一台服务器上部署不同版本的mysql，而互不影响，比起传统方式，既不用担心依赖，也不用担心开发环境不同而造成影响docker化mysql步骤安装dockercentOS 直接使用yum install docker安装debian系列：使用 apt-get install docker拉去dockerhub mysql官方镜像docker pull mysql:5.7下载完成后 ，使用docker images 查看当前所有镜像 如下所示：REPOSITORY TAG IMAGE ID CREATED SIZE mysql 5.7 383867b75fd2 7 days ago 373MB mongo latest cdc6740b66a7 5 weeks ago 361MB可以看到 TAG 下面标着 5.7， 即mysql的5.7版本运行mysql5.7镜像docker run -v ${pwd}/mysql:/var/lib/mysql –name mysql5.7 -d -e MYSQL_ROOT_PASSWORD=root-p 3306:3306 mysql:5.7参数解析：-v ${pwd}/mysql:/var/lib/mysql 把容器里的/var/lib/mysql目录挂载到实体机的当前执行此docker命令的目录下mysql上，这样容器里的数据库文件就映射到了实体机，即使容器挂掉，mysql的数据还在-p 3306：3306 把主机的3306 端口映射到容器的3306端口，使得可以再容器外访问mysql-d 使容器在后太运行-e 指定mysql容器的运行环境参数， MYSQL_ROOT_PASSWORD 可以设定mysql的root账户的密码查看运行结果docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ee000f76f8fd mongo:latest &quot;docker-entrypoint.s…&quot; 2 days ago Up About an hour 0.0.0.0:27017-&gt;27017/tcp mongoDB b32313af6fd9 mysql:5.7 &quot;docker-entrypoint.s…&quot; 3 days ago Up About an hour 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql5.7 此时，可以看到status显示 运行时间，我的已经运行了一小时，如果失败，status会显示为 Exited ，说明容器运行失败，原因基本上是 docker run 命令参数不全或者错误导致的,这时，可以使用数据库连接工具进行连接，也可以进入容器执行sql查看结果，本文以进入容器为例：执行：docker exec -it ${CONTAINER ID} bash 这里填写自己的mysql容器id,-it表示以交互模式进入容器，容器内部就像是一个精简的linux，可以执行 linux基本命令 root@cyka:/docker-all-conf/mysql5.7/conf.d# docker exec -it mysql5.7 bash root@b32313af6fd9:/# 可以看到进入容器后@后已经变成容器id，相当于linux的host 这是可以运行 mysql -uroot -p 输入 密码后进入mysql执行sql root@b32313af6fd9:/# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.27 MySQL Community Server (GPL) Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | forum-server | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.01 sec) mysql&gt; docker部署mysql5.7完成！如果想配置mysql的配置文件，可以把mysql的配置文件目录挂载，这样就可以自己配置了。","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ubisoft-potato.github.io/tags/mysql/"}]},{"title":"SpringBoot集成graphql文件上传","slug":"SpringBoot集成graphql文件上传","date":"2019-09-13T12:25:11.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/13/springboot-ji-cheng-graphql-wen-jian-shang-chuan/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/13/springboot-ji-cheng-graphql-wen-jian-shang-chuan/","excerpt":"SpringBoot集成graphql文件上传graphql上传文件所面临的问题在国内，目前使用graphql的公司并不多，facebook设计graphql主要支持是js，对于java的支持主要靠的还是社区，目前使用最多的是graphql-spring-boot与SpringBoot的整合，以及schema解析工具graphql-java-tools，maven依赖如下，但其对Graphql实现的servlet对文件上传的支持却迟迟没有的demo","text":"SpringBoot集成graphql文件上传graphql上传文件所面临的问题在国内，目前使用graphql的公司并不多，facebook设计graphql主要支持是js，对于java的支持主要靠的还是社区，目前使用最多的是graphql-spring-boot与SpringBoot的整合，以及schema解析工具graphql-java-tools，maven依赖如下，但其对Graphql实现的servlet对文件上传的支持却迟迟没有的demo &lt;dependency> &lt;groupId>com.graphql-java-kickstart&lt;/groupId> &lt;artifactId>graphql-spring-boot-starter&lt;/artifactId> &lt;version>5.9.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.graphql-java-kickstart&lt;/groupId> &lt;artifactId>graphql-java-tools&lt;/artifactId> &lt;version>5.6.1&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.graphql-java-kickstart&lt;/groupId> &lt;artifactId>graphiql-spring-boot-starter&lt;/artifactId> &lt;version>5.6.0&lt;/version> &lt;/dependency> 解决方案于是本人就上stackoverflow求助各路大神，但是由于graphql文件上传过于冷门，没人回答最终还是得靠自己解决，附上原文链接，有兴趣得朋友可以看看How to upload files with graphql-java?","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://ubisoft-potato.github.io/tags/文件上传/"},{"name":"graphql-java","slug":"graphql-java","permalink":"https://ubisoft-potato.github.io/tags/graphql-java/"}]},{"title":"SpringBoot自定义自动配置","slug":"SpringBoot自定义自动配置","date":"2019-09-08T08:26:34.000Z","updated":"2020-08-19T02:46:13.233Z","comments":true,"path":"2019/09/08/springboot-zi-ding-yi-zi-dong-pei-zhi/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/08/springboot-zi-ding-yi-zi-dong-pei-zhi/","excerpt":"前言为什么需要自定义spring自动配置?在很多时候，我们会需要开发一些公共组件jar包，同时我们又希望能在项目启动时自动加载，所以可以通过自定义自动配置包来到达此目的。","text":"前言为什么需要自定义spring自动配置?在很多时候，我们会需要开发一些公共组件jar包，同时我们又希望能在项目启动时自动加载，所以可以通过自定义自动配置包来到达此目的。准备工作自动配置原理如果不懂springboot自动配置原理，可以看我之前一篇springboot自动配置原理maven引入springboot核心依赖版本依赖父工程的springboot版本号，可自行决定&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>your-version&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;/project>开发需要自动注入的组件 import org.apache.ibatis.datasource.pooled.PooledDataSource; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; @Configuration public class AutoConfigDemo { @Bean @ConditionalOnClass(PooledDataSource.class) public DataSource MyDataSource() { //比如自己注入一个apache的数据源 return new PooledDataSource(); } }上述代码首先在类上添加了@configuration注解，说明这是一个配置类，此时这个类就相当于ssm项目中的applicationContext.xml， @Bean 标注的方法则相当于applicationContext.xml中如下配置:说明：@ConditionalOnClass(PooledDataSource.class)，意为当PooledDataSource类存在时才注入这个bean，可以实现注入bean控制&lt;bean id=&quot;MyDataSource&quot; class=&quot;org.apache.ibatis.datasource.pooled.PooledDataSource&quot;/&gt;但是这个项目如果直接作为jar包导入你的主项目里，还不能实现自动注入，我们还需要在resource下建立 META-INF/spring.factories ， 如自动配置文中所述位置, 需要注意的是 文件夹必须叫META-INF，文件名也必须是spring.factories，否则无法实现自动注入， 最后 spring.factories 添加如下内容文件位置如下：&lt;bean id=&quot;MyDataSource&quot; class=&quot;org.apache.ibatis.datasource.pooled.PooledDataSource&quot;/&gt;但是这个项目如果直接作为jar包导入你的主项目里，还不能实现自动注入，我们还需要在resource下建立 META-INF/spring.factories ， 如自动配置文中所述位置, 需要注意的是 文件夹必须叫META-INF，文件名也必须是spring.factories，否则无法实现自动注入， 最后 spring.factories 添加如下内容文件位置如下：org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.xxx.xxx.xxx.AutoConfigDemocom.xxx.xxx.xxx.AutoConfigDemo 是我们的配置类全类名 测试将项目打成jar包，在主项目中引入，启动主项目，实现自动注入","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"自定义","slug":"自定义","permalink":"https://ubisoft-potato.github.io/tags/自定义/"}]},{"title":"SpringBoot自动配置原理","slug":"SpringBoot自动配置原理","date":"2019-09-07T09:38:26.000Z","updated":"2020-08-19T02:46:13.233Z","comments":true,"path":"2019/09/07/springboot-zi-dong-pei-zhi-yuan-li/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/07/springboot-zi-dong-pei-zhi-yuan-li/","excerpt":"自动配置原理关键注解@SpringBootApplication点击进入@SpringBootApplication注解代码@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { }","text":"自动配置原理关键注解@SpringBootApplication点击进入@SpringBootApplication注解代码@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { }其中包含@EnableAutoConfiguration注解:意为开启自动配置（顺便一提:@ComponentScan注解这个注解会扫描和加了这个注解的类在同一包和子包下的所有组件即:Controller、service等,为我们省去了写xml配置文件的过程）,再点击进入@EnableAutoConfiguration注解@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?>[] exclude() default {}; String[] excludeName() default {}; }这个注解有2个方法: exclude 和 excludeName，在@SpringBootApplication中可以通过使用这两个方法来指明我们不想自动注入的类比如：我们不想让springBoot自动配置数据源（springBoot默认HikariCP连接池），这样可以自己注入数据源，达到切换连接池的目的@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) public class ForumServiceApplication { public static void main(String[] args) { SpringApplication.run(ForumServiceApplication.class, args); } }@Import(AutoConfigurationImportSelector.class),@import注解表示引入指定类型的bean，即AutoConfigurationImportSelector，springBoot为我们自动注入的bean全部通过它来读取,点击进入AutoConfigurationImportSelector源码public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry( autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } protected AutoConfigurationEntry getAutoConfigurationEntry( AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String> configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String> exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } protected List&lt;String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String> configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } }getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);AutoConfigurationImportSelector通过getAutoConfigurationEntry这个方法获取到需要自动注入的类，getAutoConfigurationEntry又调用了getCandidateConfigurations(annotationMetadata,attributes),getCandidateConfigurations调用SpringFactoriesLoader类的静态方法，进入SpringFactoriesLoader中，这个类是spring-core包中的public final class SpringFactoriesLoader { /** * The location to look for factories. * &lt;p>Can be present in multiple JAR files. */ public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; }自动配置核心文件通过源码注释可以看到 FACTORIES_RESOURCE_LOCATION，并且位置为META-INF/spring.factories, spring.factories是本文重点部分spring.factories内容： # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\ org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.EnableAutoConfiguration=下面所有的自动配置类将被springBoot自动注入，通过spring.factories我们可以自定义自动配置类，实现springboot容器启动时自动注入的效果","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"自动配置","slug":"自动配置","permalink":"https://ubisoft-potato.github.io/tags/自动配置/"}]}]}