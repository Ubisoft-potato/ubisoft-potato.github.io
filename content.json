{"meta":{"title":"Ubi-potato's Blog","subtitle":null,"description":null,"author":"Ubi-potato","url":"https://ubisoft-potato.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-08-19T02:46:13.236Z","updated":"2020-08-19T02:46:13.236Z","comments":false,"path":"about/index.html","permalink":"https://ubisoft-potato.github.io/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-08-19T02:46:13.236Z","updated":"2020-08-19T02:46:13.236Z","comments":false,"path":"books/index.html","permalink":"https://ubisoft-potato.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-19T02:46:13.236Z","updated":"2020-08-19T02:46:13.236Z","comments":false,"path":"categories/index.html","permalink":"https://ubisoft-potato.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-19T02:46:13.240Z","updated":"2020-08-19T02:46:13.240Z","comments":true,"path":"links/index.html","permalink":"https://ubisoft-potato.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-19T02:46:13.240Z","updated":"2020-08-19T02:46:13.240Z","comments":false,"path":"repository/index.html","permalink":"https://ubisoft-potato.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-19T02:46:13.240Z","updated":"2020-08-19T02:46:13.240Z","comments":false,"path":"tags/index.html","permalink":"https://ubisoft-potato.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"spring bean","slug":"spring-bean","date":"2020-08-19T03:11:21.000Z","updated":"2020-08-19T03:13:27.088Z","comments":true,"path":"2020/08/19/spring-bean/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/spring-bean/","excerpt":"","text":"Spring BeanSpring容器管理了一个或者多个bean，这些bean是更具bean定义元数据进行创建的。在Spring容器内部，bean定义元数据以BeanDefinition对象呈现，包含以下信息：类的全类名定义bean在容器中的行为的配置元素，比如：bean作用域、生命周期回掉方法等被当前bean所引用的bean其他配置-比如：连接池的大小这些元数据会翻译为一系列属性组成BeanDefinition：属性官方说明链接ClassInstantiating BeansNameNaming BeansScopeBean ScopesConstructor argumentsDependency InjectionPropertiesDependency InjectionAutowiring modeAutowiring CollaboratorsLazy initialization modeLazy-initialized BeansInitialization methodInitialization CallbacksDestruction methodDestruction CallbacksBeanDefinition包含了如何准确创建一个bean的信息，ApplicationContext也允许用户注册在容器外部创建的对象。可以通过getBeanFactory()来获取ApplicationContext内部聚合的BeanFactory来做到，其返回BeanFactory实现类为DefaultListableBeanFactory，DefaultListableBeanFactory支持通过registerSingleton(..)和registerBeanDefinition(..)方法进行注册TIPS： 为了能让Spring容器在自动装盘时正确的理解bean的意图，Bean元数据和手动注册的单实例对象应该被尽可能早地执行。虽然在某种程度上支持覆盖现有Bean元数据和现有单例实例，但是在运行时（与对工厂的实时访问同时）对新bean的注册不被Spring支持，并且可能导致并发访问异常，bean容器中的状态不一致。bean的命名任何一个bean都有一个或多个标识符，这些标识符在持有这些bean的容器中必须唯一，通常一个bean只有一个标识符，如果要求有多个，可以考虑起别名。使用XML进行配置时，我们使用id和name属性进行指定bean的标识符，id能指定唯一的标识，这些都是由字母数字组成的(‘myBean’, ‘someService’等)，也能包含特殊的字符，如果需要起一些别名，则使用name属性进行定义，使用逗号，分号或空格进行分隔。但id必须唯一。如果没有指定id和name，容器会为bean自动生成一个唯一的标识符。bean命名惯例：bean的名称默认使用首单词的首字母小写，其余的单词首字母都是大写，比如：accountManager,accountService,userDao,loginController等。bean的命名能够使得应用的配置更加简单和易读，如果使用Spring Aop，能够更方便的通过bean的名称进行的切面定义。TIPS:通过在类路径中进行组件扫描，Spring会按照前面描述的规则为未命名的组件生成Bean名称：从本质上讲，将采用简单的类名称并将其首字符转换为小写。 但是，在（不寻常的）特殊情况下，如果有多个字符且第一个和第二个字符均为大写字母，则会保留原始大小写。在BeanDefinition之外给bean去别名我们可以通过BeanDefinition给bean定义一个或多个名称，通过id属性定义唯一标识符和name属性定义多个别名。但是，在实际定义bean的地方指定所有别名并不能满足需求。 有时需要为在别处定义的bean引入别名。 在大型系统中通常是这种情况，在大型系统中，配置在每个子系统之间分配，每个子系统都有自己的对象定义集。1&lt;alias name=\"fromName\" alias=\"toName\"/&gt;使用XML的标签进行起别名给fromName的bean起一个toName的别名。比如：A系统通过subsystemA-dataSource来引用一个Datasource对象，B系统通过subsystemB-dataSource来引用DataSource对象，当组合这2个子系统为一个系统时，主应用使用myApp-dataSource来进行引用，这种情况可以使用以下配置：12&lt;alias name=\"myApp-dataSource\" alias=\"subsystemA-dataSource\"/&gt;&lt;alias name=\"myApp-dataSource\" alias=\"subsystemB-dataSource\"/&gt;实例化bean一个beanDefinition可以创建一个或多个对象，容器在被查询时会查看命名bean的定义，并使用该bean定义封装的配置元数据来创建（或获取）实际对象。如果使用XML定义Bean元数据，通常需要指定标签中的class属性class属性对应BeanDefinition中的Class字段。Class字段有2种用法:通常，在容器本身通过反射机制调用其构造函数直接创建Bean的情况下，指定要构造的Bean类型，这在某种程度上等同于使用new运算符的Java代码。要指定包含用于创建对象的静态工厂方法的实际类，在不太常见的情况下，容器将在类上调用静态工厂方法以创建Bean。 从静态工厂方法的调用返回的对象类型可以是同一类，也可以是完全不同的另一类。内部类：如果需要配置类的内部静态类的bean定义，必须要使用类的组合名称，比如：在 com.example 包下有一个叫SomeThing的类，在其内部有一个叫OtherThing的内部静态类，则其beanDefinition的class属性将会是com.example.SomeThing$OtherThing,$被用来作为内部类和外部类的分隔。使用构造器初始化当通过构造方法创建一个bean时，所有普通类都可以被Spring使用并兼容。 也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。 只需指定bean类就足够了。 但是，根据用于该特定bean的IoC类型，可能需要一个默认（空）构造函数。Spring IoC容器几乎可以管理任何类。 它不仅限于管理真正的JavaBean。 大多数Spring用户更喜欢实际的JavaBean，它们仅具有默认（无参数）构造函数，并具有根据容器中的属性建模的适当的setter和getter。 还可以在容器中包含更多奇特的非bean样式类。 例如，如果需要使用绝对不符合JavaBean规范的旧式连接池，则Spring也可以对其进行管理。123&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"/&gt;&lt;bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/&gt;使用静态工厂方法进行实例化可以使用class属性来指定包含静态工厂方法的的类，使用factory-method属性来指定工厂方法的名字。123&lt;bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/&gt;12345678public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125;使用实例工厂方法使用已存在的bean的非静态工厂方法创建新的bean：123456789&lt;!-- the factory bean, which contains a method called createInstance() --&gt;&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;!-- the bean to be created via the factory bean --&gt;&lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/&gt;12345678public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125;工厂类也能拥有多个工厂方法：1234567891011&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/&gt;&lt;bean id=\"accountService\" factory-bean=\"serviceLocator\" factory-method=\"createAccountServiceInstance\"/&gt;1234567891011121314public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125;这种方式说明工厂bean本省可以被容器管理和通过DI配置。决定bean的运行时类型确定特定bean的运行时类型并非易事。 Bean元数据定义中的指定类只是初始类引用，可能与声明的工厂方法结合使用，或者是FactoryBean类，这可能导致Bean的运行时类型不同，或者在实例的情况下根本不进行设置 工厂方法（通过指定的factory-bean名称解析）。 此外，AOP代理可以使用基于接口的代理包装Bean实例，而目标Bean的实际类型（仅是其实现的接口）的暴露程度有限。建议使用BeanFactory.getType获取运行时bean的类型。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"k3s中使用configmap灵活配置","slug":"k3s中使用configmap灵活配置","date":"2019-12-07T09:15:39.000Z","updated":"2020-08-19T02:46:13.235Z","comments":true,"path":"2019/12/07/k3s中使用configmap灵活配置/","link":"","permalink":"https://ubisoft-potato.github.io/2019/12/07/k3s中使用configmap灵活配置/","excerpt":"使用configmap前所遇到的问题123在微服务横行的时代，一个系统被拆分成多个子系统，使得每个子系统各自有一套自己管理的配置，使得配置管理难度加大，springcloud的解决方案是spring config，可以通过github等集中托管各服务配置，集群化部署有比spring config更简单的解决方案：k8s configmap","text":"使用configmap前所遇到的问题123在微服务横行的时代，一个系统被拆分成多个子系统，使得每个子系统各自有一套自己管理的配置，使得配置管理难度加大，springcloud的解决方案是spring config，可以通过github等集中托管各服务配置，集群化部署有比spring config更简单的解决方案：k8s configmap什么是configmapConfigMap 是k8s集群中的一种资源类型，并且ConfigMap会将配置数据作为k-v键值对存储，存储的数据可以被集群中的pod消费。通过configMap我们可以将springboot的配置文件集中管理在一个k8s名称空间下，这样就可以统一管理所有容器配置创建configMap使用kubectl命令创建:1kubectl create configmap &lt;map-name&gt; &lt;data-source&gt; -n &lt;namespace&gt;其中可以是存放配置文件的目录或者就是配置文件，是创建的configMap的名字, &lt; namespace &gt;为指定的名称空间名。例子：12345678# 创建本地目录mkdir -p /config# 下载事例配置wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.propertieswget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.propertieskubectl create configmap testConfigMap --from-file=/config/ -n dev上述命令为使用/config 目录下的所有配置文件在dev名称空间创建名为 testConfigMap的configMap资源查看创建完的configmap:12kubectl describe configmap testConfigMap -n devkubectl get configmap testConfigMap -o yaml -n dev查看dev名称空间下名叫testConfigMap的configMap，如果按照上述操作，结果应该如下：123456789Name: game-configNamespace: devLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====game.properties: 158 bytesui.properties: 83 bytes使用第二条命令则更详细：12345678910111213141516171819202122apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2016-02-18T18:52:05Z name: game-config namespace: dev resourceVersion: &quot;516&quot; uid: b4952dc3-d670-11e5-8cd0-68f728db1985data: game.properties: | enemies=aliens lives=3 enemies.cheat=true enemies.cheat.level=noGoodRotten secret.code.passphrase=UUDDLRLRBABAS secret.code.allowed=true secret.code.lives=30 ui.properties: | color.good=purple color.bad=yellow allow.textmode=true how.nice.to.look=fairlyNice1通过上述操作可以发现，使用命令创建后，configmap中的key即为配置文件的名字，所以使用起来也非常方便创建configMap还可以通过yaml配置文件的方式创建，不再详细说明，通过文件方式更为通用configMap的应用创建好configMap就要使用到实际应用中，pod可以直接使用集群中的configMap资源，通常来说有2种应用：121、作为pod中的环境变量导入2、作为pod中的loume挂载，将configMap的key对应的数据变成文件挂载到pod中的指定位置要集中管理springboot配置文件，使用第2种营业员方式：12345678910111213141516171819202122232425262728293031323334创建configMap，其中有2个配置文件apiVersion: v1kind: ConfigMapmetadata: name: special-config namespace: defaultdata: SPECIAL_LEVEL: very SPECIAL_TYPE: charm---将配置文件挂载到pod的/etc/config 目录下apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config/&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: # Provide the name of the ConfigMap containing the files you want # to add to the container name: special-config restartPolicy: Never当pod创建并启动后，会输出如下结果：12SPECIAL_LEVELSPECIAL_TYPE说明configMap中的key作为了文件名，值作为文件内容。12注意：这种挂载方式会清空 pod中/etc/config目录下原有的所有文件，再将配置文件挂载进去，如果不想原来的配置被删除可以使用subPath的挂载方式，修改如下：123456789101112131415161718192021apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config/&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config/SPECIAL_LEVEL subPath: SPECIAL_LEVEL volumes: - name: config-volume configMap: name: special-config items: - key: SPECIAL_LEVEL path: SPECIAL_LEVEL restartPolicy: Never通过subPath的挂载方式，原来pod目录里的文件就不会被删除","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"configmap","slug":"configmap","permalink":"https://ubisoft-potato.github.io/tags/configmap/"}]},{"title":"k3s配置ingress使用ssl证书","slug":"k3s配置ingress使用ssl证书","date":"2019-11-03T06:39:03.000Z","updated":"2020-08-19T02:46:13.235Z","comments":true,"path":"2019/11/03/k3s配置ingress使用ssl证书/","link":"","permalink":"https://ubisoft-potato.github.io/2019/11/03/k3s配置ingress使用ssl证书/","excerpt":"What is Ingress?Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource.12345678910 internet | [ Ingress ] --|-----|-- [ Services ]Ingress暴露了从集群外部到集群内服务的HTTP和HTTPS路由。流量路由由Ingress资源上定义的规则控制。可以将Ingress配置为提供服务外部可访问的URL，负载平衡流量，并提供基于SSL / TLS的虚拟主机。入口控制器通常通过负载平衡器负责实现入口，尽管它也可以配置边缘路由器或其他前端以帮助处理流量。","text":"What is Ingress?Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource.12345678910 internet | [ Ingress ] --|-----|-- [ Services ]Ingress暴露了从集群外部到集群内服务的HTTP和HTTPS路由。流量路由由Ingress资源上定义的规则控制。可以将Ingress配置为提供服务外部可访问的URL，负载平衡流量，并提供基于SSL / TLS的虚拟主机。入口控制器通常通过负载平衡器负责实现入口，尽管它也可以配置边缘路由器或其他前端以帮助处理流量。说白了ingress的功能就是类是于反向代理，能够做到像nginx一样的反代的功能，控制流量，并有负载均衡的能力，本文主要讨论如何在k3s集群中配置https证书注意：k3s集群默认使用traefik来实现反向代理，但也支持使用nginx来作为 ingress controller 来实现反向代理配置http ingress12345678910111213141516171819202122kind: IngressapiVersion: networking.k8s.io/v1beta1metadata: name: test-ingress annotations: kubernetes.io/ingress.class: traefik traefik.frontend.rule.type: PathPrefixStripspec: rules: # 这里可以配置多个域名代理规则 - host: xxx # 域名 http: paths: - backend: serviceName: service-01 servicePort: 8080 - host: xxx # 域名 http: paths: - backend: serviceName: service-02 servicePort: 80801234567执行: kubectl apply -f ingress.yaml ,创建ingress。[root@hostname ~]# kubectl get ingress NAME HOSTS ADDRESS PORTS AGEtest-ingress xxxxx,xxxx 172.17.19.115 80 6h15m可以看到 端口为80，说明ingress已经为指定的service做好http代理为ingress配置https首先配置k3s secret123456789apiVersion: v1kind: Secretmetadata: name: testsecret-tls namespace: defaultdata: tls.crt: base64 encoded cert #此处必须为base64 加密后的证书 可使用 cat xxx.pem | base64 命令得到 tls.key: base64 encoded key #此处必须为base64 加密后的密钥 可使用 cat xxx.key | base64 命令得到type: kubernetes.io/tls123456789101112131415161718192021222324252627282930kind: IngressapiVersion: networking.k8s.io/v1beta1metadata: name: test-ingress namespace: default # ingress要和secret在同一个名称空间下 annotations: kubernetes.io/ingress.class: traefik traefik.frontend.rule.type: PathPrefixStrip # http 重定向到 https ingress.kubernetes.io/ssl-redirect: \"True\"spec: tls: - hosts: - xxxx.xxxx # 这里是下面要配置https的域名 - xxxx.xxxx # 这里是下面要配置https的域名 secretName: testsecret-tls rules: # 这里可以配置多个域名代理规则 - host: xxx # 域名 http: paths: - backend: serviceName: service-01 servicePort: 8080 - host: xxx # 域名 http: paths: - backend: serviceName: service-02 servicePort: 808012345678910111213141516171819先后执行： kubectl apply -f secret.yaml kubectl apply -f ingress.yaml-----------------------------------------------------查看 secret : kubectl get secret [root@hostname ~]# kubectl get secret NAME TYPE DATA AGE default-token-d25kq kubernetes.io/service-account-token 3 10h testsecret-tls kubernetes.io/tls 2 7h25m第二行为我们所创建的证书的secret对象------------------------------------------------------查看ingress: kubectl get ingress [root@hostname ~]# kubectl get ingress NAME HOSTS ADDRESS PORTS AGEtest-ingress xxx.xxx,xxx.xxx 172.17.19.115 80, 443 7h26m可以看到 端口已经添加了443如果操作无误，这时访问我们的域名已经是变成了https，并且访问http也会被重定向到https","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"ingress","slug":"ingress","permalink":"https://ubisoft-potato.github.io/tags/ingress/"},{"name":"ssl","slug":"ssl","permalink":"https://ubisoft-potato.github.io/tags/ssl/"}]},{"title":"docker入门","slug":"docker入门","date":"2019-11-01T13:44:27.000Z","updated":"2020-08-19T02:46:13.235Z","comments":true,"path":"2019/11/01/docker入门/","link":"","permalink":"https://ubisoft-potato.github.io/2019/11/01/docker入门/","excerpt":"什么是docker？123Docker is a set of platform-as-a-service products that use OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. --wiki12Docker是一组平台即服务产品，它们使用操作系统级虚拟化并被称为容器的软件包交付软件。 容器彼此隔离，并将它们自己的软件，库和配置文件捆绑在一起； 他们可以通过定义明确的渠道相互通信。","text":"什么是docker？123Docker is a set of platform-as-a-service products that use OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. --wiki12Docker是一组平台即服务产品，它们使用操作系统级虚拟化并被称为容器的软件包交付软件。 容器彼此隔离，并将它们自己的软件，库和配置文件捆绑在一起； 他们可以通过定义明确的渠道相互通信。docker基本概念容器–什么是容器What is a Container? A standardized unit of software容器是标准的软件单元（可独立运行的） ，传统的软件部署方式，需要将软件打包，并在部署之前，要在操作系统上安装相关依赖，这样的部署方式使得软件的耦合度太高，并且不宜维护，而通过容器，可以将软件打包到标准化单元中，以进行开发，运输和部署，极大降低软件部署的耦合度。Why Docker?作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。docker 容器 vs 虚拟机 123容器是应用程序层的抽象，将代码和依赖项打包在一起。多个容器可以在同一台计算机上运行，​​并与其他容器共享OS内核，每个容器在用户空间中作为隔离的进程运行。容器占用的空间少于VM（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要的VM和操作系统更少。1234虚拟机（VM）是将一台服务器转变为多台服务器的物理硬件的抽象。虚拟机管理程序允许多个VM在单台计算机上运行。每个VM包含操作系统，应用程序，必要的二进制文件和库的完整副本-占用数十GB。 VM也可能启动缓慢。基本概念Docker 包括三个基本概念镜像（Image）容器（Container）仓库（Repository）镜像1234567Docker 镜像（Image）就是一个只读的模板。例如：一个镜像可以包含一个完整的 Ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。容器12345Docker 利用容器（Container）来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。仓库12345678910111213仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括时速云 、网易云等，可以提供大陆用户更稳定快速的访问。当然，用户也可以在本地网络内创建一个私有仓库（参考本文“私有仓库”部分）。当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"docker基本概念","slug":"docker基本概念","permalink":"https://ubisoft-potato.github.io/tags/docker基本概念/"}]},{"title":"rancher、k3s安装记录","slug":"rancher、k3s安装记录","date":"2019-10-09T06:02:43.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/10/09/rancher、k3s安装记录/","link":"","permalink":"https://ubisoft-potato.github.io/2019/10/09/rancher、k3s安装记录/","excerpt":"k3s 简介k3s 是 Rancher 推出的轻量级 k8s。k3s 本身包含了 k8s 的源码，所以本质上和 k8s 没有区别。但为了降低资源占用，k3s 和 k8s 还是有一些区别的，主要是：使用了相比 Docker 更轻量的 containerd 作为容器运行时（Docker 并不是唯一的容器选择）去掉了 k8s 的 Legacy, alpha, non-default features用 sqlite3 作为默认的存储，而不是 etcd其他的一些优化，最终 k3s 只是一个 binary 文件，非常易于部署所以 k3s 适用于边缘计算，IoT 等资源紧张的场景。同时 k3s 也是非常容易部署的，官网上提供了一键部署的脚本。","text":"k3s 简介k3s 是 Rancher 推出的轻量级 k8s。k3s 本身包含了 k8s 的源码，所以本质上和 k8s 没有区别。但为了降低资源占用，k3s 和 k8s 还是有一些区别的，主要是：使用了相比 Docker 更轻量的 containerd 作为容器运行时（Docker 并不是唯一的容器选择）去掉了 k8s 的 Legacy, alpha, non-default features用 sqlite3 作为默认的存储，而不是 etcd其他的一些优化，最终 k3s 只是一个 binary 文件，非常易于部署所以 k3s 适用于边缘计算，IoT 等资源紧张的场景。同时 k3s 也是非常容易部署的，官网上提供了一键部署的脚本。下载可执行k3s 安装脚本、二进制文件 和 镜像123456mkdir k3s-installcd k3s-installcurl -sfL https://get.k3s.io &gt; install.shchmod +x ./install.shwget https://github.com/rancher/k3s/releases/download/$&#123;k3s.version&#125;/k3swget https://github.com/rancher/k3s/releases/download/$&#123;k3s.version&#125;/k3s-airgap-images-amd64.tar安装k3s主服务器12345678910cp ./k3s /usr/local/bin/chmod +x /usr/local/bin/k3smkdir -p /var/lib/rancher/k3s/agent/images/cp ./k3s-airgap-images-amd64.tar /var/lib/rancher/k3s/agent/images/INSTALL_K3S_SKIP_START=true INSTALL_K3S_EXEC=\"--docker\" INSTALL_K3S_BIN_DIR=\"/usr/local/bin\" INSTALL_K3S_SKIP_DOWNLOAD=true sh install.shln -s /usr/local/bin/k3s /usr/bin/k3ssystemctl enable k3ssystemctl start k3s修改配置文件 /etc/systemd/system/k3s.service 将其中的ExecStart修改为使用docker1ExecStart=/usr/local/bin/k3s server --docker运行命令，查看状态1234kubectl get nodeNAME STATUS ROLES AGE VERSIONhostname Ready master 110s v1.14.5-k3s.1安装agent12345678910cp ./k3s /usr/local/bin/chmod +x /usr/local/bin/k3smkdir -p /var/lib/rancher/k3s/agent/images/cp ./k3s-airgap-images-amd64.tar /var/lib/rancher/k3s/agent/images/INSTALL_K3S_SKIP_START=true INSTALL_K3S_EXEC=\"--docker\" INSTALL_K3S_BIN_DIR=\"/usr/local/bin\" INSTALL_K3S_SKIP_DOWNLOAD=true K3S_TOKEN=XXXXX K3S_URL=https://XXXXX:6443 sh install.shln -s /usr/local/bin/k3s /usr/bin/k3ssystemctl enable k3s-agentsystemctl start k3s-agenttoken需要从主服务器的 /var/lib/rancher/k3s/server/node-token 获取安装控制台创建目录 /data/k3s/rancher-server/var/lib/rancher1docker run -d -v /data/k3s/rancher-server/var/lib/rancher/:/var/lib/rancher/ --restart=unless-stopped --name rancher-server -p 38080:80 -p 38443:443 rancher/rancher:stable","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"rancher","slug":"rancher","permalink":"https://ubisoft-potato.github.io/tags/rancher/"}]},{"title":"使用docker部署文件服务ambry","slug":"使用docker部署文件服务ambry","date":"2019-10-08T13:17:30.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/10/08/使用docker部署文件服务ambry/","link":"","permalink":"https://ubisoft-potato.github.io/2019/10/08/使用docker部署文件服务ambry/","excerpt":"分布式文件服务ambry分布式文件服务ambry是国外著名社交软件公司 linkedin 的开源项目，ambry官网地址:https://github.com/linkedin/ambry, 可以自行查看github介绍","text":"分布式文件服务ambry分布式文件服务ambry是国外著名社交软件公司 linkedin 的开源项目，ambry官网地址:https://github.com/linkedin/ambry, 可以自行查看github介绍如何使用docker容器化部署ambryambry官方并没有相关镜像，所以自己制作ambry镜像进行部署,下面进行介绍:ambry分为服务段和前端，所以制作了2个镜像, 镜像dockerHub地址：https://hub.docker.com/r/wdnmdcyka/ambry-client, https://hub.docker.com/r/wdnmdcyka/ambry-server123456789101112131415[root@izwz94ymqw967redc0vyeoz ~]# docker search ambryNAME DESCRIPTION STARS OFFICIAL AUTOMATEDamimimor/ambry Ambry Docker Image 0 civicknowledge/ambry Public data ETL framework 0 [OK]sandinh/ambry dockerize for linkedin [ambry] 0 [OK]sivabalan/ambry Adding docker support for ambry 0 [OK]sivabalan/ambryfe Ambry FE using in memory router factory 0 [OK]sandinh/ambry-import-xenforo import xenforo avatars, attachments to ambry 0 maciejbak85/ambry Distributed object store https://github.com 0 civicknowledge/ambry-base 0 gnkr8/ambry 0 ktimothy/ambry 0 wdnmdcyka/ambry-server linkedin/ambry server image 0 wdnmdcyka/ambry-client linkedin/ambry fronted image 0需要下载 wdnmdcyka/ambry-server、wdnmdcyka/ambry-client123[root@izwz94ymqw967redc0vyeoz ~]# docker pull wdnmdcyka/ambry-server:1.0[root@izwz94ymqw967redc0vyeoz ~]# docker pull wdnmdcyka/ambry-client:1.0部署方式按照官网传统部署方式，需要部署ambry的服务端和ambry的前端，前端不负责存储，所有的文件都是在服务端存储，前端只是负责转发请求和组织服务端存储首先部署ambry-server:12345678docker run -d -v $&#123;your config dir&#125;:/app/config -v $&#123;your tmp dir&#125;:/tmp -v $&#123;your logs dir&#125;:/app/logs -p 6667:6667 -p 16503:16503 --restart always --name ambry-server wdnmdcyka/ambry-server:tagname说明：其中挂载出来的目录有ambry的配置文件目录，/tmp为服务端存储文件的目录，/app/logs为ambry生成日志存储的目录暴露的端口6667为server和client通信的端口部署ambry-client：123456docker run -d -v $&#123;your config dir&#125;:/app/config -v $&#123;your logs dir&#125;:/app/logs -p 1174:1174 --restart always --name ambry-client wdnmdcyka/ambry-client:tagname说明：由于client端不负责存储，所以没有挂载/tmp目录，1174端口是ambry暴露的rest接口所使用的端口配置文件获取地址：https://github.com/linkedin/ambry/tree/master/config测试如果配置无误，直接请求 http://localhost:1174/healthCheck ，如果返回 GOOD 则部署成功!","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://ubisoft-potato.github.io/tags/文件上传/"},{"name":"分布式文件服务","slug":"分布式文件服务","permalink":"https://ubisoft-potato.github.io/tags/分布式文件服务/"}]},{"title":"springBoot统一异常处理","slug":"springBoot统一异常处理","date":"2019-09-28T12:33:00.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/28/springBoot统一异常处理/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/28/springBoot统一异常处理/","excerpt":"如何在springBoot优雅的处理异常？异常处理在任何项目中都尤为重要，所以这使得如何统一处理异常变得非常重要，本文记录在SpringBoot中解决统一异常处理最优雅的方式。","text":"如何在springBoot优雅的处理异常？异常处理在任何项目中都尤为重要，所以这使得如何统一处理异常变得非常重要，本文记录在SpringBoot中解决统一异常处理最优雅的方式。spring 3.2新增注解@ControllerAdvice12345678910111213141516171819202122232425package org.springframework.web.bind.annotation;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface ControllerAdvice &#123; @AliasFor(\"basePackages\") String[] value() default &#123;&#125;; @AliasFor(\"value\") String[] basePackages() default &#123;&#125;; Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;; Class&lt;?&gt;[] assignableTypes() default &#123;&#125;; Class&lt;? extends Annotation&gt;[] annotations() default &#123;&#125;;&#125;ControllerAdvice拆分开来就是Controller Advice，关于Advice，可以理解为AOP面向切面编程中的环绕增强，为指定范围内的controller进行相应方法的增强代理。结合方法型注解@ExceptionHandler，用于捕获Controller中抛出的指定类型的异常，从而达到不同类型的异常区别处理的目的；@ControllerAdvice的用法基本是将其声明在某个bean上，然后在该bean的方法上使用其他的注解来指定不同的织入逻辑。不过这里@ControllerAdvice并不是使用AOP的方式来织入业务逻辑的，而是Spring内置对其各个逻辑的织入方式进行了内置支持@ExceptionHandler注解@ExceptionHandler的作用主要在于声明一个或多个类型的异常,当符合条件的Controller抛出这些异常之后将会对这些异常进行捕获，然后按照其标注的方法的逻辑进行处理，从而改变返回的信息12345678@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ExceptionHandler &#123; // 指定需要捕获的异常的Class类型 Class&lt;? extends Throwable&gt;[] value() default &#123;&#125;;&#125;实例说明统一异常配置类123456789101112@ControllerAdvice(basePackages = \"xxx.xxx\")//指定controller所在的包public class MyExceptionHandler &#123; @ExceptionHandler(Exception.class)//需要处理的异常类型 @ResponseBody public Map&lt;String, String&gt; handleException(Exception e) &#123; HashMap&lt;String, String&gt; errorMap = new HashMap&lt;&gt;(); errorMap.put(\"errorMsg\", e.getMessage()); errorMap.put(\"code\", 500 + \"\"); return errorMap; &#125;&#125;写个简单的controller 直接抛出异常12345678@RestControllerpublic class MyController &#123; @GetMapping(\"/test\") public void test() &#123; throw new ArrayIndexOutOfBoundsException(\"数组越界\"); &#125;&#125;访问 /test 并没有直接返回结果 而是上述返回异常处理的map1234&#123; &quot;code&quot;:500, &quot;errorMsg&quot;:&quot;数组越界&quot;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://ubisoft-potato.github.io/tags/异常处理/"}]},{"title":"mapstruct在SpringBoot中的使用","slug":"mapstruct在SpringBoot中的使用","date":"2019-09-26T12:54:38.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/26/mapstruct在SpringBoot中的使用/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/26/mapstruct在SpringBoot中的使用/","excerpt":"MapStruct是什么MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach.MapStruct是一个极大简化javaBean之间互相转换的代码生成器，即简化实体类DTO的互相转化官方文档（https://mapstruct.org/documentation/stable/reference/html/#defining-mapper）","text":"MapStruct是什么MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach.MapStruct是一个极大简化javaBean之间互相转换的代码生成器，即简化实体类DTO的互相转化官方文档（https://mapstruct.org/documentation/stable/reference/html/#defining-mapper）maven依赖12345678910111213141516&lt;properties&gt; &lt;org.mapstruct.version&gt;1.3.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;集成MapStruct官方提供了两种方式，上面配置文件内我们采用的是直接添加Maven依赖，而官方文档还提供了另外一种方式，采用Maven插件形式配置，配置如下所示：12345678910111213141516171819202122232425262728293031&lt;properties&gt; &lt;org.mapstruct.version&gt;1.3.0.Final&lt;/org.mapstruct.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;!-- or newer version --&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!-- depending on your project --&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!-- depending on your project --&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;!-- other annotation processors --&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;一对一转换123456789101112131415161718192021222324252627282930//实体类public class Customer &#123; private Long id; private String name; //getters and setter omitted for brevity&#125;//DTOpublic class CustomerDto &#123; public Long id; public String customerName;&#125;//(org.mapstruct.Mapper) annotation@Mapperpublic interface CustomerMapper &#123; CustomerMapper INSTANCE = Mappers.getMapper( CustomerMapper.class ); //相同属性不需要用@Mapping指定，如Customer和CustomerDto中的id //customerName与name不同，则必须指定 @Mapping(source = \"customerName\", target = \"name\") Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer);&#125;可以看到CustomerMapper是一个接口的形式存在的，当然也可以是一个抽象类，如果需要在转换的时候才用个性化的定制的时候可以采用抽象类的方式，相应的代码配置官方文档已经声明。@Mapper注解是用于标注接口、抽象类是被MapStruct自动映射的标识，只有存在该注解才会将内部的接口方法自动实现。使用方式1：不需要做过多的配置内容，获取Mapper的方式就是采用Mappers通过动态工厂内部反射机制完成Mapper实现类的获取。1234567891011public class MapStructTest &#123; @Test public void directMapping() &#123; Customer customer = new Customer(); customer.setId(12L); customer.setName(\"customer001\"); CustomerDto customerDto = CustomerConverter.INSTANCE.fromCustomer(customer); System.out.println(\"customerDto = \" + customerDto); &#125;&#125;使用方式2：使用springBoot依赖注入1234567891011121314151617181920212223242526272829303132// Specifies the component model to which the generated mapper should adhere. Supported values are//指定mapper的注入模板 :cdi spring jsr330//@mapper添加参数 componentModel = \"spring\" @Mapper(componentModel = \"spring\") public interface CustomerConverter &#123; CustomerConverter INSTANCE = Mappers.getMapper(CustomerConverter.class); @Mapping(source = \"customerName\", target = \"name\") Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer);&#125;public class MapStructTest &#123;//使用autowired自动注入 @Autowired private CustomerConverter customerConverter; @Test public void directMapping() &#123; Customer customer = new Customer(); customer.setId(12L); customer.setName(\"customer001\");// CustomerDto customerDto = CustomerConverter.INSTANCE.fromCustomer(customer); CustomerDto customerDto = customerConverter.fromCustomer(customer); System.out.println(\"customerDto = \" + customerDto); &#125;&#125;1结果： customerDto = CustomerDto(id=12, customerName=customer001)IDEA插件: MapStruct Support安装idea插件MapStruct Support在编写mapper时可以提示不相同的属性映射12345678910@Mapper(componentModel = \"spring\") public interface CustomerConverter &#123; CustomerConverter INSTANCE = Mappers.getMapper(CustomerConverter.class); @Mapping(source = \"customerName\", target = \"name\") //插件可以提示source和target参数 Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer);&#125;实体类中有List属性的转换12345678910111213141516171819202122232425@Datapublic class Student &#123; private Integer id; private String name; private Integer age; private String sex;&#125;@Datapublic class Teacher &#123; private List&lt;Student&gt; students;&#125;@Datapublic class StudentDto &#123; private Integer id; private String name; private Integer age; private String gender;&#125;@Datapublic class TeacherDto &#123; private List&lt;StudentDto&gt; studentDtos;&#125;要将teacher转换到teacherDto，按照以前的方式：把teacher中的List遍历，挨个转换成dto再手动添加到teacherDto中的list中使用mapStruct:12345678910111213141516@Mapper(componentModel = \"spring\")public interface StudentConverter &#123; //定义student转studentDto @Mapping(target = \"gender\", source = \"sex\") StudentDto studentToDto(Student student); //List&lt;Student&gt; 转 List&lt;StudentDto&gt;，此方法在编译生成后会调用StudentDto studentToDto(Student student); //如果不定义StudentDto studentToDto(Student student); 此方法会报错 List&lt;StudentDto&gt; studentToDtoList(List&lt;Student&gt; students); //Teacher 转 TeacherDto ，此方法调用 List&lt;StudentDto&gt; studentToDtoList(List&lt;Student&gt; students); // 如果没有List&lt;StudentDto&gt; studentToDtoList(List&lt;Student&gt; students); 此方法报错 @Mapping(target = \"studentDtos\", source = \"students\") TeacherDto teacherToDto(Teacher teacher);&#125;测试：12345678910111213141516171819202122232425262728public class ApplicationTests &#123; @Autowired StudentConverter studentConverter; @Test public void contextLoads() &#123; Student student1 = new Student(); student1.setId(1); student1.setName(\"sda\"); student1.setAge(12); student1.setSex(\"男\"); Student student2 = new Student(); student2.setId(2); student2.setName(\"asdfd\"); student2.setAge(23); student2.setSex(\"男\"); Teacher teacher = new Teacher(); teacher.setStudents(Arrays.asList(student1, student2)); TeacherDto teacherDto = studentConverter.teacherToDto(teacher); System.out.println(\"teacher = \" + teacher); System.out.println(\"teacherDto = \" + teacherDto); &#125;&#125;123结果: teacher = Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)])teacherDto = TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男), StudentDto(id=2, name=asdfd, age=23, gender=男)])多对一这里以二对一为例:实体类:12345678910111213141516171819202122232425@Datapublic class School &#123; private Long id; private String address; private String name;&#125;@Datapublic class Student &#123; private Integer id; private String name; private Integer age; private String sex;&#125;@Datapublic class Teacher &#123; private List&lt;Student&gt; students;&#125;对应Dto:1234567891011121314151617181920212223242526@Datapublic class SchoolDto &#123; private Long id; private String address; private String name; private List&lt;TeacherDto&gt; teacherDtos;&#125;@Datapublic class StudentDto &#123; private Integer id; private String name; private Integer age; private String gender;&#125;@Datapublic class TeacherDto &#123; private List&lt;StudentDto&gt; studentDtos;&#125;mapper类:123456789101112131415161718192021222324@Mapper(componentModel = \"spring\")public interface StudentConverter &#123; //定义student转studentDto @Mapping(target = \"gender\", source = \"sex\") StudentDto studentToDto(Student student); //List&lt;Student&gt; 转 List&lt;StudentDto&gt;，此方法在编译生成后会调用StudentDto studentToDto(Student student); //如果不定义StudentDto studentToDto(Student student); 此方法会报错 List&lt;StudentDto&gt; studentToDtoList(List&lt;Student&gt; students); //Teacher 转 TeacherDto ，此方法调用 List&lt;StudentDto&gt; studentToDtoList(List&lt;Student&gt; students); // 如果没有List&lt;StudentDto&gt; studentToDtoList(List&lt;Student&gt; students); 此方法报错 @Mapping(target = \"studentDtos\", source = \"students\") TeacherDto teacherToDto(Teacher teacher); //多对一时，每个属性最好写上起对应关系，并且此方法能正确执行依赖 TeacherDto teacherToDto(Teacher teacher); //如果teacherToDto方法不存在则会报错 @Mapping(target = \"teacherDtos\", source = \"teachers\") @Mapping(target = \"name\", source = \"school.name\") @Mapping(target = \"id\", source = \"school.id\") @Mapping(target = \"address\", source = \"school.address\") SchoolDto schoolToDto(School school, List&lt;Teacher&gt; teachers);&#125;测试：1234567891011121314151617181920212223242526272829303132333435363738public class EurkaApplicationTests &#123; @Autowired StudentConverter studentConverter; @Test public void convert() &#123; Student student1 = new Student(); student1.setId(1); student1.setName(\"sda\"); student1.setAge(12); student1.setSex(\"男\"); Student student2 = new Student(); student2.setId(2); student2.setName(\"asdfd\"); student2.setAge(23); student2.setSex(\"男\"); Teacher teacher1 = new Teacher(); teacher1.setStudents(Arrays.asList(student1, student2)); Teacher teacher2 = new Teacher(); teacher2.setStudents(Arrays.asList(student1, student2)); List&lt;Teacher&gt; teachers = Arrays.asList(teacher1, teacher2); School school = new School(); school.setId(123L); school.setAddress(\"育碧，苏维埃\"); school.setName(\"育碧一中\"); //调用mapper转换 SchoolDto schoolDto = studentConverter.schoolToDto(school, teachers); System.out.println(\"school = \" + school); System.out.println(\"teachers = \" + teachers); System.out.println(\"schoolDto = \" + schoolDto); &#125;&#125;123456789101112131415161718运行结果：school = School(id=123, address=育碧，苏维埃, name=育碧一中)teachers = [Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]), Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)])]schoolDto = SchoolDto(id=123, address=育碧，苏维埃, name=育碧一中, teacherDtos=[TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男),StudentDto(id=2, name=asdfd, age=23, gender=男)]),TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男), StudentDto(id=2, name=asdfd, age=23, gender=男)])])","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"javaBean","slug":"javaBean","permalink":"https://ubisoft-potato.github.io/tags/javaBean/"}]},{"title":"docker部署mysql5.7","slug":"docker部署mysql5-7","date":"2019-09-19T12:28:54.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/19/docker部署mysql5-7/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/19/docker部署mysql5-7/","excerpt":"docker部署mysql与传统方式对比1、传统方式：在linux上直接使用yum安装 或者mysql官网下载 tar.gz安装，使用tar.gz可能还要自己手动解决依赖问题，yum安装虽然解决了依赖问题，但是随着日益增多，其他数据安装，以及开发环境，难免会引起于其他开发环境的冲突2、docker容器化部署docker是基于linux容器技术发展而来，而linux容器技术能做到进程隔离，从而使得各个服务的部署独立，互不干扰，使用docker部署mysql，还可以部署在同一台服务器上部署不同版本的mysql，而互不影响，比起传统方式，既不用担心依赖，也不用担心开发环境不同而造成影响","text":"docker部署mysql与传统方式对比1、传统方式：在linux上直接使用yum安装 或者mysql官网下载 tar.gz安装，使用tar.gz可能还要自己手动解决依赖问题，yum安装虽然解决了依赖问题，但是随着日益增多，其他数据安装，以及开发环境，难免会引起于其他开发环境的冲突2、docker容器化部署docker是基于linux容器技术发展而来，而linux容器技术能做到进程隔离，从而使得各个服务的部署独立，互不干扰，使用docker部署mysql，还可以部署在同一台服务器上部署不同版本的mysql，而互不影响，比起传统方式，既不用担心依赖，也不用担心开发环境不同而造成影响docker化mysql步骤安装dockercentOS 直接使用yum install docker安装debian系列：使用 apt-get install docker拉去dockerhub mysql官方镜像docker pull mysql:5.7下载完成后 ，使用docker images 查看当前所有镜像 如下所示：123REPOSITORY TAG IMAGE ID CREATED SIZEmysql 5.7 383867b75fd2 7 days ago 373MBmongo latest cdc6740b66a7 5 weeks ago 361MB可以看到 TAG 下面标着 5.7， 即mysql的5.7版本运行mysql5.7镜像docker run -v ${pwd}/mysql:/var/lib/mysql –name mysql5.7 -d -e MYSQL_ROOT_PASSWORD=root-p 3306:3306 mysql:5.7参数解析：-v ${pwd}/mysql:/var/lib/mysql 把容器里的/var/lib/mysql目录挂载到实体机的当前执行此docker命令的目录下mysql上，这样容器里的数据库文件就映射到了实体机，即使容器挂掉，mysql的数据还在-p 3306：3306 把主机的3306 端口映射到容器的3306端口，使得可以再容器外访问mysql-d 使容器在后太运行-e 指定mysql容器的运行环境参数， MYSQL_ROOT_PASSWORD 可以设定mysql的root账户的密码查看运行结果docker ps123CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESee000f76f8fd mongo:latest &quot;docker-entrypoint.s…&quot; 2 days ago Up About an hour 0.0.0.0:27017-&gt;27017/tcp mongoDBb32313af6fd9 mysql:5.7 &quot;docker-entrypoint.s…&quot; 3 days ago Up About an hour 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql5.7此时，可以看到status显示 运行时间，我的已经运行了一小时，如果失败，status会显示为 Exited ，说明容器运行失败，原因基本上是 docker run 命令参数不全或者错误导致的,这时，可以使用数据库连接工具进行连接，也可以进入容器执行sql查看结果，本文以进入容器为例：1234567891011121314151617181920212223242526272829303132333435363738执行：docker exec -it $&#123;CONTAINER ID&#125; bash这里填写自己的mysql容器id,-it表示以交互模式进入容器，容器内部就像是一个精简的linux，可以执行linux基本命令root@cyka:/docker-all-conf/mysql5.7/conf.d# docker exec -it mysql5.7 bashroot@b32313af6fd9:/# 可以看到进入容器后@后已经变成容器id，相当于linux的host这是可以运行 mysql -uroot -p输入 密码后进入mysql执行sqlroot@b32313af6fd9:/# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.27 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || forum-server || mysql || performance_schema || sys |+--------------------+5 rows in set (0.01 sec)mysql&gt;docker部署mysql5.7完成！如果想配置mysql的配置文件，可以把mysql的配置文件目录挂载，这样就可以自己配置了。","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ubisoft-potato.github.io/tags/mysql/"}]},{"title":"SpringBoot集成graphql文件上传","slug":"SpringBoot集成graphql文件上传","date":"2019-09-13T12:25:11.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/13/SpringBoot集成graphql文件上传/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/13/SpringBoot集成graphql文件上传/","excerpt":"SpringBoot集成graphql文件上传graphql上传文件所面临的问题在国内，目前使用graphql的公司并不多，facebook设计graphql主要支持是js，对于java的支持主要靠的还是社区，目前使用最多的是graphql-spring-boot与SpringBoot的整合，以及schema解析工具graphql-java-tools，maven依赖如下，但其对Graphql实现的servlet对文件上传的支持却迟迟没有的demo","text":"SpringBoot集成graphql文件上传graphql上传文件所面临的问题在国内，目前使用graphql的公司并不多，facebook设计graphql主要支持是js，对于java的支持主要靠的还是社区，目前使用最多的是graphql-spring-boot与SpringBoot的整合，以及schema解析工具graphql-java-tools，maven依赖如下，但其对Graphql实现的servlet对文件上传的支持却迟迟没有的demo123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt; &lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt; &lt;artifactId&gt;graphql-java-tools&lt;/artifactId&gt; &lt;version&gt;5.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt; &lt;artifactId&gt;graphiql-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;5.6.0&lt;/version&gt;&lt;/dependency&gt;解决方案于是本人就上stackoverflow求助各路大神，但是由于graphql文件上传过于冷门，没人回答最终还是得靠自己解决，附上原文链接，有兴趣得朋友可以看看How to upload files with graphql-java?","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://ubisoft-potato.github.io/tags/文件上传/"},{"name":"graphql-java","slug":"graphql-java","permalink":"https://ubisoft-potato.github.io/tags/graphql-java/"}]},{"title":"SpringBoot自定义自动配置","slug":"SpringBoot自定义自动配置","date":"2019-09-08T08:26:34.000Z","updated":"2020-08-19T02:46:13.233Z","comments":true,"path":"2019/09/08/SpringBoot自定义自动配置/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/08/SpringBoot自定义自动配置/","excerpt":"前言为什么需要自定义spring自动配置?在很多时候，我们会需要开发一些公共组件jar包，同时我们又希望能在项目启动时自动加载，所以可以通过自定义自动配置包来到达此目的。","text":"前言为什么需要自定义spring自动配置?在很多时候，我们会需要开发一些公共组件jar包，同时我们又希望能在项目启动时自动加载，所以可以通过自定义自动配置包来到达此目的。准备工作自动配置原理如果不懂springboot自动配置原理，可以看我之前一篇springboot自动配置原理maven引入springboot核心依赖版本依赖父工程的springboot版本号，可自行决定12345678910111213141516&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;your-version&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;开发需要自动注入的组件123456789101112131415161718import org.apache.ibatis.datasource.pooled.PooledDataSource;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;@Configurationpublic class AutoConfigDemo &#123; @Bean @ConditionalOnClass(PooledDataSource.class) public DataSource MyDataSource() &#123; //比如自己注入一个apache的数据源 return new PooledDataSource(); &#125;&#125;上述代码首先在类上添加了@configuration注解，说明这是一个配置类，此时这个类就相当于ssm项目中的applicationContext.xml， @Bean 标注的方法则相当于applicationContext.xml中如下配置:说明：@ConditionalOnClass(PooledDataSource.class)，意为当PooledDataSource类存在时才注入这个bean，可以实现注入bean控制1&lt;bean id=\"MyDataSource\" class=\"org.apache.ibatis.datasource.pooled.PooledDataSource\"/&gt;但是这个项目如果直接作为jar包导入你的主项目里，还不能实现自动注入，我们还需要在resource下建立 META-INF/spring.factories ， 如自动配置文中所述位置, 需要注意的是 文件夹必须叫META-INF，文件名也必须是spring.factories，否则无法实现自动注入， 最后 spring.factories 添加如下内容文件位置如下：12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.xxx.xxx.xxx.AutoConfigDemocom.xxx.xxx.xxx.AutoConfigDemo 是我们的配置类全类名 测试将项目打成jar包，在主项目中引入，启动主项目，实现自动注入","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"自定义","slug":"自定义","permalink":"https://ubisoft-potato.github.io/tags/自定义/"}]},{"title":"SpringBoot自动配置原理","slug":"SpringBoot自动配置原理","date":"2019-09-07T09:38:26.000Z","updated":"2020-08-19T02:46:13.233Z","comments":true,"path":"2019/09/07/SpringBoot自动配置原理/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/07/SpringBoot自动配置原理/","excerpt":"自动配置原理关键注解@SpringBootApplication点击进入@SpringBootApplication注解代码123456789101112@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125;","text":"自动配置原理关键注解@SpringBootApplication点击进入@SpringBootApplication注解代码123456789101112@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125;其中包含@EnableAutoConfiguration注解:意为开启自动配置（顺便一提:@ComponentScan注解这个注解会扫描和加了这个注解的类在同一包和子包下的所有组件即:Controller、service等,为我们省去了写xml配置文件的过程）,再点击进入@EnableAutoConfiguration注解12345678910111213141516@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125;这个注解有2个方法: exclude 和 excludeName，在@SpringBootApplication中可以通过使用这两个方法来指明我们不想自动注入的类比如：我们不想让springBoot自动配置数据源（springBoot默认HikariCP连接池），这样可以自己注入数据源，达到切换连接池的目的123456@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)public class ForumServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ForumServiceApplication.class, args); &#125;&#125;@Import(AutoConfigurationImportSelector.class),@import注解表示引入指定类型的bean，即AutoConfigurationImportSelector，springBoot为我们自动注入的bean全部通过它来读取,点击进入AutoConfigurationImportSelector源码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry( autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125; protected AutoConfigurationEntry getAutoConfigurationEntry( AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); &#125; protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; &#125;&#125;getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);AutoConfigurationImportSelector通过getAutoConfigurationEntry这个方法获取到需要自动注入的类，getAutoConfigurationEntry又调用了getCandidateConfigurations(annotationMetadata,attributes),getCandidateConfigurations调用SpringFactoriesLoader类的静态方法，进入SpringFactoriesLoader中，这个类是spring-core包中的12345678public final class SpringFactoriesLoader &#123; /** * The location to look for factories. * &lt;p&gt;Can be present in multiple JAR files. */ public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";&#125;自动配置核心文件通过源码注释可以看到 FACTORIES_RESOURCE_LOCATION，并且位置为META-INF/spring.factories, spring.factories是本文重点123456789101112部分spring.factories内容：# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.EnableAutoConfiguration=下面所有的自动配置类将被springBoot自动注入，通过spring.factories我们可以自定义自动配置类，实现springboot容器启动时自动注入的效果","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"自动配置","slug":"自动配置","permalink":"https://ubisoft-potato.github.io/tags/自动配置/"}]}]}