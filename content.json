{"meta":{"title":"Ubi-potato","subtitle":"Ubi-potato","description":null,"author":"Ubi-potato","url":"https://ubisoft-potato.github.io","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-19T06:01:36.891Z","comments":true,"path":"about/index.html","permalink":"https://ubisoft-potato.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-08-19T06:01:09.943Z","comments":true,"path":"categories/index.html","permalink":"https://ubisoft-potato.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-08-19T02:46:13.236Z","updated":"2020-08-19T02:46:13.236Z","comments":false,"path":"books/index.html","permalink":"https://ubisoft-potato.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-19T02:46:13.240Z","updated":"2020-08-19T02:46:13.240Z","comments":true,"path":"links/index.html","permalink":"https://ubisoft-potato.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-08-19T06:01:20.258Z","comments":true,"path":"tags/index.html","permalink":"https://ubisoft-potato.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-19T02:46:13.240Z","updated":"2020-08-19T02:46:13.240Z","comments":false,"path":"repository/index.html","permalink":"https://ubisoft-potato.github.io/repository/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-08-19T06:07:37.000Z","updated":"2020-08-19T06:07:59.548Z","comments":true,"path":"contact/index.html","permalink":"https://ubisoft-potato.github.io/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"Netty 客户端开发连接池","slug":"Netty-客户端开发连接池","date":"2020-08-20T04:57:50.000Z","updated":"2020-08-20T05:20:56.663Z","comments":true,"path":"2020/08/20/netty-ke-hu-duan-kai-fa-lian-jie-chi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/20/netty-ke-hu-duan-kai-fa-lian-jie-chi/","excerpt":"","text":"使用Netty提供的连接池通常来说，使用netty开发服务端应用不需要使用到连接池来管理客户端与服务端的连接，但是在客户端开发中，在发送请求时就新开一个Tcp连接会导致性能低下，所以在web开发中我们会使用到Druid这样的数据库连接池。Netty在4.0.28.Final 版本发布时添加了ChannelPool接口，方便开发客户端池化Channel，以此减少重复代码。在Reactor-netty中就使用到了ChannelPool来开发它自己的HttpClient官方提供的使用案例public static void main(string[] args){ EventLoopGroup group = new NioEventLoopGroup(); final Bootstrap cb = new Bootstrap(); InetSocketAddress addr1 = new InetSocketAddress(\"10.0.0.10\", 8888); InetSocketAddress addr2 = new InetSocketAddress(\"10.0.0.11\", 8888); cb.group(group).channel(NioSocketChannel.class); ChannelPoolMap&lt;InetSocketAddress, SimpleChannelPool> poolMap = new AbstractChannelPoolMap&lt;InetSocketAddress, SimpleChannelPool>() { @Override protected SimpleChannelPool newPool(InetSocketAddress key) { return new SimpleChannelPool(cb.remoteAddress(key), new TestChannelPoolHandler()); } }; // depending on when you use addr1 or addr2 you will get different pools. final SimpleChannelPool pool = poolMap.get(addr1); Future&lt;Channel> f = pool.acquire(); f.addListener(new FutureListener&lt;Channel>() { @Override public void operationComplete(Future&lt;Channel> f) { if (f.isSuccess()) { Channel ch = f.getNow(); // Do somethings // ... // ... // Release back to pool pool.release(ch); } } }); }TIP：ChannelPoolMap的key可以是任何对象，所以极其灵活，比如它还可以是不同的EventLoopChannelPool与channelGroup的区别ChannelPool是用来实现池化操作，像是数据库连接池、httpClient等，而channelGroup是用来实现广播或者批量操作，比如一次性关闭同一个组中的所有Channel或者是同时发送一条消息到同一个组中的所有Channel。","categories":[{"name":"Netty","slug":"Netty","permalink":"https://ubisoft-potato.github.io/categories/Netty/"}],"tags":[{"name":"connectionPool","slug":"connectionPool","permalink":"https://ubisoft-potato.github.io/tags/connectionPool/"}]},{"title":"ApplicationContext额外的功能","slug":"ApplicationContext额外的功能","date":"2020-08-19T04:42:43.000Z","updated":"2020-08-19T07:38:54.389Z","comments":true,"path":"2020/08/19/applicationcontext-e-wai-de-gong-neng/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/applicationcontext-e-wai-de-gong-neng/","excerpt":"","text":"ApplicationContext额外的功能org.springframework.beans.factory 包提供了管理和使用bean的基本功能， org.springframework.context 包下添加了继承BeanFactory的ApplicationContext接口，其提供了额外的应用级功能ApplicationContext提供了如下功能：通过MessageSource接口进行国际化通过ResourceLoader接口获取URLs或者文件等资源事件发布，通过ApplicationEventPublisher通知实现ApplicationListener接口的bean加载多个上下文环境（继承关系），通过HierarchicalBeanFactory使得每一个context能专注于其功能项，比如web应用的前端控制器层。使用 MessageSource进行国际化ApplicationContext接口继承了MessageSource接口，因此ApplicationContext能够提供国际化的功能，Spring也提供HierarchicalMessageSource来支持分层处理国际化，接口定义的方法包括：String getMessage(String code, Object[] args, String default, Locale loc): 从 MessageSource中获取国际化消息的基本方法。如果没有找到相应的国际化消息结果，则使用默认的值。使用 MessageFormat进行参数位置替换。String getMessage(String code, Object[] args, Locale loc): 本质上和以上方法一样，唯一不同是不提供默认值，如果未找到则抛出 NoSuchMessageExceptionString getMessage(MessageSourceResolvable resolvable, Locale locale): 上述方法使用到的参数被封装到 MessageSourceResolvable当ApplicationContext被加载时，会自动查询容器中的MessageSourcebean，并且这个bean的名字必须为messageSource，如果找到MessageSourcebean，所有相关的方法都会被代理到这个bean实现，如果未找到，ApplicationContext会查询其父容器中的messageSourcebean，如果未找到任何messageSourcebean，将会实例化DelegatingMessageSource进行使用。spring提供了2个MessageSource实现类： ResourceBundleMessageSource 和 StaticMessageSource。并且都实现了HierarchicalMessageSource接口来实现消息合并国际化处理，StaticMessageSource使用的比较少，ResourceBundleMessageSource案例：&lt;beans> &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"> &lt;property name=\"basenames\"> &lt;list> &lt;value>format&lt;/value> &lt;value>exceptions&lt;/value> &lt;value>windows&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;/beans>以上表示类路径下有3个资源集合： format, exceptions， windows ，任何请求都将通过ResourceBundle – JDK的标准方式进行国际化处理。国际化文件编写案例: # in format.properties message=Alligators rock! # in exceptions.properties argument.required=The {0} argument is required.通过代码使用MessageSource接口，记住：ApplicationContext实现了MessageSource接口，可以被强转为MessageSourcepublic static void main(String[] args) { MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\"); String message = resources.getMessage(\"message\", null, \"Default\", Locale.ENGLISH); System.out.println(message); }结果：Alligators rock!解析：上述MessageSource定义在beans.xml中，messageSourcebean通过basenames指定国际化资源文件。上述指定了3个文件： format.properties, exceptions.properties, windows.propertiesMessageSource获取使用参数：&lt;beans> &lt;!-- this MessageSource is being used in a web application --> &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"> &lt;property name=\"basename\" value=\"exceptions\"/> &lt;/bean> &lt;!-- lets inject the above MessageSource into this POJO --> &lt;bean id=\"example\" class=\"com.something.Example\"> &lt;property name=\"messages\" ref=\"messageSource\"/> &lt;/bean> &lt;/beans>public class Example { private MessageSource messages; public void setMessages(MessageSource messages) { this.messages = messages; } public void execute() { String message = this.messages.getMessage(\"argument.required\", new Object [] {\"userDao\"}, \"Required\", Locale.ENGLISH); System.out.println(message); } }结果如下：The userDao argument is required.如果想要进行英国的国际化(en-GB），需要创建 format_en_GB.properties, exceptions_en_GB.properties, windows_en_GB.properties。比如：# in exceptions_en_GB.properties argument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.public static void main(final String[] args) { MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\"); String message = resources.getMessage(\"argument.required\", new Object [] {\"userDao\"}, \"Required\", Locale.UK); System.out.println(message); } 结果如下：Ebagum lad, the &#39;userDao&#39; argument is required, I say, required.也可以使用 MessageSourceAware 接口来获取MessageSource对象，ApplicationContext中任何实现MessageSourceAware接口的对象在创建和被配置的时候都将被注入MessageSource对象。tips：ResourceBundleMessageSource的一个可选实现是ReloadableResourceBundleMessageSource，ReloadableResourceBundleMessageSource比基于JDK的ResourceBundleMessageSource更加灵活，尤其是支持从任何spring资源加载位置读取（不仅仅是类路径）以及支持热加载， 详情：ReloadableResourceBundleMessageSource标准和自定义事件ApplicationContext通过ApplicationEvent和ApplicationListener提供事件处理机制，如果容器中一个bean实现了ApplicationListener接口,每当有ApplicationEvent发布到ApplicationContext中就会通知此bean，本质上这就是观察者模式的实现。Spring 4.2之后，事件机制得到增强，Spring提供了注解开发模式以及事件不再必须实现ApplicationEvent接口，当发布事件时，Spring自动将其封装为ApplicationEvent。Spring提供的标准事件：EventExplanationContextRefreshedEventPublished when the ApplicationContext is initialized or refreshed (for example, by using the refresh() method on the ConfigurableApplicationContext interface). Here, “initialized” means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the ApplicationContext object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen ApplicationContext actually supports such “hot” refreshes. For example, XmlWebApplicationContext supports hot refreshes, but GenericApplicationContext does not.ContextStartedEventPublished when the ApplicationContext is started by using the start() method on the ConfigurableApplicationContext interface. Here, “started” means that all Lifecycle beans receive an explicit start signal. Typically, this signal is used to restart beans after an explicit stop, but it may also be used to start components that have not been configured for autostart (for example, components that have not already started on initialization).ContextStoppedEventPublished when the ApplicationContext is stopped by using the stop() method on the ConfigurableApplicationContext interface. Here, “stopped” means that all Lifecycle beans receive an explicit stop signal. A stopped context may be restarted through a start() call.ContextClosedEventPublished when the ApplicationContext is being closed by using the close() method on the ConfigurableApplicationContext interface or via a JVM shutdown hook. Here, “closed” means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted.RequestHandledEventA web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring’s DispatcherServlet.ServletRequestHandledEventA subclass of RequestHandledEvent that adds Servlet-specific context information.自定义事件案例：public class BlockedListEvent extends ApplicationEvent { private final String address; private final String content; public BlockedListEvent(Object source, String address, String content) { super(source); this.address = address; this.content = content; } // accessor and other methods... }发布事件需要调用ApplicationEventPublisher的 publishEvent() 方法，通常的做法是实现ApplicationEventPublisherAware接口，并将其注册为spring bean：public class EmailService implements ApplicationEventPublisherAware { private List&lt;String> blockedList; private ApplicationEventPublisher publisher; public void setBlockedList(List&lt;String> blockedList) { this.blockedList = blockedList; } // 重写 setApplicationEventPublisher方法获取ApplicationEventPublisher public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { this.publisher = publisher; } public void sendEmail(String address, String content) { if (blockedList.contains(address)) { publisher.publishEvent(new BlockedListEvent(this, address, content)); return; } // send email... } }在Spring容器的配置期间，检测到EmailService实现了ApplicationEventPublisherAware接口，会自动调用setApplicationEventPublisher()方法，Spring会自动填充其参数，所以我们可以通过ApplicationEventPublisher与Spring容器交互。为了能监听ApplicationEvent事件，需要实现ApplicationListener并将其注册为Spring bean：public class BlockedListNotifier implements ApplicationListener&lt;BlockedListEvent> { private String notificationAddress; public void setNotificationAddress(String notificationAddress) { this.notificationAddress = notificationAddress; } public void onApplicationEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress... } }ApplicationListener带有范型，意味着onApplicationEvent()方法不需要我们进行强转，我们可以注册许多监听器，但是默认情况下监听器是同步接受事件的，也就是说 publishEvent() 在直到所有监听器被执行完之前是一只阻塞的，好处就是能在同一线程中执行，并且如果存在事务环境，也能保持一致。如果需要使用其他策略，考虑 ApplicationEventMulticaster以及实现类 SimpleApplicationEventMulticaster注册以上的bean进行使用：&lt;bean id=\"emailService\" class=\"example.EmailService\"> &lt;property name=\"blockedList\"> &lt;list> &lt;value>known.spammer@example.org&lt;/value> &lt;value>known.hacker@example.org&lt;/value> &lt;value>john.doe@example.org&lt;/value> &lt;/list> &lt;/property> &lt;/bean> &lt;bean id=\"blockedListNotifier\" class=\"example.BlockedListNotifier\"> &lt;property name=\"notificationAddress\" value=\"blockedlist@example.org\"/> &lt;/bean>当emailService的 sendEmail() 被调用时，如果有黑名单中的邮件，则会发布BlockedListEvent，blockedListNotifier就会被通知spring的事件机制的设计是被用来处理同一个ApllicationContext中的Bean进行交互的，如果需要更加复杂的交互能力需要使用Spring Integration ，能够构建轻量级、基于事件驱动的应用基于注解的事件监听Spring 4.2之后能够在任何Bean中的public方法上加上@EventListener注解完成事件监听，blockedListNotifier重新实现：public class BlockedListNotifier { private String notificationAddress; public void setNotificationAddress(String notificationAddress) { this.notificationAddress = notificationAddress; } @EventListener public void processBlockedListEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress... } }如果方法需要监听多个事件，并且想使用无参方法，也可以将事件声明到注解中：@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class}) public void handleContextStart() { // ... }还能够使用注解的condition属性进行事件过滤，并且是使用 SpEL expression （Spring表达式）条件配置：@EventListener(condition = \"#blEvent.content == 'my-event'\") // 只有当BlockedListEvent事件中的content属性为my-event时才进行调用 public void processBlockedListEvent(BlockedListEvent blockedListEvent) { // notify appropriate parties via notificationAddress... }事件上下文环境可用的元数据信息：NameLocationDescriptionExampleEventroot objectThe actual ApplicationEvent.#root.event or eventArguments arrayroot objectThe arguments (as an object array) used to invoke the method.#root.args or args; args[0] to access the first argument, etc.Argument nameevaluation contextThe name of any of the method arguments. If, for some reason, the names are not available (for example, because there is no debug information in the compiled byte code), individual arguments are also available using the #a&lt;#arg&gt; syntax where &lt;#arg&gt; stands for the argument index (starting from 0).#blEvent or #a0 (you can also use #p0 or #p&lt;#arg&gt; parameter notation as an alias)#root.event能获取到底层的事件，即使监听方法签名参数接收的是自定义事件。在处理完一个事件后，如果需要继续发布事件，只需要修改方法返回值即可：@EventListener public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress and // then publish a ListUpdateEvent... }但是此用法不支持异步调用监听器这个方法在美处理完一个BlockedListEvent事件后发布ListUpdateEvent事件，如果需要发布多个事件可以返回事件的Collection。异步监听器只需在监听方法上加 @Async 注解就能 完成异步监听：@EventListener @Async public void processBlockedListEvent(BlockedListEvent event) { // BlockedListEvent is processed in a separate thread }使用异步监听器的局限性：如果异步监听器抛出异常，并不会被传递到调用者，详情参考AsyncUncaughtExceptionHandler异步监听器方法不支持上述发布连续的事件，如果需要进行发布连续事件，需要注入 ApplicationEventPublisher 进行手动发布监听器的执行顺序添加@Order注解进行顺序编排：@EventListener @Order(42) public void processBlockedListEvent(BlockedListEvent event) { // notify appropriate parties via notificationAddress... }通用事件在某些情况下，如果所有事件都遵循相同的结构，这可能会变得很通用性（就像前面示例中的事件一样）。 在这种情况下，可以实现ResolvableTypeProvider来指导框架获取运行时类型：public class EntityCreatedEvent&lt;T> extends ApplicationEvent implements ResolvableTypeProvider { public EntityCreatedEvent(T entity) { super(entity); } @Override public ResolvableType getResolvableType() { return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource())); } }使用 EntityCreatedEvent&lt;T&gt; 构造通用的事件，其中T是实际的事件实体，比如：只接收EntityCreatedEvent事件的监听器：@EventListener public void onPersonCreated(EntityCreatedEvent&lt;Person> event) { // ... }这不光对ApplicationEvent有效，而且可以是任意事件对象","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"ioc 容器","slug":"ioc-容器","date":"2020-08-19T04:39:08.000Z","updated":"2020-08-20T05:06:01.976Z","comments":true,"path":"2020/08/19/ioc-rong-qi/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/ioc-rong-qi/","excerpt":"","text":"介绍IoC容器​ IoC容器也被称为依赖注入（DI，dependency injection）。这就是一个过程，在这个过程中，对象通过构造器参数、工厂方法参数或者是工厂方法返回后的对象上的属性来定义依赖项。IoC容器会在创建这些bean的时候注入这些依赖，这个过程完全是交由容器处理（正如其名：控制反转）。​ org.springframework.beans 和 org.springframework.context 包下的类是IoC 容器的基础。 BeanFactory 提供了管理任何类型对象的高级配置机制。 ApplicationContext 是 BeanFactory的子接口，它添加了以下功能：集成Spring AOP特性国际化（i18n）事件发布（ApllicationEvent）应用级容器，例如： WebApplicationContext 构建web应用总而言之，BeanFactory提供了配置框架和基本功能，ApllicationContext则提供了更多企业级的功能。ApllicationContext完全是扩展自BeanFactory （子集关系）。在spring中，被springIoC容器所管理的、组成应用的对象就叫Spring Bean，一个Bean会被Spring IoC容器所实例化、收集和管理。除此之外，bean只是我们应用容器中许多对象的其中之一。Bean之间的依赖关系通过容器中的配置元数据（BeanDefinition）进行展示。容器概览org.springframework.context.ApplicationContext 接口呈现了IoC容器并且负责实例化、配置、收集Bean。容器会通过读取配置元数据来进行实例化、配置和收集Bean。配置元数据可以通过XML、Java注解、Java代码来定义。通过定义可以让我们表示组成应用的对象信息以及对象之间的内部依赖关系。Sprin提供了ApllicationContext的许多实现类，在标准的独立应用中，创建 ClassPathXmlApplicationContext 或者 FileSystemXmlApplicationContext 是常见的选择。尽管XML是定义配置元数据的传统格式，但是我们可以通过提供少量XML配置来声明式地启用对这些其他配置元数据格式的支持，从而指示容器将Java注释或代码用作元数据格式。在大多数应用场景下，不需要用户显式的创建一个或多个Spring IoC容器。下图展示了spring是如何工作的，我们的应用Java类和配置元数据被整合在一起，在创建完ApllicationContext后，将会得到一个完全可配置并且可执行的系统或应用程序。配置元数据像上图所展示的，Spring IoC容器会使用一系列配置元数据，配置元数据能让开发者定义Spring容器如何实例化、配置、收集应用程序中的对象。配置元数据支持以XML格式定义，但是当今许多开发者选择使用基于Java的配置方式。使用其他形式配置：基于注解配置: Spring 2.5 支持基于注解配置基于Java配置: Spring 3.0开始,SpringJava配置项目提供的新特性被加入到Spring的核心框架中。这样就不仅可以使用XML配置还能使用新特性： @Configuration, @Bean, @Import, @DependsOn 注解Spring配置必须又至少管理了一个Bean定义的容器组成。XML通常使用标签定义，而Java配置则通常使用@Bean注解被@configuration类的方法上来定义这些bean定义对应的真实对象组成了应用程序，通常来说，我们定义的服务层、DAO、表述层对象，应用基础对象。通常，不会在容器中配置细粒度的域对象，因为DAO和业务逻辑通常负责创建和加载域对象。如果要配置IoC容器之外的对象可以使用Spring Aspectj整合&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"...\" class=\"...\"> &lt;!-- collaborators and configuration for this bean go here --> &lt;/bean> &lt;bean id=\"...\" class=\"...\"> &lt;!-- collaborators and configuration for this bean go here --> &lt;/bean> &lt;!-- more bean definitions go here --> &lt;/beans>id是Bean定义的唯一标识class定义了bean的类型，使用全类名实例化一个IoC容器ApplicationContext可以从多种外部资源进行加载，比如：本地文件系统，Java类路径等等。public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); }组合XML配置分多个XML文件配置Bean definition是十分有用的，每个XML都可以独立呈现应用程序的逻辑或者模块可以使用application context的接受多个Resource参数的方法来加载多个XML定义，也可以使用标签来加载其他XML文件：&lt;beans> &lt;import resource=\"services.xml\"/> &lt;import resource=\"resources/messageSource.xml\"/> &lt;import resource=\"/resources/themeSource.xml\"/> &lt;bean id=\"bean1\" class=\"...\"/> &lt;bean id=\"bean2\" class=\"...\"/> &lt;/beans>以上配置加载了三个文件：services.xml, messageSource.xml, themeSource.xml。services.xml地址都是相对路径，所以services.xml文件必须在同一个目录下活类路径下，而 messageSource.xml 和 themeSource.xml 必须在resources目录下。能发下的是：地址开头的“/”已经被忽略了，所以鉴于这些路径是相对路径，最好不要使用斜线开头。TIPS：虽然能使用“../”来获取上级目录但是并不是被推荐的方式，这样做会依赖应用外部的文件，更不建议在类路径中使用：比如classpath:../services.xml,如果类路径配置改变将会导致不同的，不正确的目录。也可以使用绝对路径而不是相对路径file:C:/config/services.xml或者 classpath:/config/services.xml但是要注意到应用程序已经耦合了文件系统绝对路径，通常使用绝对路径更好的做法是使用占位符，通过在运行时针对JVM系统属性解析的“ $ {…}”占位符。使用容器ApplicationContext 是一个管理不同bean注册以及它们的依赖的高级工厂接口类，通过使用T getBean(String name, Class&lt;T&gt; requiredType)可以得到想要的实例。ApplicationContext能够让开发者读取bean定义的信息，并访问它们：// create and configure beans ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); // retrieve configured instance PetStoreService service = context.getBean(\"petStore\", PetStoreService.class); // use configured instance List&lt;String> userList = service.getUsernameList();我们可以使用getBean来获取bean，ApplicationContext还有许多获取bean的方法，但是我们的业务代码最好不要使用它们，这样就不会依赖spring的api。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"spring bean","slug":"spring-bean","date":"2020-08-19T03:11:21.000Z","updated":"2020-08-19T14:40:33.307Z","comments":true,"path":"2020/08/19/spring-bean/","link":"","permalink":"https://ubisoft-potato.github.io/2020/08/19/spring-bean/","excerpt":"","text":"Spring BeanSpring容器管理了一个或者多个bean，这些bean是更具bean定义元数据进行创建的。在Spring容器内部，bean定义元数据以BeanDefinition对象呈现，包含以下信息：类的全类名定义bean在容器中的行为的配置元素，比如：bean作用域、生命周期回掉方法等被当前bean所引用的bean其他配置-比如：连接池的大小这些元数据会翻译为一系列属性组成BeanDefinition：属性官方说明链接ClassInstantiating BeansNameNaming BeansScopeBean ScopesConstructor argumentsDependency InjectionPropertiesDependency InjectionAutowiring modeAutowiring CollaboratorsLazy initialization modeLazy-initialized BeansInitialization methodInitialization CallbacksDestruction methodDestruction CallbacksBeanDefinition包含了如何准确创建一个bean的信息，ApplicationContext也允许用户注册在容器外部创建的对象。可以通过getBeanFactory()来获取ApplicationContext内部聚合的BeanFactory来做到，其返回BeanFactory实现类为DefaultListableBeanFactory，DefaultListableBeanFactory支持通过registerSingleton(..)和registerBeanDefinition(..)方法进行注册TIPS： 为了能让Spring容器在自动装盘时正确的理解bean的意图，Bean元数据和手动注册的单实例对象应该被尽可能早地执行。虽然在某种程度上支持覆盖现有Bean元数据和现有单例实例，但是在运行时（与对工厂的实时访问同时）对新bean的注册不被Spring支持，并且可能导致并发访问异常，bean容器中的状态不一致。bean的命名任何一个bean都有一个或多个标识符，这些标识符在持有这些bean的容器中必须唯一，通常一个bean只有一个标识符，如果要求有多个，可以考虑起别名。使用XML进行配置时，我们使用id和name属性进行指定bean的标识符，id能指定唯一的标识，这些都是由字母数字组成的(‘myBean’, ‘someService’等)，也能包含特殊的字符，如果需要起一些别名，则使用name属性进行定义，使用逗号，分号或空格进行分隔。但id必须唯一。如果没有指定id和name，容器会为bean自动生成一个唯一的标识符。bean命名惯例：bean的名称默认使用首单词的首字母小写，其余的单词首字母都是大写，比如：accountManager,accountService,userDao,loginController等。bean的命名能够使得应用的配置更加简单和易读，如果使用Spring Aop，能够更方便的通过bean的名称进行的切面定义。TIPS:通过在类路径中进行组件扫描，Spring会按照前面描述的规则为未命名的组件生成Bean名称：从本质上讲，将采用简单的类名称并将其首字符转换为小写。 但是，在（不寻常的）特殊情况下，如果有多个字符且第一个和第二个字符均为大写字母，则会保留原始大小写。在BeanDefinition之外给bean取别名我们可以通过BeanDefinition给bean定义一个或多个名称，通过id属性定义唯一标识符和name属性定义多个别名。但是，在实际定义bean的地方指定所有别名并不能满足需求。 有时需要为在别处定义的bean引入别名。 在大型系统中通常是这种情况，在大型系统中，配置在每个子系统之间分配，每个子系统都有自己的对象定义集。&lt;alias name=\"fromName\" alias=\"toName\"/> 使用XML的标签进行起别名给fromName的bean起一个toName的别名。比如：A系统通过subsystemA-dataSource来引用一个Datasource对象，B系统通过subsystemB-dataSource来引用DataSource对象，当组合这2个子系统为一个系统时，主应用使用myApp-dataSource来进行引用，这种情况可以使用以下配置：&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt; &lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;实例化bean一个beanDefinition可以创建一个或多个对象，容器在被查询时会查看命名bean的定义，并使用该bean定义封装的配置元数据来创建（或获取）实际对象。如果使用XML定义Bean元数据，通常需要指定标签中的class属性class属性对应BeanDefinition中的Class字段。Class字段有2种用法:通常，在容器本身通过反射机制调用其构造函数直接创建Bean的情况下，指定要构造的Bean类型，这在某种程度上等同于使用new运算符的Java代码。要指定包含用于创建对象的静态工厂方法的实际类，在不太常见的情况下，容器将在类上调用静态工厂方法以创建Bean。 从静态工厂方法的调用返回的对象类型可以是同一类，也可以是完全不同的另一类。内部类：如果需要配置类的内部静态类的bean定义，必须要使用类的组合名称，比如：在 com.example 包下有一个叫SomeThing的类，在其内部有一个叫OtherThing的内部静态类，则其beanDefinition的class属性将会是com.example.SomeThing$OtherThing,$被用来作为内部类和外部类的分隔。使用构造器初始化当通过构造方法创建一个bean时，所有普通类都可以被Spring使用并兼容。 也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。 只需指定bean类就足够了。 但是，根据用于该特定bean的IoC类型，可能需要一个默认（空）构造函数。Spring IoC容器几乎可以管理任何类。 它不仅限于管理真正的JavaBean。 大多数Spring用户更喜欢实际的JavaBean，它们仅具有默认（无参数）构造函数，并具有根据容器中的属性建模的适当的setter和getter。 还可以在容器中包含更多奇特的非bean样式类。 例如，如果需要使用绝对不符合JavaBean规范的旧式连接池，则Spring也可以对其进行管理。&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"/> &lt;bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/>使用静态工厂方法进行实例化可以使用class属性来指定包含静态工厂方法的的类，使用factory-method属性来指定工厂方法的名字。&lt;bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/> public class ClientService { private static ClientService clientService = new ClientService(); private ClientService() {} public static ClientService createInstance() { return clientService; } }使用实例工厂方法使用已存在的bean的非静态工厂方法创建新的bean：&lt;!-- the factory bean, which contains a method called createInstance() --> &lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"> &lt;!-- inject any dependencies required by this locator bean --> &lt;/bean> &lt;!-- the bean to be created via the factory bean --> &lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/>public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } }工厂类也能拥有多个工厂方法：&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"> &lt;!-- inject any dependencies required by this locator bean --> &lt;/bean> &lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/> &lt;bean id=\"accountService\" factory-bean=\"serviceLocator\" factory-method=\"createAccountServiceInstance\"/>public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } public AccountService createAccountServiceInstance() { return accountService; } }这种方式说明工厂bean本省可以被容器管理和通过DI配置。决定bean的运行时类型确定特定bean的运行时类型并非易事。 Bean元数据定义中的指定类只是初始类引用，可能与声明的工厂方法结合使用，或者是FactoryBean类，这可能导致Bean的运行时类型不同，或者在实例的情况下根本不进行设置 工厂方法（通过指定的factory-bean名称解析）。 此外，AOP代理可以使用基于接口的代理包装Bean实例，而目标Bean的实际类型（仅是其实现的接口）的暴露程度有限。建议使用BeanFactory.getType获取运行时bean的类型。","categories":[{"name":"spring","slug":"spring","permalink":"https://ubisoft-potato.github.io/categories/spring/"}],"tags":[{"name":"spring core","slug":"spring-core","permalink":"https://ubisoft-potato.github.io/tags/spring-core/"}]},{"title":"k3s中使用configmap灵活配置","slug":"k3s中使用configmap灵活配置","date":"2019-12-07T09:15:39.000Z","updated":"2020-08-19T14:30:16.067Z","comments":true,"path":"2019/12/07/k3s-zhong-shi-yong-configmap-ling-huo-pei-zhi/","link":"","permalink":"https://ubisoft-potato.github.io/2019/12/07/k3s-zhong-shi-yong-configmap-ling-huo-pei-zhi/","excerpt":"使用configmap前所遇到的问题在微服务横行的时代，一个系统被拆分成多个子系统，使得每个子系统各自有一套自己管理的配置， 使得配置管理难度加大，springcloud的解决方案是spring config，可以通过github等集中托管各服务配置， 集群化部署有比spring config更简单的解决方案：k8s configmap","text":"使用configmap前所遇到的问题在微服务横行的时代，一个系统被拆分成多个子系统，使得每个子系统各自有一套自己管理的配置， 使得配置管理难度加大，springcloud的解决方案是spring config，可以通过github等集中托管各服务配置， 集群化部署有比spring config更简单的解决方案：k8s configmap什么是configmapConfigMap 是k8s集群中的一种资源类型，并且ConfigMap会将配置数据作为k-v键值对存储，存储的数据可以被集群中的pod消费。通过configMap我们可以将springboot的配置文件集中管理在一个k8s名称空间下，这样就可以统一管理所有容器配置创建configMap使用kubectl命令创建:kubectl create configmap &lt;map-name&gt; &lt;data-source&gt; -n &lt;namespace&gt;其中可以是存放配置文件的目录或者就是配置文件，是创建的configMap的名字, &lt; namespace &gt;为指定的名称空间名。例子：# 创建本地目录 mkdir -p /config # 下载事例配置 wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties kubectl create configmap testConfigMap --from-file=/config/ -n dev上述命令为使用/config 目录下的所有配置文件在dev名称空间创建名为 testConfigMap的configMap资源查看创建完的configmap:kubectl describe configmap testConfigMap -n dev kubectl get configmap testConfigMap -o yaml -n dev查看dev名称空间下名叫testConfigMap的configMap，如果按照上述操作，结果应该如下：Name: game-config Namespace: dev Labels: &lt;none&gt; Annotations: &lt;none&gt; Data ==== game.properties: 158 bytes ui.properties: 83 bytes使用第二条命令则更详细：apiVersion: v1 kind: ConfigMap metadata: creationTimestamp: 2016-02-18T18:52:05Z name: game-config namespace: dev resourceVersion: \"516\" uid: b4952dc3-d670-11e5-8cd0-68f728db1985 data: game.properties: | enemies=aliens lives=3 enemies.cheat=true enemies.cheat.level=noGoodRotten secret.code.passphrase=UUDDLRLRBABAS secret.code.allowed=true secret.code.lives=30 ui.properties: | color.good=purple color.bad=yellow allow.textmode=true how.nice.to.look=fairlyNice通过上述操作可以发现，使用命令创建后，configmap中的key即为配置文件的名字，所以使用起来也非常方便创建configMap还可以通过yaml配置文件的方式创建，不再详细说明，通过文件方式更为通用configMap的应用创建好configMap就要使用到实际应用中，pod可以直接使用集群中的configMap资源，通常来说有2种应用：1、作为pod中的环境变量导入 2、作为pod中的loume挂载，将configMap的key对应的数据变成文件挂载到pod中的指定位置要集中管理springboot配置文件，使用第2种营业员方式：创建configMap，其中有2个配置文件 apiVersion: v1 kind: ConfigMap metadata: name: special-config namespace: default data: SPECIAL_LEVEL: very SPECIAL_TYPE: charm --- 将配置文件挂载到pod的/etc/config 目录下 apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config/&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: # Provide the name of the ConfigMap containing the files you want # to add to the container name: special-config restartPolicy: Never当pod创建并启动后，会输出如下结果：SPECIAL_LEVEL SPECIAL_TYPE说明configMap中的key作为了文件名，值作为文件内容。注意：这种挂载方式会清空 pod中/etc/config目录下原有的所有文件，再将配置文件挂载进去， 如果不想原来的配置被删除可以使用subPath的挂载方式，修改如下：apiVersion: v1 kind: Pod metadata: name: dapi-test-pod spec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config/&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config/SPECIAL_LEVEL subPath: SPECIAL_LEVEL volumes: - name: config-volume configMap: name: special-config items: - key: SPECIAL_LEVEL path: SPECIAL_LEVEL restartPolicy: Never通过subPath的挂载方式，原来pod目录里的文件就不会被删除","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"configmap","slug":"configmap","permalink":"https://ubisoft-potato.github.io/tags/configmap/"}]},{"title":"k3s配置ingress使用ssl证书","slug":"k3s配置ingress使用ssl证书","date":"2019-11-03T06:39:03.000Z","updated":"2020-08-19T06:58:43.367Z","comments":true,"path":"2019/11/03/k3s-pei-zhi-ingress-shi-yong-ssl-zheng-shu/","link":"","permalink":"https://ubisoft-potato.github.io/2019/11/03/k3s-pei-zhi-ingress-shi-yong-ssl-zheng-shu/","excerpt":"What is Ingress?Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. internet | [ Ingress ] --|-----|-- [ Services ] Ingress暴露了从集群外部到集群内服务的HTTP和HTTPS路由。流量路由由Ingress资源上定义的规则控制。 可以将Ingress配置为提供服务外部可访问的URL，负载平衡流量，并提供基于SSL / TLS的虚拟主机。 入口控制器通常通过负载平衡器负责实现入口，尽管它也可以配置边缘路由器或其他前端以帮助处理流量。","text":"What is Ingress?Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. internet | [ Ingress ] --|-----|-- [ Services ] Ingress暴露了从集群外部到集群内服务的HTTP和HTTPS路由。流量路由由Ingress资源上定义的规则控制。 可以将Ingress配置为提供服务外部可访问的URL，负载平衡流量，并提供基于SSL / TLS的虚拟主机。 入口控制器通常通过负载平衡器负责实现入口，尽管它也可以配置边缘路由器或其他前端以帮助处理流量。说白了ingress的功能就是类是于反向代理，能够做到像nginx一样的反代的功能，控制流量，并有负载均衡的能力，本文主要讨论如何在k3s集群中配置https证书注意：k3s集群默认使用traefik来实现反向代理，但也支持使用nginx来作为 ingress controller 来实现反向代理配置http ingresskind: Ingress apiVersion: networking.k8s.io/v1beta1 metadata: name: test-ingress annotations: kubernetes.io/ingress.class: traefik traefik.frontend.rule.type: PathPrefixStrip spec: rules: # 这里可以配置多个域名代理规则 - host: xxx # 域名 http: paths: - backend: serviceName: service-01 servicePort: 8080 - host: xxx # 域名 http: paths: - backend: serviceName: service-02 servicePort: 8080执行: kubectl apply -f ingress.yaml ,创建ingress。 [root@hostname ~]# kubectl get ingress NAME HOSTS ADDRESS PORTS AGE test-ingress xxxxx,xxxx 172.17.19.115 80 6h15m 可以看到 端口为80，说明ingress已经为指定的service做好http代理为ingress配置https首先配置k3s secretapiVersion: v1 kind: Secret metadata: name: testsecret-tls namespace: default data: tls.crt: base64 encoded cert #此处必须为base64 加密后的证书 可使用 cat xxx.pem | base64 命令得到 tls.key: base64 encoded key #此处必须为base64 加密后的密钥 可使用 cat xxx.key | base64 命令得到 type: kubernetes.io/tlskind: Ingress apiVersion: networking.k8s.io/v1beta1 metadata: name: test-ingress namespace: default # ingress要和secret在同一个名称空间下 annotations: kubernetes.io/ingress.class: traefik traefik.frontend.rule.type: PathPrefixStrip # http 重定向到 https ingress.kubernetes.io/ssl-redirect: \"True\" spec: tls: - hosts: - xxxx.xxxx # 这里是下面要配置https的域名 - xxxx.xxxx # 这里是下面要配置https的域名 secretName: testsecret-tls rules: # 这里可以配置多个域名代理规则 - host: xxx # 域名 http: paths: - backend: serviceName: service-01 servicePort: 8080 - host: xxx # 域名 http: paths: - backend: serviceName: service-02 servicePort: 8080先后执行： kubectl apply -f secret.yaml kubectl apply -f ingress.yaml ----------------------------------------------------- 查看 secret : kubectl get secret [root@hostname ~]# kubectl get secret NAME TYPE DATA AGE default-token-d25kq kubernetes.io/service-account-token 3 10h testsecret-tls kubernetes.io/tls 2 7h25m 第二行为我们所创建的证书的secret对象 ------------------------------------------------------ 查看ingress: kubectl get ingress [root@hostname ~]# kubectl get ingress NAME HOSTS ADDRESS PORTS AGE test-ingress xxx.xxx,xxx.xxx 172.17.19.115 80, 443 7h26m 可以看到 端口已经添加了443如果操作无误，这时访问我们的域名已经是变成了https，并且访问http也会被重定向到https","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"ingress","slug":"ingress","permalink":"https://ubisoft-potato.github.io/tags/ingress/"},{"name":"ssl","slug":"ssl","permalink":"https://ubisoft-potato.github.io/tags/ssl/"}]},{"title":"docker入门","slug":"docker入门","date":"2019-11-01T13:44:27.000Z","updated":"2020-08-19T02:46:13.235Z","comments":true,"path":"2019/11/01/docker-ru-men/","link":"","permalink":"https://ubisoft-potato.github.io/2019/11/01/docker-ru-men/","excerpt":"什么是docker？Docker is a set of platform-as-a-service products that use OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. --wikiDocker是一组平台即服务产品，它们使用操作系统级虚拟化并被称为容器的软件包交付软件。 容器彼此隔离，并将它们自己的软件，库和配置文件捆绑在一起； 他们可以通过定义明确的渠道相互通信。","text":"什么是docker？Docker is a set of platform-as-a-service products that use OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. --wikiDocker是一组平台即服务产品，它们使用操作系统级虚拟化并被称为容器的软件包交付软件。 容器彼此隔离，并将它们自己的软件，库和配置文件捆绑在一起； 他们可以通过定义明确的渠道相互通信。docker基本概念容器–什么是容器What is a Container? A standardized unit of software容器是标准的软件单元（可独立运行的） ，传统的软件部署方式，需要将软件打包，并在部署之前，要在操作系统上安装相关依赖，这样的部署方式使得软件的耦合度太高，并且不宜维护，而通过容器，可以将软件打包到标准化单元中，以进行开发，运输和部署，极大降低软件部署的耦合度。Why Docker?作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。docker 容器 vs 虚拟机 容器是应用程序层的抽象，将代码和依赖项打包在一起。 多个容器可以在同一台计算机上运行，​​并与其他容器共享OS内核，每个容器在用户空间中作为隔离的进程运行。 容器占用的空间少于VM（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要的VM和操作系统更少。虚拟机（VM）是将一台服务器转变为多台服务器的物理硬件的抽象。 虚拟机管理程序允许多个VM在单台计算机上运行。 每个VM包含操作系统，应用程序，必要的二进制文件和库的完整副本-占用数十GB。 VM也可能启动缓慢。基本概念Docker 包括三个基本概念镜像（Image）容器（Container）仓库（Repository）镜像Docker 镜像（Image）就是一个只读的模板。 例如：一个镜像可以包含一个完整的 Ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。 镜像可以用来创建 Docker 容器。 Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。容器Docker 利用容器（Container）来运行应用。 容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。仓库仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。 实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括时速云 、网易云等，可以提供大陆用户更稳定快速的访问。 当然，用户也可以在本地网络内创建一个私有仓库（参考本文“私有仓库”部分）。 当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库， 这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。 注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"docker基本概念","slug":"docker基本概念","permalink":"https://ubisoft-potato.github.io/tags/docker基本概念/"}]},{"title":"rancher、k3s安装记录","slug":"rancher、k3s安装记录","date":"2019-10-09T06:02:43.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/10/09/rancher-k3s-an-zhuang-ji-lu/","link":"","permalink":"https://ubisoft-potato.github.io/2019/10/09/rancher-k3s-an-zhuang-ji-lu/","excerpt":"k3s 简介k3s 是 Rancher 推出的轻量级 k8s。k3s 本身包含了 k8s 的源码，所以本质上和 k8s 没有区别。但为了降低资源占用，k3s 和 k8s 还是有一些区别的，主要是：使用了相比 Docker 更轻量的 containerd 作为容器运行时（Docker 并不是唯一的容器选择）去掉了 k8s 的 Legacy, alpha, non-default features用 sqlite3 作为默认的存储，而不是 etcd其他的一些优化，最终 k3s 只是一个 binary 文件，非常易于部署所以 k3s 适用于边缘计算，IoT 等资源紧张的场景。同时 k3s 也是非常容易部署的，官网上提供了一键部署的脚本。","text":"k3s 简介k3s 是 Rancher 推出的轻量级 k8s。k3s 本身包含了 k8s 的源码，所以本质上和 k8s 没有区别。但为了降低资源占用，k3s 和 k8s 还是有一些区别的，主要是：使用了相比 Docker 更轻量的 containerd 作为容器运行时（Docker 并不是唯一的容器选择）去掉了 k8s 的 Legacy, alpha, non-default features用 sqlite3 作为默认的存储，而不是 etcd其他的一些优化，最终 k3s 只是一个 binary 文件，非常易于部署所以 k3s 适用于边缘计算，IoT 等资源紧张的场景。同时 k3s 也是非常容易部署的，官网上提供了一键部署的脚本。下载可执行k3s 安装脚本、二进制文件 和 镜像mkdir k3s-install cd k3s-install curl -sfL https://get.k3s.io &gt; install.sh chmod +x ./install.sh wget https://github.com/rancher/k3s/releases/download/${k3s.version}/k3s wget https://github.com/rancher/k3s/releases/download/${k3s.version}/k3s-airgap-images-amd64.tar安装k3s主服务器cp ./k3s /usr/local/bin/ chmod +x /usr/local/bin/k3s mkdir -p /var/lib/rancher/k3s/agent/images/ cp ./k3s-airgap-images-amd64.tar /var/lib/rancher/k3s/agent/images/ INSTALL_K3S_SKIP_START=true INSTALL_K3S_EXEC=\"--docker\" INSTALL_K3S_BIN_DIR=\"/usr/local/bin\" INSTALL_K3S_SKIP_DOWNLOAD=true sh install.sh ln -s /usr/local/bin/k3s /usr/bin/k3s systemctl enable k3s systemctl start k3s 修改配置文件 /etc/systemd/system/k3s.service 将其中的ExecStart修改为使用dockerExecStart=/usr/local/bin/k3s server --docker运行命令，查看状态kubectl get node NAME STATUS ROLES AGE VERSION hostname Ready master 110s v1.14.5-k3s.1安装agent cp ./k3s /usr/local/bin/ chmod +x /usr/local/bin/k3s mkdir -p /var/lib/rancher/k3s/agent/images/ cp ./k3s-airgap-images-amd64.tar /var/lib/rancher/k3s/agent/images/ INSTALL_K3S_SKIP_START=true INSTALL_K3S_EXEC=\"--docker\" INSTALL_K3S_BIN_DIR=\"/usr/local/bin\" INSTALL_K3S_SKIP_DOWNLOAD=true K3S_TOKEN=XXXXX K3S_URL=https://XXXXX:6443 sh install.sh ln -s /usr/local/bin/k3s /usr/bin/k3s systemctl enable k3s-agent systemctl start k3s-agent token需要从主服务器的 /var/lib/rancher/k3s/server/node-token 获取安装控制台创建目录 /data/k3s/rancher-server/var/lib/rancherdocker run -d -v /data/k3s/rancher-server/var/lib/rancher/:/var/lib/rancher/ --restart=unless-stopped --name rancher-server -p 38080:80 -p 38443:443 rancher/rancher:stable","categories":[{"name":"k3s","slug":"k3s","permalink":"https://ubisoft-potato.github.io/categories/k3s/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/tags/docker/"},{"name":"rancher","slug":"rancher","permalink":"https://ubisoft-potato.github.io/tags/rancher/"}]},{"title":"使用docker部署文件服务ambry","slug":"使用docker部署文件服务ambry","date":"2019-10-08T13:17:30.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/10/08/shi-yong-docker-bu-shu-wen-jian-fu-wu-ambry/","link":"","permalink":"https://ubisoft-potato.github.io/2019/10/08/shi-yong-docker-bu-shu-wen-jian-fu-wu-ambry/","excerpt":"分布式文件服务ambry分布式文件服务ambry是国外著名社交软件公司 linkedin 的开源项目，ambry官网地址:https://github.com/linkedin/ambry, 可以自行查看github介绍","text":"分布式文件服务ambry分布式文件服务ambry是国外著名社交软件公司 linkedin 的开源项目，ambry官网地址:https://github.com/linkedin/ambry, 可以自行查看github介绍如何使用docker容器化部署ambryambry官方并没有相关镜像，所以自己制作ambry镜像进行部署,下面进行介绍:ambry分为服务段和前端，所以制作了2个镜像, 镜像dockerHub地址：https://hub.docker.com/r/wdnmdcyka/ambry-client, https://hub.docker.com/r/wdnmdcyka/ambry-server[root@izwz94ymqw967redc0vyeoz ~]# docker search ambry NAME DESCRIPTION STARS OFFICIAL AUTOMATED amimimor/ambry Ambry Docker Image 0 civicknowledge/ambry Public data ETL framework 0 [OK] sandinh/ambry dockerize for linkedin [ambry] 0 [OK] sivabalan/ambry Adding docker support for ambry 0 [OK] sivabalan/ambryfe Ambry FE using in memory router factory 0 [OK] sandinh/ambry-import-xenforo import xenforo avatars, attachments to ambry 0 maciejbak85/ambry Distributed object store https://github.com 0 civicknowledge/ambry-base 0 gnkr8/ambry 0 ktimothy/ambry 0 wdnmdcyka/ambry-server linkedin/ambry server image 0 wdnmdcyka/ambry-client linkedin/ambry fronted image 0 需要下载 wdnmdcyka/ambry-server、wdnmdcyka/ambry-client[root@izwz94ymqw967redc0vyeoz ~]# docker pull wdnmdcyka/ambry-server:1.0 [root@izwz94ymqw967redc0vyeoz ~]# docker pull wdnmdcyka/ambry-client:1.0部署方式按照官网传统部署方式，需要部署ambry的服务端和ambry的前端，前端不负责存储，所有的文件都是在服务端存储，前端只是负责转发请求和组织服务端存储首先部署ambry-server: docker run -d -v ${your config dir}:/app/config -v ${your tmp dir}:/tmp -v ${your logs dir}:/app/logs -p 6667:6667 -p 16503:16503 --restart always --name ambry-server wdnmdcyka/ambry-server:tagname说明：其中挂载出来的目录有ambry的配置文件目录，/tmp为服务端存储文件的目录，/app/logs为ambry生成日志存储的目录暴露的端口6667为server和client通信的端口部署ambry-client：docker run -d -v ${your config dir}:/app/config -v ${your logs dir}:/app/logs -p 1174:1174 --restart always --name ambry-client wdnmdcyka/ambry-client:tagname说明：由于client端不负责存储，所以没有挂载/tmp目录，1174端口是ambry暴露的rest接口所使用的端口配置文件获取地址：https://github.com/linkedin/ambry/tree/master/config测试如果配置无误，直接请求 http://localhost:1174/healthCheck ，如果返回 GOOD 则部署成功!","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://ubisoft-potato.github.io/tags/文件上传/"},{"name":"分布式文件服务","slug":"分布式文件服务","permalink":"https://ubisoft-potato.github.io/tags/分布式文件服务/"}]},{"title":"springBoot统一异常处理","slug":"springBoot统一异常处理","date":"2019-09-28T12:33:00.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/28/springboot-tong-yi-yi-chang-chu-li/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/28/springboot-tong-yi-yi-chang-chu-li/","excerpt":"如何在springBoot优雅的处理异常？异常处理在任何项目中都尤为重要，所以这使得如何统一处理异常变得非常重要，本文记录在SpringBoot中解决统一异常处理最优雅的方式。","text":"如何在springBoot优雅的处理异常？异常处理在任何项目中都尤为重要，所以这使得如何统一处理异常变得非常重要，本文记录在SpringBoot中解决统一异常处理最优雅的方式。spring 3.2新增注解@ControllerAdvice package org.springframework.web.bind.annotation; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface ControllerAdvice { @AliasFor(\"basePackages\") String[] value() default {}; @AliasFor(\"value\") String[] basePackages() default {}; Class&lt;?>[] basePackageClasses() default {}; Class&lt;?>[] assignableTypes() default {}; Class&lt;? extends Annotation>[] annotations() default {}; }ControllerAdvice拆分开来就是Controller Advice，关于Advice，可以理解为AOP面向切面编程中的环绕增强，为指定范围内的controller进行相应方法的增强代理。结合方法型注解@ExceptionHandler，用于捕获Controller中抛出的指定类型的异常，从而达到不同类型的异常区别处理的目的；@ControllerAdvice的用法基本是将其声明在某个bean上，然后在该bean的方法上使用其他的注解来指定不同的织入逻辑。不过这里@ControllerAdvice并不是使用AOP的方式来织入业务逻辑的，而是Spring内置对其各个逻辑的织入方式进行了内置支持@ExceptionHandler注解@ExceptionHandler的作用主要在于声明一个或多个类型的异常,当符合条件的Controller抛出这些异常之后将会对这些异常进行捕获，然后按照其标注的方法的逻辑进行处理，从而改变返回的信息@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface ExceptionHandler { // 指定需要捕获的异常的Class类型 Class&lt;? extends Throwable>[] value() default {}; }实例说明统一异常配置类@ControllerAdvice(basePackages = \"xxx.xxx\")//指定controller所在的包 public class MyExceptionHandler { @ExceptionHandler(Exception.class)//需要处理的异常类型 @ResponseBody public Map&lt;String, String> handleException(Exception e) { HashMap&lt;String, String> errorMap = new HashMap&lt;>(); errorMap.put(\"errorMsg\", e.getMessage()); errorMap.put(\"code\", 500 + \"\"); return errorMap; } }写个简单的controller 直接抛出异常@RestController public class MyController { @GetMapping(\"/test\") public void test() { throw new ArrayIndexOutOfBoundsException(\"数组越界\"); } }访问 /test 并没有直接返回结果 而是上述返回异常处理的map{ &quot;code&quot;:500, &quot;errorMsg&quot;:&quot;数组越界&quot; }","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://ubisoft-potato.github.io/tags/异常处理/"}]},{"title":"mapstruct在SpringBoot中的使用","slug":"mapstruct在SpringBoot中的使用","date":"2019-09-26T12:54:38.000Z","updated":"2020-08-19T07:40:51.019Z","comments":true,"path":"2019/09/26/mapstruct-zai-springboot-zhong-de-shi-yong/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/26/mapstruct-zai-springboot-zhong-de-shi-yong/","excerpt":"MapStruct是什么MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach.MapStruct是一个极大简化javaBean之间互相转换的代码生成器，即简化实体类DTO的互相转化官方文档（https://mapstruct.org/documentation/stable/reference/html/#defining-mapper）","text":"MapStruct是什么MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach.MapStruct是一个极大简化javaBean之间互相转换的代码生成器，即简化实体类DTO的互相转化官方文档（https://mapstruct.org/documentation/stable/reference/html/#defining-mapper）maven依赖 &lt;properties> &lt;org.mapstruct.version>1.3.0.Final&lt;/org.mapstruct.version> &lt;/properties> &lt;dependency> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct-jdk8&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct-processor&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;scope>provided&lt;/scope> &lt;/dependency>集成MapStruct官方提供了两种方式，上面配置文件内我们采用的是直接添加Maven依赖，而官方文档还提供了另外一种方式，采用Maven插件形式配置，配置如下所示： &lt;properties> &lt;org.mapstruct.version>1.3.0.Final&lt;/org.mapstruct.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.5.1&lt;/version> &lt;!-- or newer version --> &lt;configuration> &lt;source>1.8&lt;/source> &lt;!-- depending on your project --> &lt;target>1.8&lt;/target> &lt;!-- depending on your project --> &lt;annotationProcessorPaths> &lt;path> &lt;groupId>org.mapstruct&lt;/groupId> &lt;artifactId>mapstruct-processor&lt;/artifactId> &lt;version>${org.mapstruct.version}&lt;/version> &lt;/path> &lt;!-- other annotation processors --> &lt;/annotationProcessorPaths> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build>一对一转换//实体类 public class Customer { private Long id; private String name; //getters and setter omitted for brevity } //DTO public class CustomerDto { public Long id; public String customerName; } //(org.mapstruct.Mapper) annotation @Mapper public interface CustomerMapper { CustomerMapper INSTANCE = Mappers.getMapper( CustomerMapper.class ); //相同属性不需要用@Mapping指定，如Customer和CustomerDto中的id //customerName与name不同，则必须指定 @Mapping(source = \"customerName\", target = \"name\") Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer); }可以看到CustomerMapper是一个接口的形式存在的，当然也可以是一个抽象类，如果需要在转换的时候才用个性化的定制的时候可以采用抽象类的方式，相应的代码配置官方文档已经声明。@Mapper注解是用于标注接口、抽象类是被MapStruct自动映射的标识，只有存在该注解才会将内部的接口方法自动实现。使用方式1：不需要做过多的配置内容，获取Mapper的方式就是采用Mappers通过动态工厂内部反射机制完成Mapper实现类的获取。public class MapStructTest { @Test public void directMapping() { Customer customer = new Customer(); customer.setId(12L); customer.setName(\"customer001\"); CustomerDto customerDto = CustomerConverter.INSTANCE.fromCustomer(customer); System.out.println(\"customerDto = \" + customerDto); } }使用方式2：使用springBoot依赖注入// Specifies the component model to which the generated mapper should adhere. Supported values are //指定mapper的注入模板 :cdi spring jsr330 //@mapper添加参数 componentModel = \"spring\" @Mapper(componentModel = \"spring\") public interface CustomerConverter { CustomerConverter INSTANCE = Mappers.getMapper(CustomerConverter.class); @Mapping(source = \"customerName\", target = \"name\") Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer); } public class MapStructTest { //使用autowired自动注入 @Autowired private CustomerConverter customerConverter; @Test public void directMapping() { Customer customer = new Customer(); customer.setId(12L); customer.setName(\"customer001\"); // CustomerDto customerDto = CustomerConverter.INSTANCE.fromCustomer(customer); CustomerDto customerDto = customerConverter.fromCustomer(customer); System.out.println(\"customerDto = \" + customerDto); } }结果： customerDto = CustomerDto(id=12, customerName=customer001)IDEA插件: MapStruct Support安装idea插件MapStruct Support在编写mapper时可以提示不相同的属性映射@Mapper(componentModel = \"spring\") public interface CustomerConverter { CustomerConverter INSTANCE = Mappers.getMapper(CustomerConverter.class); @Mapping(source = \"customerName\", target = \"name\") //插件可以提示source和target参数 Customer toCustomer(CustomerDto customerDto); @InheritInverseConfiguration CustomerDto fromCustomer(Customer customer); }实体类中有List属性的转换@Data public class Student { private Integer id; private String name; private Integer age; private String sex; } @Data public class Teacher { private List&lt;Student> students; } @Data public class StudentDto { private Integer id; private String name; private Integer age; private String gender; } @Data public class TeacherDto { private List&lt;StudentDto> studentDtos; }要将teacher转换到teacherDto，按照以前的方式：把teacher中的List遍历，挨个转换成dto再手动添加到teacherDto中的list中使用mapStruct:@Mapper(componentModel = \"spring\") public interface StudentConverter { //定义student转studentDto @Mapping(target = \"gender\", source = \"sex\") StudentDto studentToDto(Student student); //List&lt;Student> 转 List&lt;StudentDto>，此方法在编译生成后会调用StudentDto studentToDto(Student student); //如果不定义StudentDto studentToDto(Student student); 此方法会报错 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); //Teacher 转 TeacherDto ，此方法调用 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); // 如果没有List&lt;StudentDto> studentToDtoList(List&lt;Student> students); 此方法报错 @Mapping(target = \"studentDtos\", source = \"students\") TeacherDto teacherToDto(Teacher teacher); }测试：public class ApplicationTests { @Autowired StudentConverter studentConverter; @Test public void contextLoads() { Student student1 = new Student(); student1.setId(1); student1.setName(\"sda\"); student1.setAge(12); student1.setSex(\"男\"); Student student2 = new Student(); student2.setId(2); student2.setName(\"asdfd\"); student2.setAge(23); student2.setSex(\"男\"); Teacher teacher = new Teacher(); teacher.setStudents(Arrays.asList(student1, student2)); TeacherDto teacherDto = studentConverter.teacherToDto(teacher); System.out.println(\"teacher = \" + teacher); System.out.println(\"teacherDto = \" + teacherDto); } }结果: teacher = Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]) teacherDto = TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男), StudentDto(id=2, name=asdfd, age=23, gender=男)])多对一这里以二对一为例:实体类: @Data public class School { private Long id; private String address; private String name; } @Data public class Student { private Integer id; private String name; private Integer age; private String sex; } @Data public class Teacher { private List&lt;Student> students; }对应Dto: @Data public class SchoolDto { private Long id; private String address; private String name; private List&lt;TeacherDto> teacherDtos; } @Data public class StudentDto { private Integer id; private String name; private Integer age; private String gender; } @Data public class TeacherDto { private List&lt;StudentDto> studentDtos; }mapper类:@Mapper(componentModel = \"spring\") public interface StudentConverter { //定义student转studentDto @Mapping(target = \"gender\", source = \"sex\") StudentDto studentToDto(Student student); //List&lt;Student> 转 List&lt;StudentDto>，此方法在编译生成后会调用StudentDto studentToDto(Student student); //如果不定义StudentDto studentToDto(Student student); 此方法会报错 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); //Teacher 转 TeacherDto ，此方法调用 List&lt;StudentDto> studentToDtoList(List&lt;Student> students); // 如果没有List&lt;StudentDto> studentToDtoList(List&lt;Student> students); 此方法报错 @Mapping(target = \"studentDtos\", source = \"students\") TeacherDto teacherToDto(Teacher teacher); //多对一时，每个属性最好写上起对应关系，并且此方法能正确执行依赖 TeacherDto teacherToDto(Teacher teacher); //如果teacherToDto方法不存在则会报错 @Mapping(target = \"teacherDtos\", source = \"teachers\") @Mapping(target = \"name\", source = \"school.name\") @Mapping(target = \"id\", source = \"school.id\") @Mapping(target = \"address\", source = \"school.address\") SchoolDto schoolToDto(School school, List&lt;Teacher> teachers); }测试：public class EurkaApplicationTests { @Autowired StudentConverter studentConverter; @Test public void convert() { Student student1 = new Student(); student1.setId(1); student1.setName(\"sda\"); student1.setAge(12); student1.setSex(\"男\"); Student student2 = new Student(); student2.setId(2); student2.setName(\"asdfd\"); student2.setAge(23); student2.setSex(\"男\"); Teacher teacher1 = new Teacher(); teacher1.setStudents(Arrays.asList(student1, student2)); Teacher teacher2 = new Teacher(); teacher2.setStudents(Arrays.asList(student1, student2)); List&lt;Teacher> teachers = Arrays.asList(teacher1, teacher2); School school = new School(); school.setId(123L); school.setAddress(\"育碧，苏维埃\"); school.setName(\"育碧一中\"); //调用mapper转换 SchoolDto schoolDto = studentConverter.schoolToDto(school, teachers); System.out.println(\"school = \" + school); System.out.println(\"teachers = \" + teachers); System.out.println(\"schoolDto = \" + schoolDto); } }运行结果： school = School(id=123, address=育碧，苏维埃, name=育碧一中) teachers = [ Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]), Teacher(students=[Student(id=1, name=sda, age=12, sex=男), Student(id=2, name=asdfd, age=23, sex=男)]) ] schoolDto = SchoolDto( id=123, address=育碧， 苏维埃, name=育碧一中, teacherDtos=[ TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男),StudentDto(id=2, name=asdfd, age=23, gender=男)]), TeacherDto(studentDtos=[StudentDto(id=1, name=sda, age=12, gender=男), StudentDto(id=2, name=asdfd, age=23, gender=男)]) ])","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"javaBean","slug":"javaBean","permalink":"https://ubisoft-potato.github.io/tags/javaBean/"}]},{"title":"docker部署mysql5.7","slug":"docker部署mysql5-7","date":"2019-09-19T12:28:54.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/19/docker-bu-shu-mysql5-7/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/19/docker-bu-shu-mysql5-7/","excerpt":"docker部署mysql与传统方式对比1、传统方式：在linux上直接使用yum安装 或者mysql官网下载 tar.gz安装，使用tar.gz可能还要自己手动解决依赖问题，yum安装虽然解决了依赖问题，但是随着日益增多，其他数据安装，以及开发环境，难免会引起于其他开发环境的冲突2、docker容器化部署docker是基于linux容器技术发展而来，而linux容器技术能做到进程隔离，从而使得各个服务的部署独立，互不干扰，使用docker部署mysql，还可以部署在同一台服务器上部署不同版本的mysql，而互不影响，比起传统方式，既不用担心依赖，也不用担心开发环境不同而造成影响","text":"docker部署mysql与传统方式对比1、传统方式：在linux上直接使用yum安装 或者mysql官网下载 tar.gz安装，使用tar.gz可能还要自己手动解决依赖问题，yum安装虽然解决了依赖问题，但是随着日益增多，其他数据安装，以及开发环境，难免会引起于其他开发环境的冲突2、docker容器化部署docker是基于linux容器技术发展而来，而linux容器技术能做到进程隔离，从而使得各个服务的部署独立，互不干扰，使用docker部署mysql，还可以部署在同一台服务器上部署不同版本的mysql，而互不影响，比起传统方式，既不用担心依赖，也不用担心开发环境不同而造成影响docker化mysql步骤安装dockercentOS 直接使用yum install docker安装debian系列：使用 apt-get install docker拉去dockerhub mysql官方镜像docker pull mysql:5.7下载完成后 ，使用docker images 查看当前所有镜像 如下所示：REPOSITORY TAG IMAGE ID CREATED SIZE mysql 5.7 383867b75fd2 7 days ago 373MB mongo latest cdc6740b66a7 5 weeks ago 361MB可以看到 TAG 下面标着 5.7， 即mysql的5.7版本运行mysql5.7镜像docker run -v ${pwd}/mysql:/var/lib/mysql –name mysql5.7 -d -e MYSQL_ROOT_PASSWORD=root-p 3306:3306 mysql:5.7参数解析：-v ${pwd}/mysql:/var/lib/mysql 把容器里的/var/lib/mysql目录挂载到实体机的当前执行此docker命令的目录下mysql上，这样容器里的数据库文件就映射到了实体机，即使容器挂掉，mysql的数据还在-p 3306：3306 把主机的3306 端口映射到容器的3306端口，使得可以再容器外访问mysql-d 使容器在后太运行-e 指定mysql容器的运行环境参数， MYSQL_ROOT_PASSWORD 可以设定mysql的root账户的密码查看运行结果docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ee000f76f8fd mongo:latest &quot;docker-entrypoint.s…&quot; 2 days ago Up About an hour 0.0.0.0:27017-&gt;27017/tcp mongoDB b32313af6fd9 mysql:5.7 &quot;docker-entrypoint.s…&quot; 3 days ago Up About an hour 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql5.7 此时，可以看到status显示 运行时间，我的已经运行了一小时，如果失败，status会显示为 Exited ，说明容器运行失败，原因基本上是 docker run 命令参数不全或者错误导致的,这时，可以使用数据库连接工具进行连接，也可以进入容器执行sql查看结果，本文以进入容器为例：执行：docker exec -it ${CONTAINER ID} bash 这里填写自己的mysql容器id,-it表示以交互模式进入容器，容器内部就像是一个精简的linux，可以执行 linux基本命令 root@cyka:/docker-all-conf/mysql5.7/conf.d# docker exec -it mysql5.7 bash root@b32313af6fd9:/# 可以看到进入容器后@后已经变成容器id，相当于linux的host 这是可以运行 mysql -uroot -p 输入 密码后进入mysql执行sql root@b32313af6fd9:/# mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.27 MySQL Community Server (GPL) Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | forum-server | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.01 sec) mysql&gt; docker部署mysql5.7完成！如果想配置mysql的配置文件，可以把mysql的配置文件目录挂载，这样就可以自己配置了。","categories":[{"name":"docker","slug":"docker","permalink":"https://ubisoft-potato.github.io/categories/docker/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ubisoft-potato.github.io/tags/mysql/"}]},{"title":"SpringBoot集成graphql文件上传","slug":"SpringBoot集成graphql文件上传","date":"2019-09-13T12:25:11.000Z","updated":"2020-08-19T02:46:13.234Z","comments":true,"path":"2019/09/13/springboot-ji-cheng-graphql-wen-jian-shang-chuan/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/13/springboot-ji-cheng-graphql-wen-jian-shang-chuan/","excerpt":"SpringBoot集成graphql文件上传graphql上传文件所面临的问题在国内，目前使用graphql的公司并不多，facebook设计graphql主要支持是js，对于java的支持主要靠的还是社区，目前使用最多的是graphql-spring-boot与SpringBoot的整合，以及schema解析工具graphql-java-tools，maven依赖如下，但其对Graphql实现的servlet对文件上传的支持却迟迟没有的demo","text":"SpringBoot集成graphql文件上传graphql上传文件所面临的问题在国内，目前使用graphql的公司并不多，facebook设计graphql主要支持是js，对于java的支持主要靠的还是社区，目前使用最多的是graphql-spring-boot与SpringBoot的整合，以及schema解析工具graphql-java-tools，maven依赖如下，但其对Graphql实现的servlet对文件上传的支持却迟迟没有的demo &lt;dependency> &lt;groupId>com.graphql-java-kickstart&lt;/groupId> &lt;artifactId>graphql-spring-boot-starter&lt;/artifactId> &lt;version>5.9.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.graphql-java-kickstart&lt;/groupId> &lt;artifactId>graphql-java-tools&lt;/artifactId> &lt;version>5.6.1&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.graphql-java-kickstart&lt;/groupId> &lt;artifactId>graphiql-spring-boot-starter&lt;/artifactId> &lt;version>5.6.0&lt;/version> &lt;/dependency> 解决方案于是本人就上stackoverflow求助各路大神，但是由于graphql文件上传过于冷门，没人回答最终还是得靠自己解决，附上原文链接，有兴趣得朋友可以看看How to upload files with graphql-java?","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://ubisoft-potato.github.io/tags/文件上传/"},{"name":"graphql-java","slug":"graphql-java","permalink":"https://ubisoft-potato.github.io/tags/graphql-java/"}]},{"title":"SpringBoot自定义自动配置","slug":"SpringBoot自定义自动配置","date":"2019-09-08T08:26:34.000Z","updated":"2020-08-19T02:46:13.233Z","comments":true,"path":"2019/09/08/springboot-zi-ding-yi-zi-dong-pei-zhi/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/08/springboot-zi-ding-yi-zi-dong-pei-zhi/","excerpt":"前言为什么需要自定义spring自动配置?在很多时候，我们会需要开发一些公共组件jar包，同时我们又希望能在项目启动时自动加载，所以可以通过自定义自动配置包来到达此目的。","text":"前言为什么需要自定义spring自动配置?在很多时候，我们会需要开发一些公共组件jar包，同时我们又希望能在项目启动时自动加载，所以可以通过自定义自动配置包来到达此目的。准备工作自动配置原理如果不懂springboot自动配置原理，可以看我之前一篇springboot自动配置原理maven引入springboot核心依赖版本依赖父工程的springboot版本号，可自行决定&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>your-version&lt;/version> &lt;relativePath/> &lt;!-- lookup parent from repository --> &lt;/parent> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;/project>开发需要自动注入的组件 import org.apache.ibatis.datasource.pooled.PooledDataSource; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; @Configuration public class AutoConfigDemo { @Bean @ConditionalOnClass(PooledDataSource.class) public DataSource MyDataSource() { //比如自己注入一个apache的数据源 return new PooledDataSource(); } }上述代码首先在类上添加了@configuration注解，说明这是一个配置类，此时这个类就相当于ssm项目中的applicationContext.xml， @Bean 标注的方法则相当于applicationContext.xml中如下配置:说明：@ConditionalOnClass(PooledDataSource.class)，意为当PooledDataSource类存在时才注入这个bean，可以实现注入bean控制&lt;bean id=&quot;MyDataSource&quot; class=&quot;org.apache.ibatis.datasource.pooled.PooledDataSource&quot;/&gt;但是这个项目如果直接作为jar包导入你的主项目里，还不能实现自动注入，我们还需要在resource下建立 META-INF/spring.factories ， 如自动配置文中所述位置, 需要注意的是 文件夹必须叫META-INF，文件名也必须是spring.factories，否则无法实现自动注入， 最后 spring.factories 添加如下内容文件位置如下：&lt;bean id=&quot;MyDataSource&quot; class=&quot;org.apache.ibatis.datasource.pooled.PooledDataSource&quot;/&gt;但是这个项目如果直接作为jar包导入你的主项目里，还不能实现自动注入，我们还需要在resource下建立 META-INF/spring.factories ， 如自动配置文中所述位置, 需要注意的是 文件夹必须叫META-INF，文件名也必须是spring.factories，否则无法实现自动注入， 最后 spring.factories 添加如下内容文件位置如下：org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.xxx.xxx.xxx.AutoConfigDemocom.xxx.xxx.xxx.AutoConfigDemo 是我们的配置类全类名 测试将项目打成jar包，在主项目中引入，启动主项目，实现自动注入","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"自定义","slug":"自定义","permalink":"https://ubisoft-potato.github.io/tags/自定义/"}]},{"title":"SpringBoot自动配置原理","slug":"SpringBoot自动配置原理","date":"2019-09-07T09:38:26.000Z","updated":"2020-08-19T02:46:13.233Z","comments":true,"path":"2019/09/07/springboot-zi-dong-pei-zhi-yuan-li/","link":"","permalink":"https://ubisoft-potato.github.io/2019/09/07/springboot-zi-dong-pei-zhi-yuan-li/","excerpt":"自动配置原理关键注解@SpringBootApplication点击进入@SpringBootApplication注解代码@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { }","text":"自动配置原理关键注解@SpringBootApplication点击进入@SpringBootApplication注解代码@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { }其中包含@EnableAutoConfiguration注解:意为开启自动配置（顺便一提:@ComponentScan注解这个注解会扫描和加了这个注解的类在同一包和子包下的所有组件即:Controller、service等,为我们省去了写xml配置文件的过程）,再点击进入@EnableAutoConfiguration注解@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?>[] exclude() default {}; String[] excludeName() default {}; }这个注解有2个方法: exclude 和 excludeName，在@SpringBootApplication中可以通过使用这两个方法来指明我们不想自动注入的类比如：我们不想让springBoot自动配置数据源（springBoot默认HikariCP连接池），这样可以自己注入数据源，达到切换连接池的目的@SpringBootApplication(exclude = DataSourceAutoConfiguration.class) public class ForumServiceApplication { public static void main(String[] args) { SpringApplication.run(ForumServiceApplication.class, args); } }@Import(AutoConfigurationImportSelector.class),@import注解表示引入指定类型的bean，即AutoConfigurationImportSelector，springBoot为我们自动注入的bean全部通过它来读取,点击进入AutoConfigurationImportSelector源码public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry( autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } protected AutoConfigurationEntry getAutoConfigurationEntry( AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String> configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String> exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } protected List&lt;String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String> configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } }getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);AutoConfigurationImportSelector通过getAutoConfigurationEntry这个方法获取到需要自动注入的类，getAutoConfigurationEntry又调用了getCandidateConfigurations(annotationMetadata,attributes),getCandidateConfigurations调用SpringFactoriesLoader类的静态方法，进入SpringFactoriesLoader中，这个类是spring-core包中的public final class SpringFactoriesLoader { /** * The location to look for factories. * &lt;p>Can be present in multiple JAR files. */ public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; }自动配置核心文件通过源码注释可以看到 FACTORIES_RESOURCE_LOCATION，并且位置为META-INF/spring.factories, spring.factories是本文重点部分spring.factories内容： # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\ org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.EnableAutoConfiguration=下面所有的自动配置类将被springBoot自动注入，通过spring.factories我们可以自定义自动配置类，实现springboot容器启动时自动注入的效果","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://ubisoft-potato.github.io/categories/SpringBoot/"}],"tags":[{"name":"自动配置","slug":"自动配置","permalink":"https://ubisoft-potato.github.io/tags/自动配置/"}]}]}